<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[河北工业大学ACM集训队日常训练day1030]]></title>
    <url>%2F2018%2F11%2F04%2FACM%E9%A2%98%E7%9B%AE%2F%E6%B2%B3%E5%8C%97%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6ACM%E9%9B%86%E8%AE%AD%E9%98%9F%E6%97%A5%E5%B8%B8%E8%AE%AD%E7%BB%83day1030%2F</url>
    <content type="text"><![CDATA[emmm.昨天刚到青岛.今天热身赛结束.非常想记录的一点就是.这个酒店太豪了.早餐特别豪.还有浴池.orz.要加油努力赚钱买大房子呀.补了一下题.记录一下. 河北工业大学ACM集训队日常训练day1030原:Codeforces Round #490 (Div. 3) A.Mishka and Contest题目大意:easy~ 题解:easy~ 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int n, k;int a[110];int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); while(cin &gt;&gt; n &gt;&gt; k)&#123; for(int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; int ans = 0; int i; for(i = 1; i &lt;= n; ++i)&#123; if(a[i] &lt;= k) ++ans; else break; &#125; for(int j = n; j &gt; i; --j)&#123; if(a[j] &lt;= k) ++ans; else break; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; C.Alphabetic Removals题目大意:easy~ 题解:easy~ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 4*1e5+100;int n,k;char s[MAX_N];int t[26];int can[26];int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); while(cin &gt;&gt; n &gt;&gt; k)&#123; cin &gt;&gt; s; memset(t, 0, sizeof t); int len = strlen(s); for(int i = 0; i &lt; len; ++i)&#123; ++t[s[i] - 'a']; &#125; for(int i = 0; i &lt; 26; ++i) can[i] = t[i]; for(int i = 0; i &lt; 26; ++i)&#123; if(t[i] != 0) &#123; if(k - t[i] &gt;= 0) &#123; can[i] = 0; k -= t[i]; &#125; else &#123; can[i] -= k; break; &#125; &#125; &#125; for(int i = 0; i &lt; len; ++i)&#123; int cur = s[i] - 'a'; if(can[cur] &lt; t[cur]) &#123; ++can[cur]; &#125; else &#123; putchar(s[i]); &#125; &#125; putchar('\n'); &#125; return 0;&#125; E.Reachability from the Capital题目大意:有一个有向图.求最少添加几条边使得从s可以到达其他所有点. 题解:(1)dfs标记所有从s可达的点是good(2)对于每个bad的结点.统计其他同样是bad的结点可以到达它的数量.v结点计算出的值是cnt(v)(3)一次遍历非增序列cnt(v),从大到小遍历.如果它还是bad.从它dfs.标记所有可达的点是good.ans加1.相当于加了一条边(s,v) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 5*1e3+100;typedef pair&lt;int, int&gt; P;vector&lt;int&gt; G[MAX_N];vector&lt;P&gt; bad;bool has[MAX_N];bool color[MAX_N];int cnt;int n,m,s;void dfs(int u)&#123; has[u] = true; for(int i = 0; i &lt; G[u].size(); ++i)&#123; int v = G[u][i]; if(!has[v]) dfs(v); &#125;&#125;// 统计从bad的点u出发能到达的bad点void dfs2(int u)&#123; ++cnt; color[u] = true; for(int i = 0; i &lt; G[u].size(); ++i)&#123; int v = G[u][i]; if(!color[v] &amp;&amp; !has[v]) dfs2(v); &#125;&#125;int main()&#123; // freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int u,v; while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; s)&#123; memset(has, false, sizeof has); bad.clear(); for(int i = 0; i &lt;= n; ++i) G[i].clear(); for(int i = 0; i &lt; m; ++i)&#123; cin &gt;&gt; u &gt;&gt; v; G[u].push_back(v); &#125; dfs(s); for(int i = 1; i &lt;= n; ++i)&#123; if(!has[i]) &#123; cnt = 0; memset(color, false, sizeof color); dfs2(i); bad.push_back(P(cnt, i)); &#125; &#125; sort(bad.begin(), bad.end(), greater&lt;P&gt;()); int ans = 0; for(auto &amp;x: bad)&#123; int u = x.second; if(!has[u])&#123; ++ans; dfs(u); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; F.Cards and Joy题目大意:有n个人.有k*n张牌.第i张牌的权值是c_i第j个人喜欢的数字是f_j有一个等级序列.h1,h2,…,hk每个人发k张牌.如果对于第j个人.他分到的牌的权值是他喜欢的数字f_j的牌的数量是t.他的等级就是h[t].注意h[0] = 0.求一种方案.使得n个人的等级和最大输出最大的等级和. 题解:如果喜欢某个数字的人数是x.这个数字的卡牌有y个.也就是这y张卡牌怎么分给这x个人使得等级之和最大.可以看出.和数字本身是几没有关系.只和x,y有关系.dp[x][y] ::= 喜欢某个数字的人数是x(0 &lt;= x &lt;= n),是这个数字的卡牌有y(0 &lt;= y &lt;= k*n)张时候最优的方案得到等级和最大.如果我们求出了dp[x][y].$ans = \sum_{i = 1}^{1e5} dp[f[i]][c[i]]$ 容易知道dp[0][y] = dp[x][0] = 0.状态转移方程:$dp[x][y] = \max dp[x-1][y-i] + h[i], 0 &lt;= i &lt;= k$解释一下:就是有x个人y张牌的时候的最大值.是安排第x个人i张喜欢的牌.加上剩下x-1个人安排y-i张牌.类似背包时间复杂度$O(n^2*k^2)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;// http://codeforces.com/problemset/problem/999/Ftypedef long long LL;const int MAX_N = 1e5+10;int f[MAX_N], c[MAX_N];int dp[510][5100];int h[15];int n,k;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int x; cin &gt;&gt; n &gt;&gt; k; memset(c, 0, sizeof c); memset(f, 0, sizeof f); memset(dp, 0, sizeof dp); for(int i = 0; i &lt; n*k; ++i) &#123; cin &gt;&gt; x; ++c[x]; &#125; for(int i = 0;i &lt; n; ++i)&#123; cin &gt;&gt; x; ++f[x]; &#125; h[0] = 0; for(int i = 1; i &lt;= k; ++i)&#123; cin &gt;&gt; h[i]; &#125; for(int i = 1; i &lt;= n; ++i)&#123; for(int j = 1; j &lt;= n*k; ++j)&#123; for(int l = 0; l &lt;= min(j, k); ++l)&#123; dp[i][j] = max(dp[i][j], dp[i-1][j-l] + h[l]); &#125; &#125; &#125; LL ans = 0; for(int i = 0; i &lt; MAX_N; ++i)&#123; if(f[i] != 0) ans += dp[f[i]][c[i]]; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM题目</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[河北工业大学ACM选拔赛10月末]]></title>
    <url>%2F2018%2F10%2F28%2FACM%E9%A2%98%E7%9B%AE%2F%E6%B2%B3%E5%8C%97%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6ACM%E9%80%89%E6%8B%94%E8%B5%9B10%E6%9C%88%E6%9C%AB%2F</url>
    <content type="text"><![CDATA[河北工业大学ACM选拔赛 emmm.我校ACM集训队喜提实验室orz. C.强迫症题目大意:给树染色.相邻结点的颜色不同.求最后的颜色.后面的颜色会覆盖前面的.没有染色成功的输出0 题解由于是一棵树,一个树结点和他相邻的结点就是以这个结点作为根的直接孩子还有他的父亲.所以考虑先把无根树转换成有根树.这样就得到了每个结点的直接孩子.每个结点维护一个多重集合.里面存它的所有直接孩子的颜色.所以我们可以以$O(1)$的复杂度得到他的父亲的颜色.以$O(logN)$的复杂度得到他的孩子里面任意一个颜色.对于每个结点$x$.想要将$x$染成$y$.如果$x$的父亲$fa[x]$的颜色是$y$.或者$x$的孩子结点中有颜色是$y$的点.那么这个点我们不能染.否则.如果这个点曾经染过别的颜色.现在要更新.需要维护父亲$fa[x]$的多重集合.先删除$x$之前的颜色.再插入新的颜色.所以.总的复杂度大概是$O(MlogN)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 1e5+100;int N,M;int fa[MAX_N];vector&lt;int&gt; G[MAX_N];multiset&lt;int&gt; S[MAX_N];int color[MAX_N];void dfs(int u, int f)&#123; fa[u] = f; for(int i = 0; i &lt; G[u].size(); ++i)&#123; int v = G[u][i]; if(v != f) dfs(v, u); &#125;&#125;int main()&#123; //freopen("in.txt", "r", stdin); int u,v; int x,y; while(~scanf("%d%d", &amp;N, &amp;M))&#123; for(int i = 0;i &lt;= N; ++i) &#123; G[i].clear(); S[i].clear(); &#125; memset(color, 0, sizeof color); for(int i = 0;i &lt; N-1; ++i)&#123; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1, 0); for(int i = 0;i &lt; M; ++i)&#123; scanf("%d%d", &amp;x, &amp;y); // 判断 if(color[fa[x]] == y || S[x].find(y) != S[x].end()) continue; // 维护父亲 if(color[x]) S[fa[x]].erase(S[fa[x]].find(color[x])); S[fa[x]].insert(y); color[x] = y; &#125; for(int i = 1;i &lt;= N; ++i)&#123; printf("%d\n", color[i]); &#125; &#125; return 0;&#125; F.选举题目大意n个人,m个城市.第i行j列代表第i个城市给第j的编号的人投出的票数.第一轮.每个城市胜出且编号小的贡献加一.第二轮每个人贡献最大且编号最小的是最终的答案.输出每组样例胜出的人的编号. 题解题目大意就是题解.一场cf的div 2的A 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;// Elections#define MAX_N 105int n,m;int sum[MAX_N];int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int x; while(cin &gt;&gt; n &gt;&gt; m)&#123; // n个候选人. m个城市 memset(sum, 0, sizeof(sum)); for(int i = 1; i &lt;= m; ++i)&#123; int idx = 1, maxx = 0; for(int j = 1; j &lt;= n; ++j)&#123; cin &gt;&gt; x; if(maxx &lt; x)&#123; idx = j; maxx = x; &#125; &#125; ++sum[idx]; &#125; int ansidx = 1; int maxx = sum[1]; for(int i = 2; i &lt;= n; ++i)&#123; if(maxx &lt; sum[i])&#123; maxx = sum[i]; ansidx = i; &#125; &#125; cout &lt;&lt; ansidx &lt;&lt; endl; &#125; return 0;&#125; G.信号与系统题目大意 题解emm.大概就是看图按照这个意思理解.一道cf div2的C题. 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define MAX_N 55char s[MAX_N];// emm.这个函数有一个隐藏特性.就是如果参数c不是26个字母的话.返回c的ASCII值int idx(char c)&#123; if(c &gt;= 'A' &amp;&amp; c &lt;= 'Z') return c - 'A' +1; if(c &gt;= 'a' &amp;&amp; c &lt;= 'z') return c - 'a' +1;&#125;int main()&#123; //freopen("in.txt", "r", stdin); while(~scanf("%s", s))&#123; char a[5] = "@[`&#123;"; LL res = 0; for(int i = 0; s[i]; ++i)&#123; char b = s[i]; int f1 = (a[0] &lt; b) &amp; (a[1] &gt; b); int f2 = (a[2] &lt; b) &amp; (a[3] &gt; b); res += (f1 * idx(b) - f2 * idx(b)); &#125; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; H.大数GCD题目大意$1 &lt;= a &lt;= b &lt;= 10^{100}$. 求$gcd(a, a+1, a+2, …, b)$. 题解emmm.看题目被大数GCD吓一跳.想用大数写一个欧几里得.细读的话会发现.当$a &lt;= b$的时候$gcd(a,a+1,a+1,…b) = gcd(gcd(a,a+1),a+2,..,d) = gcd(1,a+2,..,d) = 1$.当$a==b$的时候.两个相等的数的最大公约数就是$a$.一道cf的div2A 1234567891011121314#include &lt;bits/stdc++.h&gt;// 1966: Complicated GCDusing namespace std;int main() &#123; //freopen("in.txt", "r", stdin); string a, b; cin &gt;&gt; a &gt;&gt; b; if (a == b) cout &lt;&lt; a; else cout &lt;&lt; 1; return 0;&#125; I 计算之神 代码里面注释的是原题链接.这道题是当时暑假参加ccpc-wannafly的时候做的题.当时没有做出来.orz.后面牛客重现赛的时候做出来的. 题目大意$$ f(l, r) = (\sum_{i=l}^r{a_i})*w_{r-l+1} $$求解:$$ \sum_{l=1}^r{\sum_{r=l}^n{f(l, r)}} $$ 题解两个式子看起来很复杂.无脑暴力一定超时.emmm.具体计算下次再更新.大概就是去掉重复的计算.上代码.orz. 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std; /*https://www.nowcoder.com/acm/contest/204/G*/const int MAX_N = 3*1e5+100;typedef long long LL;const LL MOD = 1e9+7;int n;LL a[MAX_N], w[MAX_N], sum[MAX_N]; inline LL getSum(int l, int r)&#123; return (sum[r] - sum[l-1]) % MOD;&#125; int main()&#123; // freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n; memset(sum, 0, sizeof(sum)); for(int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; sum[i] = (sum[i-1] + a[i]) % MOD; &#125; for(int i = 1; i &lt;= n; ++i) cin &gt;&gt; w[i]; LL ans = 0LL, x = 0LL; for(int i = 1; i &lt;= n &gt;&gt; 1; ++i)&#123; x = (x + getSum(i, n-i+1)) % MOD; ans += (((w[i] + w[n-i+1]) % MOD) * (x % MOD)) % MOD; &#125; if(n &amp; 1) &#123; int i = (n &gt;&gt; 1) + 1; ans += w[i] * (x + a[i]) % MOD; &#125; cout &lt;&lt; ans% MOD &lt;&lt; endl; return 0;&#125; J.莱昂哈德·欧拉 emm.这道题出自牛客的一场小白月赛.记得那次出题人背B题的锅.被骂得很严重 题目大意求$[l,r]$之间有约束的数字的个数. 题解裸数位dp.emmm.后面细更 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;// https://www.nowcoder.com/acm/contest/214/Etypedef long long LL;const LL MOD = 20020219;const int INF = 63;#define MAX_N 25LL f[MAX_N][11][INF+1];int t;LL l,r;int n;int lim[11],x,len;int num[MAX_N];LL dfs(int pos, bool limit, int pre, int cnt)&#123; if(cnt &gt; lim[pre]) return 0; if(pos == 0) return 1; if(!limit &amp;&amp; f[pos][pre][cnt] != -1) return f[pos][pre][cnt]; // 计算过了 int up = limit ? num[pos] : 9; LL tmp = 0; for(int i = 0;i &lt;= up; ++i)&#123; tmp = (tmp + dfs(pos-1, limit &amp;&amp; num[pos] == i, i, i == pre ? cnt+1 : 1) + MOD) % MOD; &#125; return limit ? tmp : f[pos][pre][cnt] = tmp % MOD;&#125;LL solve(LL x)&#123; if(x == -1) return 0; int pos = 0; while(x)&#123; num[++pos] = int(x%10); x /= 10; &#125; // pre初始值是0.orz.就过了.因为对0没有限制.不能设置成-1.因为数组下标没有-1 return dfs(pos, true, 0, 1) % MOD;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; n; for(int i = 0;i &lt; 10; ++i) lim[i] = INF; for(int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; x &gt;&gt; len; lim[x] = min(lim[x], len); &#125; memset(f, -1, sizeof f); cout &lt;&lt; (solve(r) - solve(l-1) + MOD) % MOD &lt;&lt; endl; &#125; return 0;&#125; L 超市活动题目大意在$n*m$的格子中取数满足取得数字格子之间没有公共边.求取出数字的最大和. 题解n和m比较小.网络流.emmm.后面细更.这道题目的代码我没动手.拿的别人的代码.昨天晚上突然很怕今天有人AK。所以加上了这道题目. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 50*50;const int INFS = 0x7FFFFFFF;struct edge &#123; int from, to, cap, flow; edge(int _from, int _to, int _cap, int _flow) : from(_from), to(_to), cap(_cap), flow(_flow) &#123;&#125;&#125;;class Dinic &#123;public: void initdata(int n, int s, int t) &#123; this-&gt;n = n, this-&gt;s = s, this-&gt;t = t; edges.clear(); for (int i = 0; i &lt; n; i++) G[i].clear(); &#125; void addedge(int u, int v, int cap) &#123; edges.push_back(edge(u, v, cap, 0)); edges.push_back(edge(v, u, 0, 0)); G[u].push_back(edges.size() - 2); G[v].push_back(edges.size() - 1); &#125; bool BFS() &#123; for (int i = 0; i &lt; n; i++) vis[i] = false, d[i] = 0; queue&lt;int&gt; Q; Q.push(s); vis[s] = true; while (!Q.empty()) &#123; int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); i++) &#123; edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; !vis[e.to]) &#123; vis[e.to] = true; d[e.to] = d[x] + 1; Q.push(e.to); &#125; &#125; &#125; return vis[t]; &#125; int DFS(int x, int aug) &#123; if (x == t || aug == 0) return aug; int flow = 0; for (int i = 0; i &lt; G[x].size(); i++) &#123; edge&amp; e = edges[G[x][i]]; if (d[e.to] == d[x] + 1) &#123; int f = DFS(e.to, min(aug, e.cap - e.flow)); if (f &lt;= 0) continue; e.flow += f; edges[G[x][i]^1].flow -= f; flow += f; aug -= f; if (aug == 0) break; &#125; &#125; return flow; &#125; int maxflow() &#123; int flow = 0; while (BFS()) &#123; flow += DFS(s, INFS); &#125; return flow; &#125;private: vector&lt;edge&gt; edges; vector&lt;int&gt; G[MAXN]; int n, s, t, d[MAXN]; bool vis[MAXN];&#125;;Dinic dc;int row, col;int dir[4][2] = &#123;1, 0, -1, 0, 0, 1, 0, -1&#125;;bool check(int x, int y) &#123; if (1 &lt;= x &amp;&amp; x &lt;= row &amp;&amp; 1 &lt;= y &amp;&amp; y &lt;= col) &#123; return true; &#125; return false;&#125;int main() &#123; //freopen("in.txt", "r", stdin); scanf("%d%d", &amp;row, &amp;col); int sum = 0; int s = 0, t = row*col + 1; dc.initdata(t + 1, s, t); for (int i = 1; i &lt;= row; i++) &#123; for (int j = 1; j &lt;= col; j++) &#123; int a; scanf("%d", &amp;a); sum += a; if ((i+j) &amp; 1) dc.addedge((i-1)*col+j, t, a); else &#123; dc.addedge(s, (i-1)*col+j, a); for (int k = 0; k &lt; 4; k++) &#123; int x = i + dir[k][0]; int y = j + dir[k][1]; if (check(x, y)) dc.addedge((i-1)*col+j, (x-1)*col+y, INFS); &#125; &#125; &#125; &#125; printf("%d\n", sum - dc.maxflow()); return 0;&#125;]]></content>
      <categories>
        <category>ACM题目</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wannafly挑战赛27]]></title>
    <url>%2F2018%2F10%2F27%2FACM%E9%A2%98%E7%9B%AE%2FWannafly%E6%8C%91%E6%88%98%E8%B5%9B27%2F</url>
    <content type="text"><![CDATA[Wannafly挑战赛27 emm.题目说得很明白 A 灰魔法师 AC 题目大意:给出长度为n的序列a, 求有多少对数对 (i, j) (1 &lt;= i &lt; j &lt;= n) 满足 ai + aj 为完全平方数。 题解先找出1到21e5之间所有的完全平方数.有400多个.然后二分计算答案.注意long long.注意$a_i$可能重复.注意计算答案的时候需要分开计算的地方.一个神奇的事情.以为int转成long long.只要一个int数1LL就行了.后面发现是1LL*int.还有一个就是昨天发现的一个神奇的地方.默认返回了ASCII码值.活久见.1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int fun(char c)&#123;&#125;int main()&#123; // freopen("in.txt", "r", stdin); cout &lt;&lt; fun('a') &lt;&lt; endl; cout &lt;&lt; fun('b') &lt;&lt; endl; return 0;&#125; 输出:9798 回到正题.正经代码.复杂度$O((400+)*nlogn)$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std; typedef long long LL;const int MAX_N = 1e5;int n;vector&lt;int&gt; a;vector&lt;int&gt; num;LL len[MAX_N]; void init()&#123; for(int i = 1;i &lt;= 2*MAX_N; ++i)&#123; int x = sqrt(i); if(x*x == i) num.push_back(i); &#125;&#125; int main()&#123; // freopen("in.txt", "r", stdin); init(); int x; while(cin &gt;&gt; n)&#123; memset(len, 0, sizeof len); a.clear(); for(int i = 0; i &lt; n; ++i)&#123; cin &gt;&gt; x; ++len[x]; if(len[x] == 1) a.push_back(x); &#125; sort(a.begin(), a.end()); int sz = a.size(); LL res = 0; LL ans = 0; for(int i = 0; i &lt; num.size(); ++i)&#123; int v = num[i]; for(int j = 0; j &lt; sz; ++j)&#123; if(a[j] &gt; v) continue; vector&lt;int&gt;::iterator idx = lower_bound(a.begin(), a.end(), v - a[j]); if(idx != a.end()) &#123; if(*idx == v - a[j]) &#123; int x = a[j], y = v-a[j]; if(x == y) ans += len[x] * (len[x]-1) / 2LL; else res += len[x] * len[y]; &#125; &#125; &#125; &#125; cout &lt;&lt; res/2LL + ans &lt;&lt; endl; &#125; return 0;&#125; B 紫魔法师 AC 题目大意给一个图(每条边最多被包含于一个环，无自环，无重边，保证连通)，要求用最少的颜色对其顶点染色，满足每条边两个端点的颜色不同，输出最小颜色数即可 题解如果$n==1$.一种颜色.如果是二分图.$2$种颜色.否则.就是有奇数环.就需要$3$种颜色.所以.二分染色即可.emmm.第一次二分染色写错.orz. 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 1e5+100;int color[MAX_N];vector&lt;int&gt; G[MAX_N];int n,m;bool dfs(int u, int c)&#123; color[u] = c; int sz = G[u].size(); for(int i = 0; i &lt; sz; ++i)&#123; int v = G[u][i]; if(!color[v]) &#123; if(!dfs(v, 3-c)) return false; &#125; if(color[v] == color[u]) return false; &#125; return true;&#125;int main()&#123; //freopen("in.txt", "r", stdin); int u,v; while(cin &gt;&gt; n &gt;&gt; m)&#123; for(int i = 1; i &lt;= n; ++i) G[i].clear(); memset(color, 0 ,sizeof color); for(int i = 1; i &lt;= m; ++i)&#123; cin &gt;&gt; u &gt;&gt; v; G[u].push_back(v); G[v].push_back(u); &#125; if(n == 1) &#123;puts("1"); continue;&#125; if(dfs(1, 1)) puts("2"); else puts("3"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM题目</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hebuter Daily Training 201810]]></title>
    <url>%2F2018%2F10%2F19%2FACM%E9%A2%98%E7%9B%AE%2FHebuter%20Daily%20Training%20201810%2F</url>
    <content type="text"><![CDATA[emmm.daily trainning第一天. 题目原题是cf上的Codeforces Beta Round #9 (Div. 2 Only) A Die Roll题目大意:有三个人Y,W,D.每个人都很想去一个地方.但是不好请假.所以能去一个地方就很好了.Y想出来一个方法.每个人掷骰子.点数最多的赢.就可以去他想去的地方.Y,W已经投掷了.求D获胜的概率.输出.0/1表示不可能获胜1/1表示一定获胜. 题解:根据题意的Note可知.假设$a = \max(Y, W);如果D &gt;= a$.是$D$获胜.所以只要求$(6-(a-1))/6$.分子分母约分.假设$x = 6 - a + 1. y = 6. z = gcd(x, y);ans = (x/z)/(y/z). $可以知道不可能有$0/1$的情况 `12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int Y,W; cin &gt;&gt; Y &gt;&gt; W; int a = max(Y, W); int x = 6 - a + 1, y = 6, z = __gcd(x, y); cout &lt;&lt; x/z &lt;&lt; "/" &lt;&lt; y/z &lt;&lt; endl; return 0;&#125; B Interestring graph and Apples.题目大意:一个无向图被称作interesting.当且仅当它的顶点只属于一个funny ring.funny ring的定义就是一个环可以遍历所有顶点只有一次.一个圈也是一个funny ring.最少添加多少条边使得当前图成为interesting.输出字典序最小的添加顺序. 题解:可以肯定的是interesting graph就是一个funny ring.它有n个顶点n条边.因为n个顶点n-1条边是树.多一条边就有一个环.如果再多一条边就是多余两个环了.不满足定义. 一个图是一个funny ring当且仅当满足下面两个条件A1. 每个点的度数是2.A2. 图是连通的 现在我们找到当一个图不是funny ring.但是通过添加边.可以转换成funny ringB1. m &lt; n. 边的数量少于点的数量.B2. 没有环B3. 每个点的度数都不超过2 我们需要添加一些边使得这些条件都满足.并且这个添加序列是字典序最小的.所以我们按照如下规则添加边(i,j). i,j两个点的度数都小于2.(打破条件B3) i,j属于两个不同的连通分量(打破条件B2) (i,j)字典序最小 我们什么时候不能再添加边.当没有环的时候.每个连通分量是一颗树.因此至少有一个点的度数小于2(根).如果有两个连通分量.连接的话就可以打破条件B1-B3所以图连通,没有环,每个点的度数不超过2.意味着获得的图知识一条链.我们可以连接它的结束的点获得一个funny ring. 通过上面的描述.算法: 检查是否满足条件A1,A2.如果满足.输出”YES” 和 0 检查是否满足B1.B2.不满足.输出”NO” 输出”YES” 和 n-m.(加入n-m条边) 按照描述添加边i,j.当(i,j)添加成功.输出”i j” 找到点i,j度数不超过2(i和j可以相等.如果n = 1). 输出 “i j” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 55int n,m;int fa[MAX_N];int in[MAX_N];vector&lt;int&gt; G[MAX_N];bool has[MAX_N];struct P&#123; int u,v;&#125;;void init()&#123;for(int i = 0; i &lt; n; ++i) fa[i] = i;&#125;int findd(int x) &#123;return x == fa[x] ? x : fa[x] = findd(fa[x]);&#125;void unite(int x, int y) &#123;x = findd(x); y = findd(y); fa[x] = y;&#125;bool same(int x, int y) &#123;return findd(x) == findd(y);&#125;bool dfs(int u, int fa)&#123; int sz = G[u].size(); has[u] = true; for(int i = 0; i &lt; sz; ++i)&#123; int v = G[u][i]; if(v == fa) continue; if(has[v] || dfs(v, u)) return true; &#125; return false;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int u,v; while(cin &gt;&gt; n &gt;&gt; m)&#123; init(); memset(has, false, sizeof(has)); memset(in, 0, sizeof(in)); for(int i = 0; i &lt; n; ++i) G[i].clear(); for(int i = 0; i &lt; m; ++i)&#123; cin &gt;&gt; u &gt;&gt; v; ++in[--u]; ++in[--v]; unite(u, v); G[u].push_back(v); G[v].push_back(u); &#125; bool flag = false; bool two = true; // 是不是都是2 int i; for(i = 0; i &lt; n; ++i) &#123; two &amp;= (in[i] == 2 &amp;&amp; same(0, i)); if(in[i] &gt; 2) &#123;flag = true; break;&#125; &#125; if(two)&#123; // 满足所有点在一个联通快并且是一个环 puts("YES\n0"); continue; &#125; if(flag || m &gt;= n) &#123;puts("NO"); continue;&#125; // 判断是不是有环 for(int i = 0; i &lt; n; ++i)&#123; if(!has[i]) &#123; if(dfs(i, -1)) &#123;flag = true; break;&#125; &#125; &#125; if(flag) &#123;puts("NO"); continue;&#125; puts("YES"); printf("%d\n", n - m); vector&lt;P&gt; vp; for(int i = 0; i &lt; n; ++i)&#123; if(in[i] &gt;= 2) continue; for(int j = 0; j &lt; i; ++j)&#123; if(in[j] &lt; 2 &amp;&amp; !same(i, j)) &#123; unite(i, j); // 连接i,j ++in[i]; ++in[j]; vp.push_back((P)&#123;i, j&#125;); &#125; &#125; &#125; // 最后都在一个联通块.只剩下两个或者一个度数&lt;2的 u = v = -1; for(int i = 0; i &lt; n; ++i)&#123; if(in[i] &lt; 2) &#123; if(u == -1) u = i; else &#123;v = i; break;&#125; &#125; &#125; // 只有一个结点的时候 if(v == -1) v = u; vp.push_back((P)&#123;u, v&#125;); for(int i = 0; i &lt; n-m; ++i)&#123; if(vp[i].u &gt; vp[i].v) swap(vp[i].u, vp[i].v); printf("%d %d\n", vp[i].u+1, vp[i].v+1); &#125; &#125; return 0;&#125; emmm.第二天. C.三角形题目大意:在$n*m$边长的网格中选择三个点可以组成的三角形个数。 题解$n*m$边长的网格有 $(n+1)(m+1)$ 个点 我们要选择三个来组成三角形. 方案数就是$total=C_{(n+1)(m+1)}^3$. 但是这是所有情况.有些三个点是共线的.所以我们只要找出三个点共线的方案数$other$. 答案$ans=total-other$ 在属于$other$的有下面三种情况: 横着的线有$m+1$条(横轴是$n$.纵轴是$m$).$other_1=(m+1)C_{n+1}^3$ 竖着的先有$n+1$条.$other_2=(n+1)C_{m+1}^3$ 斜着的.有斜率是正的斜着的.也有斜率是负的.但是我们只要算出斜率是正的.乘$2$即可. 解释一下第三种情况的计算： 斜线可以画一画图. 我们以$(0,0)$ 到 $(x,y)$ 的线$l_1$作为标准.$l_1$这样的线有$(n+1-x)(m+1-y)$条. (emmm.这里也可以画一画). 这条线上的点是格点的有$x=gcd(x,y)-1$个 (emmm.这个结论详见《挑战程序设计竞赛》2.6章:数学问题的解题窍门). 所以只要$x&gt;=1$.那么两端的点就可以和这$x$个点中任意一个组成一种方案. $l1$这种线的方案数就是$2x(n+1-x)(m+1-y)$ 所有$1&lt;=x&lt;=n.1&lt;=y&lt;=m$计算出来$other_3$. 最后$ans=total-(other_1+other_2+other_3)$. 时间复杂度$O(n*m)$ emm.顺便提一下.注意结果溢出.orz 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;LL n, m;LL C3(LL n) &#123; return n*(n-1)*(n-2)*1LL/6LL;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n &gt;&gt; m; ++n; ++m; LL ans = C3(n*m) - m*C3(n) - n*C3(m); for(int i = 1; i &lt; n; ++i)&#123; for(int j = 1; j &lt; m; ++j)&#123; int x = __gcd(i, j) - 1; // (0, 0) 到 (i, j)中格子数目.不包含两端 if(x &gt;= 1) &#123; // 多于一个 ans -= (n - i) * (m - j) * x * 2LL; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM题目</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wannafly挑战赛26]]></title>
    <url>%2F2018%2F10%2F13%2FACM%E9%A2%98%E7%9B%AE%2FWannafly%E6%8C%91%E6%88%98%E8%B5%9B26%2F</url>
    <content type="text"><![CDATA[Wannafly挑战赛26 emm.现在本来还是比赛时间.但是只搞出A题的我.指向写个博客然后去写项目.orz A. 御坂网络 ACWA 三次是因为.1.代码确实写错 2. 算n-1个点到这个点的距离去了. 3. emm.想到了正确的算法.但是应该输出没有换行.然后想想算距离是double.有精度损失呀.换种方式吧.就过了. 题目大意:平面坐标中有$n$个点.是否可以选择一个点作为圆心.其他$n-1$个点在这个圆上. 题解:圆的方程： $ (x - a) + (y - b) = r^2$所以只要$O(n^2)$暴力匹配这个方程就行. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define MAX_N 1100int n;struct Point&#123; LL x,y;&#125;p[MAX_N];LL d[MAX_N][MAX_N];LL dis(Point a, Point b)&#123; return (a.x - b.x)*(a.x - b.x)*1LL + (a.y - b.y) * (a.y - b.y)*1LL;&#125;int main()&#123; // freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n; for(int i = 0; i &lt; n; ++i)&#123; cin &gt;&gt; p[i].x &gt;&gt; p[i].y; &#125; for(int i = 0; i &lt; n; ++i)&#123; for(int j = 0; j &lt; n; ++j)&#123; if(i == j) continue; d[i][j] = dis(p[j], p[i]); &#125; &#125; for(int i = 0; i &lt; n; ++i)&#123; LL ans; ans = (i == 0) ? d[i][1] : d[i][0]; int j; for(j = 0; j &lt; n; ++j)&#123; if(j == i) continue; if(ans != d[i][j]) break; &#125; if(j == n) &#123; cout &lt;&lt; i+1; return 0; &#125; &#125; cout &lt;&lt; "-1"; return 0;&#125;]]></content>
      <categories>
        <category>ACM题目</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典训练指南打卡day1]]></title>
    <url>%2F2018%2F10%2F10%2F%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E8%AE%AD%E7%BB%83%E6%8C%87%E5%8D%97%2F%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E8%AE%AD%E7%BB%83%E6%8C%87%E5%8D%97%E6%89%93%E5%8D%A1day1%2F</url>
    <content type="text"><![CDATA[emm.最近有点小烦躁.今年还只能打两场了.青岛和沈阳.想要拿牌子.题目不知如何刷起.太多了呀.自己太菜了呀.所以来一个打卡系列吧.打卡刘汝佳&lt;&lt;算法竞赛 入门经典 训练指南&gt;&gt;. so. 打卡day1. Meteor UVALive - 3905题目大意:有一个矩形照相机.矩形照相机照到的范围是$(0,0)$到$(w,h)$.有$n$个流星.第i个流星的初始坐标$(x_i, y_i)$,速度$(a_i, b_i)$.所以.$t(t &gt;= 0)$时刻第$i$个流星的位置就是$(x_{ti}, y_{ti}) = (x_i, y_i) + t*(a_i, b_i).$求某一时刻矩形照相机最多可以照到的流星数量.(在边界上照到的不算) 题解:转换一下问题.每一个流星在矩形照相机中的时间段是确定的(如果可以进入矩形照相机).假设在这n个流星中有k个流星在一定时间段可以照到.第$i$个流星能照到的时间段是$(L_i, R_i) 1 \leq i \leq k. 1 \leq k \leq n.$所以我们只要求出这$k$个开区间的最大交集的数量.就是某一时刻最多有多少个区间有交集.假设我们已经计算出这k个开区间.考虑下面的算法: 每一个区间有两个端点.将每一个区间的左右端点分别看作一个事件.按照坐标优先级第一从小到大.坐标相同的按照右端点优先原则排序. 有一个扫描线.一个计数器cnt=0.答案保存ans=0.从小到大开始扫描事件.当遇到当前事件是左端点时.cnt加上1.更新ans取大.当遇到当前事件是右端点时.cnt减去1. 这样扫描完就得到答案.复杂度$O(log(n))$ 计算区间: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;int T;int w,h,n,a,b;struct Event&#123; double x; int type; // 0表示左端点.1表示右端点 bool operator&lt;(const Event&amp; b)const&#123; // 第一优先级.端点坐标从小到大.第二优先级.先处理右端点 return x &lt; b.x || (x == b.x &amp;&amp; type &gt; b.type); &#125;&#125;;// 计算到达边界的时间void update(int x, int a, int w, double &amp;L, double &amp;R)&#123; /* x + t1*a &gt; 0 x + t2*a &lt; w */ if(a == 0)&#123; if(x &lt;= 0 || x &gt;= w) R = L-1; // a是0.而且一开始就在外面 &#125; else if(a &gt; 0)&#123; L = max(L, -(double)x/a); R = min(R, (double)(w-x)/a); &#125; else &#123; L = max(L, (double)(w-x)/a); R = min(R, -(double)x/a); &#125;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int x,y; double L,R; cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; w &gt;&gt; h &gt;&gt; n; vector&lt;Event&gt; v; for(int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; a &gt;&gt; b; L = 0; R = 1e9; // 0 &lt; x+t*a &lt; w, 0 &lt; y+t*a &lt; h update(x, a, w, L, R); update(y, b, h, L, R); if(R &gt; L)&#123; // 区间成立 // 加入左右端点 v.push_back((Event)&#123;L, 0&#125;); v.push_back((Event)&#123;R, 1&#125;); &#125; &#125; sort(v.begin(), v.end()); // 排好序 int ans = 0; int cnt = 0; for(auto &amp;x : v)&#123; if(x.type == 0) &#123; ++cnt; // 左端点的时候加上 ans = max(ans, cnt); &#125; else --cnt; // 右端点的时候减去 &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛入门经典训练指南</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoderBeginnerContest112]]></title>
    <url>%2F2018%2F10%2F07%2FACM%E9%A2%98%E7%9B%AE%2F%20AtCoderBeginnerContest112%2F</url>
    <content type="text"><![CDATA[AtCoder Beginner Contest 112比赛链接 emm.第一次在AtCoder上的比赛. rank:754th rating:113. AC. WA.表示比赛时候的状态 A - Programming Education AC 题目大意: 输入1的时候输出”Hello World”. 输入2的时候会输入a,b.计算a+b. 题解: emm.入门操作.beginner出这个题还是很不错的.1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int kind,a,b; while(cin &gt;&gt; kind)&#123; if(kind == 1)&#123; cout &lt;&lt; "Hello World" &lt;&lt; endl; &#125; else &#123; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; (a+b) &lt;&lt; endl; &#125; &#125; return 0;&#125; B - Time Limit Exceeded AC 题目大意:给两个数N,T. N组数.每组两个数$c_i$和$t_i$.求所有不超过T的$t_i$中$c_i$的最小值. 题解: emm.入门操作.beginner出这个题还是很不错的. 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 105int N,T;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int c,t; while(cin &gt;&gt; N &gt;&gt; T)&#123; int ans = INT_MAX; for(int i = 1; i &lt;= N; ++i)&#123; cin &gt;&gt; c &gt;&gt; t; if(t &lt;= T) ans = min(ans, c); &#125; if(ans == INT_MAX) cout &lt;&lt; "TLE" &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; C - Pyramid WA ps: 到最后没做出这道题.想暴力.然后看到 The center coordinates and the height of the pyramid can be uniquely identified 这句话.理解成中心点的坐标和h可能是无穷的.orz应该是:可以唯一地识别金字塔的中心坐标和高度. by google translate 题目大意:有N个点.$(x_i, y_i,h_i)$. $h_i$表示这个点的高度.求一个点$(C_x, C_y, H)$满足.$h_i = max(H-|x_i - C_x| + |y_i - C_y|, 0)$. 题解:由于$0 &lt;= C_x, C_y &lt;= 100.$所以暴力即可. 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 110int n;int x[MAX_N], y[MAX_N], h[MAX_N];int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); while(cin &gt;&gt; n)&#123; for(int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; h[i]; if(h[i] &gt; 0) &#123; swap(h[i], h[1]); swap(x[i], x[1]); swap(y[i], y[1]); &#125; &#125; for(int cx = 0; cx &lt;= 100; ++cx)&#123; for(int cy = 0; cy &lt;= 100; ++cy)&#123; int ch = h[1] + abs(x[1] - cx) + abs(y[1] - cy); bool is = true; for(int i = 2; i &lt;= n; ++i)&#123; if(max(ch - abs(x[i] - cx) - abs(y[i] - cy), 0) != h[i]) &#123; is = false; break; &#125; &#125; if(is)&#123; cout &lt;&lt; cx &lt;&lt; " " &lt;&lt; cy &lt;&lt; " " &lt;&lt; ch &lt;&lt; endl; return 0; &#125; &#125; &#125; &#125; return 0;&#125; D - Partition AC 题目大意:两个数N,M.可以有多种方案找N个数之和是M.每种方案N个数的最大公约数是x.这多种方案中x最大$$ \sum_{i=1}^{N}a_i = M $$$$ ans = max(gcd(a_1, a_2,…,a_N))$$ 题解:可以确定.答案不超过M/N.如果答案是x.那么.这个N个数一定是x的倍数.所以只要从M/N到1枚举.第一个满足M每次减去x的k倍.最后如果M是0.说明当前x是答案.因为是从大到小枚举.所以第一个肯定是最大的. 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 105int N,M;bool can(int x)&#123; int m = M; m -= x; while(m &gt; 0 &amp;&amp; m/x)&#123; m -= (m/x * x); &#125; return m == 0;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); while(cin &gt;&gt; N &gt;&gt; M)&#123; for(int ans = M/N; ans &gt;= 1; --ans)&#123; if(can(ans)) &#123; cout &lt;&lt; ans &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM题目</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客集训派对day3]]></title>
    <url>%2F2018%2F10%2F04%2FACM%E9%A2%98%E7%9B%AE%2F%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E6%B4%BE%E5%AF%B9day3%2F</url>
    <content type="text"><![CDATA[原比赛链接emmm.国庆刷题狂欢,来自暑假ccpc-wannafly camp day 3的题目 A.Knight题目描述有一张无限大的棋盘，你要将马从(0,0)移到(n,m)。每一步中，如果马在(x,y)，你可以将它移动到(x+1,y+2),(x+1,y-2),(x-1,y+2),(x-1,y-2),(x+2,y+1),(x+2,y-1),(x-2,y+1)或(x-2,y-1)。你需要最小化移动步数。 输入描述:第一行一个整数t表示数据组数 (1≤ t≤ 1000)。每组数据一行两个整数n,m (|n|,|m|≤ 109)。 输出描述:每组数据输出一行一个整数表示最小步数。 示例1输入20 44 2输出22 不妨假设 x&gt;=y&gt;=0。当 x&lt;=2y 时，定义每一步的冗余值 wi=3-dx-dy，那么∑wi=∑(2-dx)=3步数-x-y，显然我们只需要最小化冗余值。我们先只用(+2,+1)(若 x 为奇数则加一步(+1,+2))走到(x,y’)，然后通过将(+2,+1)替换为 2 个(+1,+2)使得0&lt;=y-y’&lt;3。若 y-y’=0，则冗余值为 0，显然最小。若 y-y’=1，则将(+1,+2)替换为(+2,+1)和(-1,+2)或将 2 个(+2,+1)替换为(+1,+2),(+1,+2),(+2,-1)，冗余值为 2，显然最小。（此处需要特判(2,2)）若 y-y’=2，则加上(+2,+1)和(-2,+1)，冗余值为 4，由于不存在冗余值为 1的步，所以最小。当 x&gt;2y 时，定义每一步的冗余值 wi=2-dx，那么∑wi=∑(2-dx)=2步数-x，显然我们只需要最小化冗余值。我们先只使用(+2,+1)走到(2y,y)，然后用(+2,+1)和(+2,-1)走到(x’,y)使得 0&lt;=x-x’&lt;4。若 x-x’=0 则冗余值为 0，显然最小。若 x-x’=1 则将之前的(+2,+1)改为(+1,+2)和(+2,-1)，冗余值为 1，显然最小。（此处需要特判(1,0)）若 x-x’=2 则加上(+1,+2)和(+1,-2)，冗余值为 2，由 x/2+y 的奇偶性可知最小。若 x-x’=3 则加上(+2,+1),(+2,+1),(-1,-2)，冗余值为 3，由 x/2+y 的奇偶性可知最小。时间复杂度 O(t) 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll fun(ll x, ll y) &#123; if (x == 1 &amp;&amp; y == 0) &#123; return 3; &#125; if (x == 2 &amp;&amp; y == 2) &#123; return 4; &#125; ll delta = x - y; if (y&gt;delta) &#123; return delta - 2 * floor(((double)(delta-y)) / 3.0); &#125; else &#123; return delta - 2 * floor(((double)(delta-y)) / 4.0); &#125;&#125;int main()&#123; //freopen("in.txt", "r", stdin); int t; cin &gt;&gt; t; while (t--) &#123; ll x, y; cin &gt;&gt; x &gt;&gt; y; x = abs(x); y = abs(y); if (x &lt; y) &#123; swap(x, y); &#125; cout &lt;&lt; fun(x, y) &lt;&lt; endl; &#125; return 0;&#125; D. Shopping题目描述你要买n件物品，其中有一些是凳子。商场正在举行促销活动，如果购物车中有至少一个凳子，那么你可以半价购买这个购物车中最贵的一个物品。你有m辆购物车，请最小化你的花费。 输入描述:第一行一个整数t表示数据组数 (1 ≤ t ≤ 100)。每组数据第一行两个整数n,m (1 ≤ n,m ≤ 1000)，接下来n行每行两个整数ai,bi，分别表示第i件物品的价格以及它是否是凳子 (1 ≤ ai ≤ 105, 0 ≤ bi ≤ 1)。 输出描述:每组数据输出一行一个实数表示最小花费，保留一位小数。 示例1 输入25 11 02 13 14 05 05 101 02 13 14 05 0 输出12.510.5 显然可以将最贵的 min(m,凳子个数)个物品打折。时间复杂度 O(tn) 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std; int t;int n,m; int main()&#123; //freopen("in.txt", "r", stdin); scanf("%d", &amp;t); int a,b; while(t--)&#123; scanf("%d%d", &amp;n, &amp;m); vector&lt;int&gt; v; int cnt = 0; for(int i = 0; i &lt; n; ++i)&#123; scanf("%d%d", &amp;a, &amp;b); if(b == 1) ++cnt; v.push_back(a); &#125; sort(v.begin(), v.end()); double ans = 0.0; int sz = v.size(); m = min(m, cnt); for(int i = sz-1,j=1; i &gt;= 0; --i,++j)&#123; if(j &lt;= m) ans += v[i]/2.0; else ans += v[i]; &#125; printf("%.1lf\n", ans); &#125; return 0;&#125; H.Travel题目描述魔方国有n座城市，编号为。城市之间通过n-1条无向道路连接，形成一个树形结构。澜澜打算在魔方国进行m次旅游，每次游览至少一座城市。为了方便，每次旅游游览的城市必须是连通的。此外，澜澜希望游览所有城市恰好一次。澜澜想知道有多少种旅游方案满足条件，两个方案不同当且仅当存在某一次旅游游览了不同的城市。澜澜不会数数，所以只好让你来帮他数方案。 输入描述:第一行一个整数t表示数据组数 (1 ≤ t ≤ 100)。每组数据第一行两个整数n,m ，接下来n-1行每行两个整数ai,bi表示一条道路 (1≤ ai,bi≤ n)。 输出描述:每组数据输出一行一个整数表示方案数对109+7取模的结果。 示例1 输入23 11 21 33 21 21 3 输出14 把树分成 m 个连通块的方案数是 C(n-1,m-1)，乘上 m!就行了。时间复杂度 O(∑n) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL MOD = 1e9 + 7;#define MAX_N 100100LL f[MAX_N];void init()&#123; f[0] = f[1] = 1LL; for(int i = 2; i &lt; MAX_N; ++i) f[i] = i * f[i - 1] % MOD;&#125;LL powN(LL a, LL n)&#123; LL base = a, res = 1LL; while(n)&#123; if(n &amp; 1) res = res * base % MOD; base = base * base % MOD; n &gt;&gt;= 1; &#125; return res;&#125;LL inv(LL a, LL MOD)&#123; return powN(a, MOD - 2LL);&#125;LL C(LL n, LL m)&#123; if(m == 0) return 1; if(n &lt; 0 || n &lt; m) return 0; return (f[n] % MOD) * (inv(f[m], MOD) * inv(f[n - m], MOD) % MOD) % MOD;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int t,a,b; LL n,m; cin &gt;&gt; t; init(); while(t--)&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n - 1; i++) cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; (C(n-1, m-1) * f[m]) % MOD&lt;&lt; endl; &#125; return 0;&#125; I.Metropolis题目描述魔方国有n座城市，编号为。城市之间通过n-1条无向道路连接，形成一个树形结构。在若干年之后，其中p座城市发展成了大都会，道路的数量也增加到了m条。大都会之间经常有贸易往来，因此，对于每座大都会，请你求出它到离它最近的其它大都会的距离。 输入描述:第一行三个整数n,m,p (1 ≤ n,m ≤ 2*105,2 ≤ p ≤ n)，第二行p个整数表示大都会的编号 (1≤ xi≤ n)。接下来m行每行三个整数ai,bi,li表示一条连接ai和bi，长度为li的道路 (1 ≤ ai,bi ≤ n,1 ≤ li ≤ 109)。保证图是连通的。 输出描述:输出一行p个整数，第i个整数表示xi的答案。示例1 输入5 6 32 4 51 2 41 3 11 4 11 5 42 3 13 4 3 输出3 3 5 把所有大都会设为源点跑多源最短路，记下每个点是由哪个源点扩展的。如果从源点 i 出发走到了一个由另一个源点 j 扩展到的点 k，那么从 i 出发经过 k 的最短距离肯定是 dis[i][j]，那么就没有必要继续走下去了。所以只要枚举所有两端由不同源点扩展的边更新答案就行了。时间复杂度 O((n+m)logn) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define MAX_N 200100const LL INF = 1e15;struct Edge&#123;int to; LL cost;&#125;;typedef pair&lt;LL, int&gt; P;int T;int n,m,k;int p[MAX_N];int is[MAX_N];LL d[MAX_N];LL ans[MAX_N];vector&lt;Edge&gt; G[MAX_N];void dijstra()&#123; for(int i = 1; i &lt;= n; ++i) d[i] = INF; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que; for(int i = 1; i &lt;= k; ++i)&#123; que.push(P(d[p[i]] = 0, p[i])); &#125; while(!que.empty())&#123; P p = que.top(); que.pop(); int v = p.second; if(p.first &gt; d[v]) continue; for(int i = 0; i &lt; G[v].size(); ++i)&#123; Edge e = G[v][i]; if(d[e.to] &gt; d[v] + e.cost)&#123; d[e.to] = d[v] + e.cost; is[e.to] = is[v]; // e.to是由v扩展的 que.push(P(d[e.to], e.to)); &#125; else if(is[v] != is[e.to])&#123; // 不同源点扩展的边 ans[is[v]] = min(ans[is[v]], d[v] + d[e.to] + e.cost); ans[is[e.to]] = min(ans[is[e.to]], d[v] + d[e.to] + e.cost); &#125; &#125; &#125;&#125;int main()&#123; //freopen("in.txt", "r", stdin); int u,v; LL c; scanf("%d%d", &amp;n, &amp;m); for(int i = 0; i &lt;= n; ++i) G[i].clear(); scanf("%d", &amp;k); for(int i = 1; i &lt;= k; ++i)&#123; scanf("%d", &amp;p[i]); ans[p[i]] = INF; is[p[i]] = p[i]; &#125; for(int i = 1; i &lt;= m; ++i)&#123; scanf("%d%d%lld", &amp;u, &amp;v, &amp;c); G[u].push_back((Edge)&#123;v, c&#125;); G[v].push_back((Edge)&#123;u, c&#125;); &#125; dijstra(); for(int i = 1; i &lt;= k; ++i)&#123; printf("%lld%c", ans[p[i]], "\n "[i &lt; k]); &#125; return 0;&#125; J. Graph Coloring I题目描述修修在黑板上画了一些无向连通图，他发现他可以将这些图的结点用两种颜色染色，满足相邻点不同色。澜澜不服气，在黑板上画了一个三个点的完全图。修修跟澜澜说，这个图我能找到一个简单奇环。澜澜又在黑板上画了一个n个点m条边的无向连通图。很可惜这不是一道数数题，修修做不出来了。澜澜非常得意，作为一位毒瘤出题人，有了好题当然要跟大家分享，于是他把这道题出给你做了。 输入描述:第一行两个整数n,m (1≤ n,m≤ 3*105)，接下来m行每行两个整数ai,bi表示一条边 (1≤ ai,bi≤ n)。保证图连通，并且不存在重边和自环。输出描述:如果你能把图二染色，第一行输出0，第二行输出n个整数表示每个点的颜色 (0≤ xi≤ 1)。如果有多种合法方案，你可以输出任意一种。如果你能找到一个简单奇环，第一行输出环长k，第二行输出k个整数表示环上结点编号 (1≤ yi≤ n)，你需要保证yi和yi+1之间有边，y1和yn之间有边。如果有多种合法方案，你可以输出任意一种。如果两种情况都是可行的，你只需要输出任意一种。如果两种情况都是不可行的，请输出一行一个整数-1。 示例1 输入3 21 21 3 输出00 1 1 示例2复制3 31 21 32 3 输出31 2 3 判一下是不是二分图就行了。时间复杂度 O(n+m) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 3*1e5+100;int color[MAX_N];vector&lt;int&gt; G[MAX_N];vector&lt;int&gt; p;int n,m;int s,e;bool dfs(int u, int c)&#123; color[u] = c; p.push_back(u); for(int i = 0; i &lt; G[u].size(); ++i)&#123; int v = G[u][i]; if(color[u] == color[v]) &#123;s = v, e = u;return false;&#125; if(!color[v])&#123; if(!dfs(v, 3 - c)) return false; &#125; &#125; p.erase(--p.end()); return true;&#125;int main()&#123; //freopen("in.txt", "r", stdin); scanf("%d%d", &amp;n, &amp;m); int u,v; for(int i = 1; i &lt;= m; ++i)&#123; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; memset(color, 0, sizeof(color)); if(dfs(1, 1))&#123; puts("0"); for(int i = 1; i&lt;= n; ++i)&#123; printf("%d%c", color[i]-1, "\n "[i &lt; n]); &#125; &#125; else &#123; int i = -1; int sz = p.size(); while(p[++i] != s); printf("%d\n", sz - i); for(;i &lt; sz; ++i)&#123; printf("%d%c", p[i], "\n "[i &lt; sz-1]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM题目</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018ccpc-wannafly-round]]></title>
    <url>%2F2018%2F08%2F03%2F%E6%97%A5%E8%AE%B0%2F2018ccpc-wannafly-round1%2F</url>
    <content type="text"><![CDATA[前言今天是训练营的第一天，早上去了一个大教室，上了一节”如何学习算法”的课,课上的最后一个初中cf橙名大佬上去互动来着.初中人家在打算法比赛,我初中的时候在干啥,难以回忆,差距呀!!!课上击鼓传花回答了一个问题”为什么学习算法”.我内心的答案是,”好玩,神奇,能赚钱”.还有听到一句话就是:”不怕学霸有多霸,就怕学霸放暑假”,好像是这样说的.作为菜鸡的自己瑟瑟发抖,自己被别人超越了很多个暑假. 比赛中午在酒店吃了自助餐之后,躺了一小会儿就去上次打省赛的机房去了,一开始比赛方的服务器没准备好,所以早上讲课的老师就在vj上开了一场练习赛,我A了一道暴力判断回文串的水题之后,大概就开始正赛了.值得一提的是,我们旁边坐了一个小学生!!!小学生!!!再次震惊,上次震惊是5月份的省赛,我真的以为小学生就能A签到题,最后发现虽然他是在教练指导下A的,但是他真的会写C语言代码.不得不说,别人家的小时候.正式打比赛.一看I题题目是最短路,然后那道题没有样例.然后第一手队友说dijkstra模板,我说给我&lt;&lt;挑战程序设计竞赛&gt;&gt;这本书,我A一个,最后发现不行,单源最短路径一次时间复杂度是O(|E|log|V|),但是它有Q组询问,Q有1e6这么大吧,E和V也是大概1e6.然后我去看榜单,A了一个签到G题,答案就是找出序列的最大的那个然后乘2.后面我就在做A,一开始以为是DP,后来贪心,后来写了贪心的代码,样列过了,队友的样例也过了,但是就是红的WA.~~最后题解是费用流,自己菜鸡,没有看费用流.其他题也是中等题没有做出来.难题就GG,想都不要想.我们队做出三个签到. 总结渐渐的成为一个ACMer,也大概一年了,从啥都不知道到现在.发现百度之星进决赛可以百度的校招绿色通道.还有美团的比赛.所以打比赛还是很不错的,如果可以靠打比赛进入一个好公司的话,就不想考研了,下一年的目标就是每天5道cf.然后坚持一年下来.加油吧!!!]]></content>
      <categories>
        <category>ACMer日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[M斐波那契数列]]></title>
    <url>%2F2018%2F03%2F25%2FACM%E9%A2%98%E7%9B%AE%2FM%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目传送门 Problem DescriptionM斐波那契数列F[n]是一种整数数列，它的定义如下： F[0] = aF1 = bF[n] = F[n-1] * F[n-2] ( n &gt; 1 ) 现在给出a, b, n，你能求出F[n]的值吗？ Input输入包含多组测试数据；每组数据占一行，包含3个整数a, b, n（ 0 &lt;= a, b, n &lt;= 10^9 ） Output对每组测试数据请输出一个整数F[n]，由于F[n]可能很大，你只需输出F[n]对1000000007取模后的值即可，每组数据输出一行。 Sample Input0 1 06 10 2 Sample Output060 题目解决题目分析: 注意到n的范围最大到10^9,所以简单的进行递推时间和空间上都无法处理到限制范围内. 这道题涉及到取余运算,所以我们应该知道取余运算的其中一个性质:$$(ab) \mod p = ((a \mod p) (b \mod p)) \mod p$$ 注意到该递推式和斐波那契数列有相似之处. 知识点:1.斐波那契数列的矩阵运算1.斐波那契数列$fib(0) = 0$$fib(1) = 1$$fib(n) = fib(n-1)+fib(n-2)$| n | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | … | … | n-1 | n || —–: | —–: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: || fib(n) | 0 | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 | 34 | 55 | 89 | 144 | 233 | 377 | … | … | fib(n-1) | fib(n) | 2.将斐波那契数列写到矩阵中1.考虑按照以下表达式构造n个矩阵:$$ A_{n} = \begin{bmatrix} fib(n) &amp; fib(n+1) \ fib(n+1) &amp; fib(n+2) \ \end{bmatrix}$$ 2.得到如下矩阵$A_{0} = \begin{bmatrix}0 &amp; 1 \1 &amp; 1 \ \end{bmatrix} $ &nbsp; $A_{1} = \begin{bmatrix}1 &amp; 1 \1 &amp; 2 \ \end{bmatrix} $ &nbsp; $ A_{2} = \begin{bmatrix}1 &amp; 2 \2 &amp; 3 \ \end{bmatrix} $ &nbsp; $A_{3} = \begin{bmatrix}2 &amp; 3 \3 &amp; 5 \ \end{bmatrix} $ &nbsp; $A_{4} = \begin{bmatrix}3 &amp; 5 \5 &amp; 8 \ \end{bmatrix} $ … &nbsp; … &nbsp; … $A_{n} = \begin{bmatrix}fib(n) &amp; fib(n+1) \ fib(n+1) &amp; fib(n+2) \ \end{bmatrix} $ 3.矩阵乘法运算$A_{1} = \begin{bmatrix}1 &amp; 1 \1 &amp; 2 \ \end{bmatrix} = A_{0}A_{0}$ &nbsp;&nbsp;&nbsp; $ A_{2} = \begin{bmatrix}1 &amp; 2 \2 &amp; 3 \ \end{bmatrix} = A_{0}A_{0}A_{0}$ &nbsp;&nbsp; $A_{3} = \begin{bmatrix}2 &amp; 3 \3 &amp; 5 \ \end{bmatrix} = A_{0}A_{0}A_{0}A_{0} $ $ A_{4} = \begin{bmatrix}3 &amp; 5 \5 &amp; 8 \ \end{bmatrix} = A_{0}A_{0}A_{0}A_{0}A_{0}$ &nbsp;&nbsp; $A_{n} = \begin{bmatrix}fib(n) &amp; fib(n+1) \fib(n+1) &amp; fib(n+2) \ \end{bmatrix} = A_{0} ^ {n+1}$ \begin{array}{|rrrrrrrr|}\hline\color{red}{综上所述,要想求解f(n),求得A(n)或者A(n-2)即可} &amp;\hline\end{array} 2.快速幂:Q:&nbsp;&nbsp;&nbsp;求解 $ x ^ N $A:&nbsp;&nbsp;&nbsp;O(N)的算法:1234ans = 1; for(i = 1; i &lt;= n; i++)&#123; ans *= x;&#125; A:&nbsp;&nbsp;&nbsp;O(logN)的算法: 将N转换成二进制表示形式 $$ N = 2 ^ {k_{1}} + 2 ^ {k_{2}} + 2 ^ {k_{3}} + …. + 2 ^ {k_{n}}$$ 要求解$x ^ N $,相当与计算$$ x ^ N = x ^ {2 ^ {k_{1}} + 2 ^ {k_{2}} + 2 ^ {k_{3}} + …. + 2 ^ {k_{n}}} = x^{2 ^ {k_{1}}}x^{2 ^ {k_{2}}}x^{2 ^ {k_{3}}}…x^{2 ^ {k_{n}}}$$ 所以只要在依次求$x ^ {2^i} $ 的同时进行计算就好了,最终得到了O(logN)的计算幂运算的算法 举个例子:计算 $ x ^ {22} $ 十进制下的22的二进制表示 : $ 22_{10} = 10110_{2}$ $ N = 22 = 2^{4} + 2^{2} + 2^{1}$ $ x^{22} = x^{2^{4} + 2^{2} + 2^{1}} = x^{16}x^{4}x^{2}$ 可以看到如果是O(N)的算法,当前例子需要计算22次,而O(logN)的算法只需要计算5次 \begin{array}{|rrrrrrrr|}\hline&amp; \color{red}{CODE:}&amp;\hline\end{array}123456789101112131415161718192021222324typedef long long LL;// 计算x^n,复杂度O(logN)LL powN(LL x, LL n)&#123; LL r = 1; // 计算结果 while(n)&#123; if(n&amp;1) r *= x; // 如果n的二进制表示i(i &gt;= 0)的位置是1,则乘上x^(2^i) x *= x; // 将x平方 n &gt;&gt;= 1; // 右移一位 &#125; return r; // 返回结果&#125;// 计算x^n mod p, ( a * b ) % p = ( ( a % p ) * ( b * p ) ) % p 复杂度O(logN)LL mod_powN(LL x, LL n, LL p)&#123; LL r = 1; // 计算结果 while(n)&#123; if(n&amp;1) r = r * x % p; // 如果n的二进制表示i(i &gt;= 0)的位置是1,则乘上x^(2^i) x = x * x % p; // 将x平方 n &gt;&gt;= 1; // 右移一位 &#125; return r; // 返回结果&#125; 3.费马小定理:费马小定理是数论中的一个定理：假如a是一个整数，p是一个质数，那么 $a^{p}-a$是p的倍数，可以表示为$$ a ^ p \equiv a (\mod p) $$如果a不是p的倍数，这个定理也可以写成$$ a ^ {p-1} \equiv 1 (\mod p)$$费马小定理是欧拉定理的一个特殊情况：如果n和a的最大公因数是1，那么$$ a^{φ(n)} \equiv 1 (\mod n) $$这里φ(n)是欧拉函数。欧拉函数的值是所有小于或等于n的正整数中与n互质的数的个数。假如n是一个素数（质数），则φ(n) = n-1，即费马小定理注: $\equiv$是同余符号 $ a \mod p = b \mod p$ 可表示为 $ a \equiv b (\mod p)$ 推导以下表达式:当p是质数时:$$ a ^ n \equiv a ^ {(n \mod (p-1))} (\mod p) $$成立 证:$$ n = k(p-1) + (n \mod (p-1)) (k为整数) $$$$ a ^ n \equiv a ^ {k(p-1) + (n \mod (p-1))} \equiv {a ^ {p-1}} ^ {k} a ^ {(n \mod (p-1))} (\mod p)$$由费马小定理可知:$$ {a ^ {p-1}} ^ {k} \equiv a ^ {p-1} \equiv 1(\mod p)$$得证:$$ a ^ n \equiv a ^ {(n \mod (p-1))} (\mod p) $$ 回到题目:1.分析我们注意到虽然题目中的M斐波那契数列和斐波那契数列有异曲同工之处,但是一个计算的是乘法,一个是加法,但加法和乘法之间有着密切的联系. 2.算一算先计算前几项的值:$$ f(0) = a = a ^ 1 b ^ 0 $$$$ f(1) = b = a ^ 0 b ^ 1 $$$$ f(2) = a b = a ^ 1 b ^ 1 $$$$ f(3) = a b b = a ^ 1 b ^ 2 $$$$ f(4) = a a b b b = a ^ 2 b ^ 3 $$$$ f(4) = a a a b b b b b= a ^ 3 b ^ 5 $$$$ ……………………………………………………..$$$$ f(n) = f(n-1)f(n-2) = a ^ x b ^ y $$|n| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 11 | 12 | 13 | … | … | n-1 | n ||——–| —–: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: ||x| 1 | 0 | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 | 34 | 55 | 89 | … | … | fib(n-2) | fib(n-1) ||y| 0 | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 | 34 | 55 | 89 | 144 | … | … | fib(n-1) | fib(n) | 不难得出:$$ f(0) = a $$$$ f(1) = b $$$$ f(n) = f(n-1)f(n-2) = a ^ {fib(n-1)} b ^ {fib(n)} (n &gt;= 2) $$ 通过上面费马小定理证明的结论,当p是质数时:$$ a ^ n \equiv a ^ {(n \mod (p-1))} (\mod p) $$所以我们实际上需要计算的就是下面的表达式(p = 1000000007):$$ f(n) \mod p= f(n-1)f(n-2) \mod p = a ^ {fib(n-1) \mod p-1} b ^ {fib(n) \mod p-1} \mod p(n &gt;= 2) $$ 1.计算类似于计算整数的快速幂算法计算矩阵的幂 $A_{n-1} = A_{0} ^ {n}$$A_{0} = \begin{bmatrix}0 &amp; 1 \1 &amp; 1 \ \end{bmatrix}$ &nbsp;&nbsp; $A_{n-1} = \begin{bmatrix}fib(n-1) &amp; fib(n) \fib(n) &amp; fib(n+1) \ \end{bmatrix} = A_{0} ^ {n}$ 计算矩阵的幂时,我们实际上需要得到的结果是:$$ A_{n-1} \mod p-1 = \begin{bmatrix}fib(n-1) \mod p-1 &amp; fib(n) \mod p-1 \fib(n) \mod p-1 &amp; fib(n+1) \mod p-1 \ \end{bmatrix} = (A_{0} \mod p-1) ^ {n} \mod p-1 $$ 如果理解了上面的快速幂算法的话,这实现起来将会非常简单 2.得到$fib(n-1) \mod p-1$ 和 $fib(n) \mod p-1$ 之后,设这两个数为x,y,用整数的快速幂算法计算:$$a ^ x b^y \mod p = (a ^ x \mod p b^y \mod p) \mod p$$ \begin{array}{|rrrrrrrr|}\hline&amp; \color{red}{CODE:}&amp;\hline\end{array} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MOD1 = 1e9+7; // pconst int MOD2 = 1e9+6; // p-1LL a,b,n;typedef struct Matrix&#123; // 矩阵结构体 LL arr[2][2];&#125;Matrix;Matrix unit = &#123; // 单位矩阵 1,0, 0,1&#125;;Matrix A0 = &#123; // A0矩阵 0,1, 1,1&#125;;// 矩阵a*bMatrix matrixMulti(Matrix a, Matrix b)&#123; int i,j,k; Matrix tmp; for(i = 0; i &lt; 2; i++)&#123; for(j = 0; j &lt; 2; j++)&#123; tmp.arr[i][j] = 0; for(k = 0; k &lt; 2; k++)&#123; tmp.arr[i][j] += (a.arr[i][k]*b.arr[k][j])%MOD2; tmp.arr[i][j] %= MOD2; &#125; &#125; &#125; return tmp;&#125;// 矩阵快速幂,计算的结果对MOD2取余Matrix matrixPow(Matrix a, LL n)&#123; Matrix r = unit, base = a; while(n)&#123; if(n&amp;1) r = matrixMulti(r,base); base = matrixMulti(base, base); n &gt;&gt;= 1; &#125; return r;&#125;// 整数快速幂,计算的结果对MOD1取余LL powN(LL a, LL n)&#123; LL r = 1, base = a%MOD1; while(n)&#123; if(n&amp;1) r = r*base%MOD1; base = base*base%MOD1; n &gt;&gt;= 1; &#125; return r;&#125;int main()&#123; //freopen("in.txt", "r", stdin); Matrix An_1; while(~scanf("%lld%lld%lld", &amp;a, &amp;b, &amp;n))&#123; // 输入a,b,n An_1 = matrixPow(A0,n); // 计算An_1 printf("%lld\n", powN(a, An_1.arr[0][0]) * powN(b, An_1.arr[1][0]) % MOD1); &#125; return 0;&#125; 思考:Q: 为什么要使用费马小定理?A: 因为 $ x \mod p-1 &lt;= x $ 所以可以减少计算整数幂时候的计算次数,不使用费马小定理会超时. 作者 @何军2018 年 03月 24日]]></content>
      <categories>
        <category>ACM题目</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[骰子作画]]></title>
    <url>%2F2018%2F03%2F17%2Fdemo%2F%E9%AA%B0%E5%AD%90%E4%BD%9C%E7%94%BB%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package Hebut_HappyBirthday;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import java.io.PrintStream;import java.lang.invoke.ConstantCallSite;import java.util.ArrayList;import javax.imageio.ImageIO;public class HebutHappyBirthday &#123; public BufferedImage hebutImg; public static int rgb2gray(int argb) &#123; int alpha = (argb &gt;&gt; 24) &amp; 0xFF; int red = (argb &gt;&gt; 16) &amp; 0xFF; int green = (argb &gt;&gt; 8) &amp; 0xFF; int blue = argb &amp; 0xFF; return (int)(0.3*red + 0.59*green + 0.11*blue); &#125; public static int sixStepGary(int x) &#123; int i; int c = 256/10; for(i = 0; i &lt;= 9; i++) &#123; if(i*c &lt; x &amp;&amp; x &lt;= (i+1)*c) return i; &#125; return 9; &#125; public static String getXChar(int x, int i) &#123; String str[] = new String[10]; str[0] = " "; str[1] = " 0"; str[2] = "0 0"; str[3] = "0 "; str[4] = "0 0"; str[5] = "000"; if(x == 0 || (x == 1 &amp;&amp; i != 2) || (x == 2 &amp;&amp; i == 2) || (x == 4 &amp;&amp; i == 2)) return str[0]; if((x == 2 &amp;&amp; i == 1) || (x == 3 &amp;&amp; i == 1)) return str[1]; if(i == 2 &amp;&amp; (x == 1 || x == 2 || x == 3 || x == 5)) return str[2]; if(i == 3 &amp;&amp; (x == 2 || x == 3)) return str[3]; if((x == 8 &amp;&amp; i == 2) || x == 6 || (x == 7 &amp;&amp; (i == 1 || i == 3)) || (x == 5 &amp;&amp; (i == 1 || i == 3)) || x == 4) return str[4]; if(x == 9 || (x == 8 &amp;&amp; (i == 1 || i == 3)) || (x == 7 &amp;&amp; i == 2)) return str[5]; return null; &#125; public HebutHappyBirthday() throws Exception &#123; hebutImg = ImageIO.read(new File("/media/hejun/新加卷/hebut520.jpg")); final int MAX_N = 10000; int i,j,k,l,ii,jj = 0,kk,ll,n = 1; int[][] rgb = new int[MAX_N][MAX_N]; int[][] ansrgb = new int[MAX_N][MAX_N]; int width = hebutImg.getWidth(); int height = hebutImg.getHeight(); int minx = hebutImg.getMinX(); int miny = hebutImg.getMinY(); //System.out.println(minx + " " + miny + " " + width + " " + height); for(i = minx; i &lt; height; i++) &#123; for(j = miny; j &lt; width; j++) &#123; rgb[i][j] = rgb2gray(hebutImg.getRGB(j, i));//获得像素值 &#125; &#125; int sum,count; for(i = minx, ii = 0; i &lt; height; i += n, ii++) &#123; for(j = miny, jj = 0; j &lt; width; j += n, jj++) &#123; sum = count = 0; for(k = i, kk = 0; kk &lt; n &amp;&amp; k &lt; height; k++, kk++) &#123; for(l = j, ll = 0; ll &lt; n &amp;&amp; l &lt; width; l++, ll++) &#123; sum += rgb[k][l]; count++; &#125; &#125; ansrgb[ii][jj] = sixStepGary(sum/count); &#125; &#125; String str; for(i = 0; i &lt; ii; i++) &#123; for(k = 1; k &lt;= 3; k++) &#123; str = ""; for(j = 0; j &lt; jj; j++) &#123; str += getXChar(ansrgb[i][j], k); &#125; System.out.println(str); &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; HebutHappyBirthday hebutHappyBirthday = new HebutHappyBirthday(); &#125;&#125;]]></content>
      <categories>
        <category>Demo</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学问题]]></title>
    <url>%2F2017%2F09%2F09%2FACM%E9%A2%98%E7%9B%AE%2F%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目地址 数学问题时间限制：2000/1000 MS（Java / Others）内存限制：32768/32768 K（Java / Others）总提交：1321接受提交：476 问题描述给定一个正整数n，请计算k个满足多少正整数 ķ^k≤ N。 输入没有超过50个测试用例。 每种情况只包含一行中的积分整数n。 1 ≤ N ≤ 1e18 产量对于每个测试用例，输出整数表示正整数k满足的数量 k^k≤ N 在一条线上。 样品输入14 样品输出12 错误答案：1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; // 正整数 long long n; int k = 1, sum = 0; while (scanf("%I64d", &amp;n) != EOF &amp;&amp; n &gt;= 1 &amp;&amp; n &lt;= 1e18) &#123; while (k &lt;= n) &#123; if (pow(k, k) &lt;= n) &#123; sum++; k++; &#125; else &#123; break; &#125; &#125; printf("%d\n", sum); sum = 0; k = 1; &#125; return 0;&#125; 正确答案：123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;long long a[20];void deal()&#123; for (int i = 1; i &lt;= 15; i++) // 计算k的k次方 &#123; long long result = 1; for (int j = 1; j &lt;= i; j++) &#123; result *= i; &#125; a[i] = result; &#125; a[16] = (long long)1e18 * 9; // 界限是1e18&#125;int main()&#123; deal(); long long n; while (cin &gt;&gt; n) &#123; for (int i = 1; i &lt;= 16; i++) &#123; if (a[i] &gt; n) &#123; cout &lt;&lt; i - 1 &lt;&lt; endl; break; &#125; &#125; &#125;&#125; 出错原因：1. 你会发现两种方法的最大不同： 第一种是每一次算出一个k的k次方来和n比较，使用pow()函数计算k的k次方 第二种是把k^k(1&lt;=k&lt;=15)放在一个数组中，并且在最后一个数中放a[16] = 1e18 * 9计算k的k次方的函数是自己写的 2. 第二种成功的方法为什么(1&lt;=k&lt;=15)，并且在数组下标16位放1e16*9： 15^15 = 437,893,890,380,859,375 ，一共18位，但是比1e18小 16^16 = 18,446,744,073,709,511,616 ，一共20位, 比1e18大 long long的最大值：9,223,372,036,854,775,807，一共19位 这样就确定了k的范围，并且解释了为什么在数组下标16位放1e16*9 当然你也可以这样写，只要最大的数字比1e18大就好 1a[16] = (long long)1e18 + 1; // 界限是1e18 但是这样不是最严谨，尽量放大一点是最严谨的 2. 重点要解释的问题，使用pow()函数为什么会出错： pow()函数返回的是double类型的数，使用pow()函数打印15的15次方你会发现： 再拿计算器计算 两个结果不一样，对比下面两张图你就会发现 当数字大到15^15时两个计算的结果就不同，所以这就导致了第一种方法出现错误答案的原因！ 总结：解题时注意关注数据类型的取值范围和精度问题，还有题目中的数据的取值范围。]]></content>
      <categories>
        <category>ACM题目</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[春风十里，不如绿你小游戏]]></title>
    <url>%2F2017%2F08%2F29%2Fdemo%2F%E6%98%A5%E9%A3%8E%E5%8D%81%E9%87%8C%EF%BC%8C%E4%B8%8D%E5%A6%82%E7%BB%BF%E4%BD%A0%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[开始游戏]]></content>
      <categories>
        <category>Demo</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH2框架整合--实现登录]]></title>
    <url>%2F2017%2F08%2F17%2Fssh2%2FSSH2%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88--%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[知识点回顾 开始整合（使用Maven）使用Maven新建一个项目:（关于Eclipse中使用Maven可参看这篇文章）新建好一个空的Maven项目结构是这样的 接下来你需要在pom.xml中配置项目需要的jar包，eclipse会为你下载，以后开发时，你可以(到Maven的官网查找需要的包进行下载)pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com&lt;/groupId&gt; &lt;artifactId&gt;SSH2LoginDemo&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;SSH2LoginDemo Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;!-- 导入junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 导入基本的javax.servlet --&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入Mysql的连接驱动包 --&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;6.0.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.struts/struts2-spring-plugin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-spring-plugin&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- http://projects.spring.io/spring-framework/ --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- http://projects.spring.io/spring-framework/ --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-orm --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;5.2.9.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.javassist/javassist --&gt; &lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.22.0-CR1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- druid连接池 --&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.26&lt;/version&gt; &lt;/dependency&gt; &lt;!-- j2ee的注解 --&gt; &lt;!-- https://mvnrepository.com/artifact/javax.annotation/javax.annotation-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;SSH2LoginDemo&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 新建四个文件放在src/main/resource中- applicationContext.xml（配置spring） - jdbc.properties（数据库连接的属性文件） - log4j.properties（日志记录属性文件） - struts.xml（struts2的配置文件） 先写上日志记录需要的属性文件，其他三个文件具体内容在编码时给出log4j.properties 123456789101112### direct log messages to stdout ###log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### direct messages to file mylog.log ###log4j.appender.file=org.apache.log4j.FileAppenderlog4j.appender.file.File=D:\mylog.loglog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### set log levels - for more verbose logging change &apos;info&apos; to &apos;debug&apos; ###log4j.rootLogger=warn, stdout 之后你需要在src/main/webapp/WEB-INF/web.xml中添加Spring的核心监听器和Struts2的过滤器web.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt; &lt;display-name&gt;SSH2LoginDemo&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- needed for ContextLoaderListener --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Bootstraps the root web application context before servlet initialization --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置struts2拦截器-核心过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; 具体编码前，我们先创建包和文件结构，结构图如下： 开始编码：一. 视图层(登录：login.jsp ，登录成功：loginSuccess.jsp ，登录失败：回到login.jsp) login.jsp12345678910111213141516171819&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@taglib prefix="s" uri="/struts-tags" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 如果登录失败，显示登录失败信息 --&gt; &lt;h1&gt;&lt;s:property value="fieldErrors.loginFail"/&gt;&lt;/h1&gt; &lt;form action="user_login" method="post"&gt; 用户名：&lt;input type="text" name="username"&gt; 密码：&lt;input type="password" name="password"&gt; &lt;input type="submit" value="登录"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; loginSuccess.jsp 123456789101112131415&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib prefix="s" uri="/struts-tags" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;登录成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 欢迎消息，显示登陆用户的用户名 --&gt; &lt;h1&gt;欢迎你:&lt;s:property value="username"/&gt;&lt;/h1&gt; &lt;s:debug&gt;&lt;/s:debug&gt;&lt;/body&gt;&lt;/html&gt; 二.控制层(UserAction)，通过Struts.xml配置请求的ActionStruts.xml 12345678910111213141516171819&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN" "http://struts.apache.org/dtds/struts-2.5.dtd"&gt;&lt;struts&gt; &lt;!-- 开发模式 --&gt; &lt;constant name="struts.devMode" value="true"&gt;&lt;/constant&gt; &lt;!-- action的配置 --&gt; &lt;package name="ssh" namespace="/" extends="struts-default"&gt; &lt;!-- 为了安全起见，Struts2对Action中可执行的方法进行了声明，此处声明为全部 --&gt; &lt;global-allowed-methods&gt;regex:.*&lt;/global-allowed-methods&gt; &lt;!-- 匹配方法，Action交给了Spring管理，所以class属性这样写 --&gt; &lt;action name="user_*" class="userAction" method="&#123;1&#125;"&gt; &lt;!-- 成功跳转到登录成功页面 --&gt; &lt;result name="success"&gt;/loginSuccess.jsp&lt;/result&gt; &lt;!-- 失败回到登录页面 --&gt; &lt;result name="error"&gt;/login.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; UserAction.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.action;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Controller;import com.domain.User;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ModelDriven;import com.service.UserService;/** * 控制层继承ActionSupport,实现模型驱动 * @author 何军 * */@Controller // 该注解告诉Spring这是一个控制器类型的Component@Scope("prototype") // 把Action交给Spring管理，默认是单例的，该注解指定为Action多例public class UserAction extends ActionSupport implements ModelDriven&lt;User&gt;&#123; // 实现模型驱动需要new一个实体类的对象，通过getModel返回 private User user = new User(); // 自动装载UserService对象 @Autowired private UserService userService; // 返回模型user对象 public User getModel() &#123; return user; &#125; // 登录方法 public String login() &#123; // 调用Service层的方法得到用户 User existUser = userService.login(user); // 如果没有得到用户 if (existUser == null) &#123; // 加入错误提示信息 this.addFieldError("loginFail", "用户名或者密码错误"); return ERROR; &#125; else &#123; // 登录成功，将用户信息压入栈中 ActionContext.getContext().getValueStack().push(existUser); return SUCCESS; &#125; &#125;&#125; 三.业务逻辑层(UserService)，UserServiceImpl实现UserService中的方法UserService.java 123456789package com.service;import com.domain.User;public interface UserService &#123; User login(User user);&#125; UserServiceImpl.java 1234567891011121314151617181920212223package com.service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.dao.UserDao;import com.domain.User;import com.service.UserService;// 该注解说明这是一个Service类型的Commpent@Service public class UserServiceImpl implements UserService&#123; // 自动装载UserDao @Autowired private UserDao userDao; public User login(User user) &#123; // 通过用户名和密码查找用户 User existUser = userDao.findUserByUsernamAndPassword(user); return existUse; &#125;&#125; 四.数据库操作层(UserDao)，UserDaoImpl实现UserDao中的方法UserDao.java 123456789package com.dao;import com.domain.User;public interface UserDao &#123; User findUserByUsernamAndPassword(User user);&#125; UserDaoImpl.java 12345678910111213141516171819202122232425262728293031package com.dao.impl;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.orm.hibernate5.HibernateTemplate;import org.springframework.stereotype.Repository;import com.dao.UserDao;import com.domain.User;// Dao层@Repositorypublic class UserDaoImpl implements UserDao&#123; // 自动装配hibernateTemplate,这个Bean需要在applicationContext.xml中注册 @Autowired private HibernateTemplate hibernateTemplate; public User findUserByUsernamAndPassword(User user) &#123; // hql语句 String hql = "from User where username=? and password=?"; // 查找对象 List&lt;User&gt; users = (List&lt;User&gt;) hibernateTemplate.find(hql, user.getUsername(), user.getPassword()); if (users.size() &gt; 0) &#123; // 查找到的对象用户名和密码唯一，所以如果找到的话，List中的第一个对象就是要找的对象 return users.get(0); &#125; return null; &#125;&#125; 五.实体层（User）User.java 12345678910111213141516171819202122232425262728293031323334353637383940package com.domain;import java.io.Serializable;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table;// 声明实体类映射@Entity@Table(name="User")public class User implements Serializable&#123; private Integer id; // id private String username; // 用户名 private String password; // 密码 // 主键 @Id @GeneratedValue(strategy=GenerationType.AUTO) // 主键生成策略 public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; 六.建立数据库关联在数据库中创建一个名字为_ssh的数据库jjdbc.properties 1234567891011121314151617jdbc.driver=com.mysql.cj.jdbc.Driver#\u5B9A\u4E49\u8FDE\u63A5\u7684URL\u5730\u5740\uFF0C\u8BBE\u7F6E\u7F16\u7801\u96C6\uFF0C\u65F6\u95F4\u57DF\uFF0C\u5141\u8BB8\u591A\u6761SQL\u8BED\u53E5\u64CD\u4F5C\u0153jdbc.url=jdbc:mysql://localhost:3306/_ssh?characterEncoding=utf-8&amp;serverTimezone=UTC&amp;allowMultiQueries=true#jdbc:mysql://localhost:3306/thcardb?characterEncoding=utf-8&amp;serverTimezone=UTC&amp;allowMultiQueries=truejdbc.username=root#jdbc.password=asd123asdjdbc.password=123#\u5B9A\u4E49\u521D\u59CB\u8FDE\u63A5\u6570initialSize=0#\u5B9A\u4E49\u6700\u5927\u8FDE\u63A5\u6570maxActive=20#\u5B9A\u4E49\u6700\u5927\u7A7A\u95F2maxIdle=20#\u5B9A\u4E49\u6700\u5C0F\u7A7A\u95F2minIdle=1#\u5B9A\u4E49\u6700\u957F\u7B49\u5F85\u65F6\u95F4maxWait=60000 将数据库相关的全部配置作为Bean交给Spring处理，applicationContext.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd"&gt; &lt;!-- 自动扫描包下面的Bean --&gt; &lt;context:component-scan base-package="com"/&gt; &lt;!-- 加载jdbc的属性文件 --&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="location" value="classpath:jdbc.properties" /&gt; &lt;/bean&gt; &lt;!-- druid配置数据源 --&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;!-- &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"&gt;&lt;/property&gt; --&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置SessionFactory --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt; &lt;!-- 配置数据源 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 其它hibernate配置 --&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.MySQL5Dialect&lt;/prop&gt; &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.format_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt; &lt;prop key="javax.persistence.validation.mode"&gt;none&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name="packagesToScan" value="com.domain"/&gt; &lt;/bean&gt; &lt;!-- 注册hibernateTemplate这个Bean --&gt; &lt;bean id="hibernateTemplate" class="org.springframework.orm.hibernate5.HibernateTemplate"&gt; &lt;property name="sessionFactory" ref="sessionFactory" /&gt; &lt;/bean&gt; &lt;/beans&gt; 测试： 启动，自动生成了表 在数据库中加一条数据 输入错误的用户名密码测试 输入正确的用户名密码测试 总结：MVC思想是贯穿WEB开发的，回想自己当初刚刚接触WEB开发时，学习thinkphp5框架一脸懵。当时刚刚大一结束，对编程的接触就是用C语言完成了一个通讯录管理程序。用C语言实现了简单的增删改查。接触WEB开发，先学html+css，学得不怎么样，连盒子模型都没有理解透，就开始接触Boostrap框架。后来隔了一个寒假，回去开始学习thinkphp5，连框架的概念都没有的我每天学习十分得痛苦。现在，离我离开实验室应该是4个月。我自己从零开始接触了java，四个月时间，我的进步还是可观的，回想大学这一年，发生的事情真的好多。]]></content>
      <categories>
        <category>ssh2</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>hibernate</tag>
        <tag>struts2</tag>
        <tag>ssh2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页制作的总结]]></title>
    <url>%2F2017%2F08%2F13%2Fweb%E5%89%8D%E7%AB%AF%2Fhtml%2Bcss%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一. 盒子模型 在css中，width和height指的是内容区域的宽度和高度，增加内边距，边框和外边距不会影响内容区域的尺寸，但是会增加元素框的尺寸。 二.清除浮动，清除默认样式12345678910111213```` /*清除默认样式*/body&#123; margin: 0px; padding: 0px;&#125;/*清除浮动*/.clearfix &#123; zoom: 1; display: table;&#125;```` 三.使用float应该注意 float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。注释：假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止。 注意，图片本身有高度和宽度。其他浮动元素会碰到它的边框停下。 这就是文字环绕图片的原理。 浮动会让元素塌陷。即被浮动元素的父元素不具有高度。例如一个父元素包含了浮动元素，它将塌陷具有零高度。你可以按以下方法处理： 在浮动元素后加个div设置clear: both; height:0,overflow:hidden 使用clearfix; 设置父元素浮动; 四.制作弹出层 需要的知识点： 定位：absolute,relative,fixed 事件：onload,onclick DOM操作：getElementById(),scrollHeight(),clientHeight(),createElement(),appendChild(),removeChild().静止定位：相对与当前状态的屏幕静止。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Boostrap]]></title>
    <url>%2F2017%2F08%2F13%2Fweb%E5%89%8D%E7%AB%AF%2FBoostrap%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[一.响应式布局—查看Demo1.响应式布局的设计原则- 移动优先 在设计的初期就要考虑页面如何在多终端显示 - 渐进增强 充分发挥硬件设备的最大功能 2.头部声明 栅格系统进行响应式开发,头部设置响应的viewport 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;&gt; 3.网页开发中的单位： px px是相对于屏幕分辨率，大小无法跟随屏幕的放大和缩小，所有浏览器都支持 em 1em=16px(但不完全是,每个浏览器不一样)，em会继承父级元素的字体大小，IE部分浏览器不支持em rem rem和em类似,rem会继承根元素的字体大小，html{font-size:62.5%}(稳定)]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>boostrap</tag>
        <tag>响应式布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax+servlet实现百度智能提示搜索框--来自慕课课程]]></title>
    <url>%2F2017%2F08%2F08%2Fweb%E5%89%8D%E7%AB%AF%2Fajax%2Bservlet%E5%AE%9E%E7%8E%B0%E7%99%BE%E5%BA%A6%E6%99%BA%E8%83%BD%E6%8F%90%E7%A4%BA%E6%90%9C%E7%B4%A2%E6%A1%86--%E6%9D%A5%E8%87%AA%E6%85%95%E8%AF%BE%E8%AF%BE%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[查看Demo12345/** * @author xiaohejun * Man Always Remember Love Because of Romance Only. * */ 一.实现效果： 1.serach.jsp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;搜索&lt;/title&gt; &lt;style type="text/css"&gt; #myDiv &#123; position:absolute; left: 50%; top: 50%; margin-left: -200px; margin-top: -50px; &#125; .mouseOver&#123; background: #708090; color: #FFFAFA; &#125; .mouseOut&#123; background: #FFFAFA; color: #000000; &#125; &lt;/style&gt; &lt;script type="text/javascript"&gt; var xmlHttp; /*获得用户关联信息*/ function getMoreContents() &#123; // 首先获得用户输入 var content = document.getElementById("keyword"); if(content.value == "")&#123; return; &#125; // 然后给服务器发送用户输入类容，用ajax异步发送请求，获得一个对象，骄傲做xmlHttp xmlHttp = createXmlHttp(); // 要给服务器发送数据,escape()方法对字符串进行编码 var url="search?keyword=" + decodeURI(content.value); // 和服务器建立链接,true参数表示javascript脚本会在send()方法之后继续执行，而且不会等待来自服务器的响应 xmlHttp.open("GET",url); // 绑定一个回调方法，这个会调方法会在xmlHttp状态改变0-4，我们只关心4（complete）这个状态，完成之后，调用回调方法 xmlHttp.onreadystatechange=callback; xmlHttp.send(null); &#125; // 清空之前的数据 function clearContent() &#123; var tbody = document.getElementById("content_table_body"); var size = tbody.childNodes.length; for (var i = size-1; i &gt;= 0;i--) &#123; tbody.removeChild(tbody.childNodes[i]); &#125; document.getElementById("popDiv").style.border = "none"; &#125; //回调函数 function callback() &#123; if(xmlHttp.readyState==4)&#123; // 服务器响应成功 if(xmlHttp.status==200)&#123; // 交互成功，获得响应数据 var result = xmlHttp.responseText; // 解析成JSON格式 var json = eval("("+result+")"); // 获得数据之后，就可以动态显示这些数据，把这些数据展示到输入框的下面 setContent(json); &#125; &#125; &#125; // 设置关联数据的展示 function setContent(contents) &#123; clearContent(); setLocation(); var size = contents.length; for (var i = 0; i &lt; size; i++) &#123; var nextNode = contents[i]; var tr = document.createElement("tr"); var td = document.createElement("td"); td.setAttribute("border","0"); td.bgColor = "white"; td.onmouseover = function () &#123; this.className = 'mouseOver'; &#125;; td.onmouseout = function () &#123; this.className = 'mouseOut'; &#125; td.onmousedown = function() &#123; document.getElementById("keyword").value = this.innerHTML; &#125; var text = document.createTextNode(nextNode); td.appendChild(text); tr.appendChild(td); document.getElementById('content_table_body').appendChild(tr); &#125; &#125; // 获得xmlHttp对象 function createXmlHttp() &#123; // 对于大多数浏览器适用的 var xmlHttp; if (window.XMLHttpRequest) &#123; xmlHttp = new XMLHttpRequest(); &#125; // 要考虑浏览器的兼容 if (window.ActiveXObiect) &#123; xmlHttp = new ActiveXObiect("Microsoft.XMLHTTP"); if (!xmlHttp) &#123; xmlHttp = new ActiveXObiect("Msxml2.XMLHTTP"); &#125; &#125; return xmlHttp; &#125; function keywordBlur() &#123; clearContent(); &#125; // 设置显示的位置 function setLocation() &#123; // 关联信息的显示位置要和输入框一致 var content = document.getElementById("keyword"); // 输入框的宽度 var width = content.offsetWidth; // 到左边框的距离 var left = content["offsetLeft"]; // 到顶部的距离 var top = content["offsetTop"] + content.offsetHeight; // 获得显示数据的div var popDiv = document.getElementById("popDiv"); popDiv.style.border = "black 1px solid"; popDiv.style.left = left + "px"; popDiv.style.top = top + "px"; popDiv.style.width = width + "px"; document.getElementById("content_table").style.width = width + "px"; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="myDiv"&gt; &lt;!-- 输入框 --&gt; &lt;input type="text" size="50" id="keyword" onkeyup="getMoreContents()" onblur="keywordBlur()" onfocus="getMoreContents()"/&gt; &lt;input type="button" value="百度一下" width="50px"/&gt; &lt;!-- 内容展示的区域 --&gt; &lt;div id="popDiv"&gt; &lt;table id="content_table" bgcolor="#FFFAFA" border="0" cellspacing="0" cellpadding="0"&gt; &lt;tbody id="content_table_body"&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2.SearchServlet.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.servlet;import java.io.IOException;import java.util.ArrayList;import java.util.List;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import net.sf.json.JSONArray;/** * Servlet implementation class search */@WebServlet("/search")public class SearchServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; private static List&lt;String&gt; datas; /** * @see HttpServlet#HttpServlet() */ public SearchServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ static &#123; datas = new ArrayList&lt;String&gt;(); datas.add("ajax"); datas.add("ajax post"); datas.add("b啊哈"); datas.add("b哈"); datas.add("这是ajax"); datas.add("你全家都是ajax"); &#125; public List&lt;String&gt; getData(String keyword) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (String data : datas) &#123; if (data.contains(keyword)) &#123; list.add(data); &#125; &#125; return list; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException&#123; response.setCharacterEncoding("UTF-8"); request.setCharacterEncoding("UTF-8");; String keyword = request.getParameter("keyword"); List&lt;String&gt; listData = getData(keyword); response.getWriter().write(JSONArray.fromObject(listData).toString()); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doGet(request, response); &#125;&#125; 注意：不可以使用escape()函数编码，已经过时]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery+原生的javascript实现网站右侧导航定位--来自慕课课程]]></title>
    <url>%2F2017%2F08%2F08%2Fweb%E5%89%8D%E7%AB%AF%2Fjquery%2B%E5%8E%9F%E7%94%9F%E7%9A%84javascript%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%AB%99%E5%8F%B3%E4%BE%A7%E5%AF%BC%E8%88%AA%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[12345/** * @author xiaohejun * Man Always Remember Love Because of Romance Only. * */ 先看效果 demo的文件结构图你需要下载Jqueryjquery-3.2.1.js-jQuery+原生的javascript实现导航 -css -demo.css -js -demo.js -jquery-3.2.1.js -images -1.png -2.jpg -3.jpg -4.png -5.png -demo.html 界面原型demo.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;购物网站&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="css/demo.css"&gt; &lt;script src="js/jquery-3.2.1.js" rel="script"&gt;&lt;/script&gt; &lt;script src="js/demo.js" rel="script"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 菜单 --&gt; &lt;div id="menu"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#item1" class="current"&gt;1F 一楼&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#item2"&gt;2F 二楼&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#item3"&gt;3F 三楼&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#item4"&gt;4F 四楼&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#item5"&gt;5F 五楼&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="content"&gt; &lt;h1&gt;天狗购物&lt;/h1&gt; &lt;div id="item1" class="item"&gt; &lt;h2&gt;1F 男装&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="item2" class="item"&gt; &lt;h2&gt;2F 女装&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="item3" class="item"&gt; &lt;h2&gt;3F 美妆&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="item4" class="item"&gt; &lt;h2&gt;4F 数码&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="item5" class="item"&gt; &lt;h2&gt;5F 母婴&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ##样式css/demo.css1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677* &#123; margin:0px; padding: 0px;&#125;body &#123; font-size: 12px; line-height: 1.7;&#125;li &#123; list-style: none;&#125;#content &#123; width: 800px; margin: 0 auto; padding: 20px;&#125;#content h1 &#123; color: red;&#125;#content .item &#123; padding: 20px; margin-bottom: 20px; border: 1px dotted red;&#125;#content .item h2 &#123; font-size: 16px; font-weight: bold; border-bottom: 2px solid red; margin-bottom: 10px;&#125;#content .item li&#123; display: inline; margin-right: 10px;&#125;#content .item li a img &#123; width: 230px; height: 230px; border: none;&#125;#menu &#123; position: fixed; top: 100px; left: 50%; margin-left: 400px; width: 80px;&#125;#menu ul li a&#123; display: block; margin: 5px 0; font-size: 14px; font-weight: bold; color: #333; width: 80px; height:50px; line-height: 50px; text-decoration: none; text-align:center;&#125;#menu ul li a:hover,#menu ul li a.current&#123; color: #ffffff; background: red;&#125; 动作操作js/demo.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * Created by 何军 on 2017/8/7. * 使用jquery */$(document).ready(function () &#123; // 滚动条发生滚动 $(window).scroll(function () &#123; // 滚动挑距离顶部的距离 var top = $(document).scrollTop(); // 获取menu var menu = $("#menu"); // 获取每一个框 var items = $("#content").find(".item"); var currentId = ""; // 当前的id items.each(function () &#123; // 遍历每一个item var m = $(this); // 取得当前对象 var itemTop = m.offset().top; // 获得当前item的距离顶位置 if(top &gt; itemTop-200)&#123; // 如果用户滚动的距离比当前item的距离顶部位置少200px currentId = "#" + m.attr("id"); // 设置currentId 为当前id &#125; else &#123; return false; // 过头了。直接返回false退出循环 &#125; &#125;); var currentLink = menu.find(".current"); // 找到class是current的导航。初始是item1 if(currentId &amp;&amp; currentLink.attr("href") !== currentId)&#123; // 如果currentId不是空并且当前导航的href不是当前的id currentLink.removeClass("current"); // 移走current的Class // 注意此处查找方法的字符串拼接。currentId要用引号 menu.find("[href=\"" + currentId +"\"]").addClass("current"); // 找到currentId的导航加上current的class &#125; &#125;); &#125;);/*// 使用原生的jswindow.onload = function () &#123; window.onscroll = function () &#123; var top = document.documentElement ? document.documentElement.scrollTop : document.body.scrollTop; var menus = document.getElementById("menu").getElementsByTagName("a"); var items = getByClassName(document.getElementById("content"), "item"); var currentId = ""; for(var i =0; i &lt; items.length; i++) &#123; var _item = items[i]; var _itemTop = _item.offsetTop; if (top &gt; _itemTop - 200) &#123; currentId = _item.id; &#125; else &#123; break; &#125; &#125; if(currentId) &#123; // 给正确的menu的a元素current赋值 for (var i = 0; i &lt; menus.length; i++) &#123; var _menu = menus[i]; var _href = _menu.href.split("#"); if (_href[_href.length-1] !== currentId) &#123; console.log(_href[_href.length-1]); removeClass(_menu, "current"); &#125; else &#123; addClass(_menu, "current"); &#125; &#125; &#125; &#125;&#125;function getByClassName(obj,cls) &#123; var elements = obj.getElementsByTagName("*"); var result = []; for (var i=0; i &lt; elements.length; i++) &#123; if(elements[i].className === cls) &#123; result.push(elements[i]); &#125; &#125; return result;&#125;function hasClass(obj, cls) &#123; return obj.className.match(new RegExp("(\\s|^)" + cls + "(\\s|$)"));&#125;function removeClass(obj, cls) &#123; if (hasClass( obj, cls)) &#123; var reg = new RegExp("(\\s|^)" + cls + "(\\s|$)"); console.log("cls="); console.log(cls); obj.className = obj.className.replace(reg," "); &#125;&#125;function addClass(obj, cls) &#123; if (!hasClass(obj, cls)) &#123; obj.className += " " + cls; &#125;&#125;*/]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>jquery</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
