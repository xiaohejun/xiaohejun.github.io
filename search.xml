<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2020%2F02%2F02%2FACM%E9%A2%98%E7%9B%AE%2F%E9%A2%98%E8%A7%A3(codeforces)%2FEducational%20Codeforces%20Round%2081%20(Rated%20for%20Div.%202)%20D%E9%A2%98%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[KMP算法]]></title>
    <url>%2F2020%2F01%2F23%2FACM%E6%A8%A1%E6%9D%BF%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%2FKMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前述：以下讨论字符串下标均从0开始 解决的问题：一个文本串$S$(主串)和一个模式串$P$，求$P$在$S$中出现的位置，或者$P$在$S$中出现的次数，等等问题。 暴力做法：复杂度是$O(n*m)$,$n$是$P$的长度,$m$是$S$的长度 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define dbg(x) cout &lt;&lt; #x"=" &lt;&lt; x &lt;&lt; endl;const int MAX_N = 1e3+100;char s[MAX_N], p[MAX_N];// 返回P在S中的出现次数int solve(char P[], int n, char S[], int m)&#123; int ans = 0; int i,j; for(i = 0; i+n &lt;= m; ++i)&#123; for(j = 0; j &lt; n; ++j)&#123; if(S[i+j] != P[j])&#123; break; &#125; &#125; if(j == n) &#123; ans++; &#125; &#125; return ans;&#125;int main()&#123; // freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; s &gt;&gt; p; dbg(solve(p, strlen(p), s, strlen(s))) return 0;&#125; 讨论：暴力做法，字符失配以后，模式串往后移动一步，重新开始匹配 S: ABCDABCDABDE P: ABCDABD 此时在$i=6$且$j=6$处失配($i$表示指向$S$的下标，$j$表示指向$P$的下标)，由于失配，按照暴力做法，下一步的比较是下面这样的： S: ABCDABCDABDE P: ABCDABD 此时$i=1$，$j=0$重新开始比较 KMP的做法：发生不匹配的时候，$i$不移动，直接移动模式串的位置，也就是$j$的位置，假设新的$j$的位置是$k(k &lt; j)$，那么要求尽可能大的$k$使得： $S[i-k…i-1]=P[0…k-1]$（式子1） 失配的前提条件是： $S[i-j…i-1] = P[0…j-1]$，并且$S[i] != P[j]$（式子2）， 由于$k &lt; j$，由式子2可得： $S[i-k…i-1] = P[j-k…j-1]$（式子3） 那么由式子1和式子3可得$P[0…k-1]=P[j-k…j-1]$ 下面用文字的方式来解释： 式子2表示$P$的长度是$j$的前缀等于$S$的长度是$i$的前缀的长度是$j$的后缀，然后此时$S[i] != P[j]$，也就是失配了，我们知道了前面相等的匹配信息，所以不能浪费这些信息。 式子1表示我们不动下标$i$，只动下标$j$，然后使得$P$的长度是$k$的前缀等于$S$的长度是$i$的前缀的长度是$k$的后缀。然后$k &lt; j$并且$k$越大越好。 由式子2我们推出式子3，也就是$P$的长度是$j$的前缀的长度是$k$的后缀等于$S$的长度是$i$的前缀的长度是$k$的后缀。 根据上面的叙述，我们定义一个数组$next$： $next[j] = k$，表示到$S[i] != P[j]$的时候，下一步$j$指针需要跳到$k$的位置 由上面的分析可以知道。$next[j]=k$表示为满足$P[0…k-1] = P[j-k…j-1]$的最大$k$ 文字解释： $next[j]$表示字符串$P$的长度是$j$的前缀的前缀和后缀相等的最大长度 P：ABCDABD next：-1 0 0 0 0 1 2 0 如何求解next数组：求解$next$数组的代码 1234567void kmp_pre(char P[], int m, int nxt[])&#123; int i = 0, j = nxt[0] = -1; while(i &lt; m)&#123; while(j != -1 &amp;&amp; P[i] != P[j]) j = nxt[j]; nxt[++i] = ++j; &#125;&#125; 当前我们已经知道$next[i] = j$，那么可知$P[0…j-1]=P[i-j…i-1]$，如果$P[i] == P[j]$，那么就是$P[0…j]=P[i-j…i]$，那么可以推知$next[i+1]=next[j+1]$，等价于$next[++i]=next[++j]$，如果$P[i] != P[j]$那么令$j=next[j]$，我们已经知道$P[0…next[j]-1]=P[i-next[j]…i-1]$，同样的道理，这样继续下去。可以看出$next$数组是字符串$P$自己和自己匹配的结果。 next数组的其他操作：1.next数组的跳转：沿着next数组一直往前，得到的是所有即使前缀也是后缀的字符串 next数组往前跳的步数的步长是一样的，除了最后一次 下标 0 1 2 3 4 5 6 7 8 9 10 11 P A B C A B C A B C A B next -1 0 0 0 1 2 3 4 5 6 7 8 从11开始跳： 得到11，8，5，2，0 从10开始跳： 得到10，7，4，1，0 从9开始跳： 得到9，6，3，0 从8开始跳： 得到8，5，2，0 等等。。。可以看出步长都是3 从11开始跳到8得到字符串AB 从8跳到5得到字符串ABCAB 从5跳到2得到字符串ABCABCAB 从2跳到0得到字符串ABCABCABCAB 以上四个字符串就是字符串$P$的既是前缀也是后缀的字符串 2.周期性字符串如果$n \mod (n-next[n]) == 0$，那么循环节的长度是$n-next[n]$ 推导一下：对于模式串$P$有它的前缀$P[0…next[n]-1]$有$P[0…next[n]-1]=P[n-next[n]…n-1]$，通俗的说就是对于串$P[0…n-1]$，它的前半段长度是$k$的串和它的后半段长度是$k$的串相等。那么$n-next[n]$长的字符串就是后面的$P[n-(n-next[n])…n-1]$，也就是$P[next[n]…n-1]$，假设现在条件成立，即$n \mod (n-next[n]) == 0$，对于$next[next[n]]$，有$P[0…next[next[n]]-1]=P[next[n]-next[next[n]]…next[n]-1]$ 综上可以推出:$P[next[next[n]]…next[n]-1] = P[next[n]…n-1]$ 同样的道理推下去就可以知道循环节的长度是$n-next[n]$ 举个例子： 下标 0 1 2 3 4 5 6 7 8 9 10 11 12 P a b c a b c a b c a b c next -1 0 0 0 1 2 3 4 5 6 7 8 9 条件： 条件1： (abcabcabc) abc abc (abcabcabc) $P[0…next[n]-1]=P[n-next[n]…n-1]$ 条件2： (abcabc) abcabc abc (abcabc) abc $P[0…next[next[n]]-1]=P[next[n]-next[next[n]]…next[n]-1]$ 推出结论： (abcabc) [abc] abc abc (abcabc) [abc] $P[next[next[n]]…next[n]-1] = P[next[n]…n-1]$ 相关题目练习：1.POJ3461题目描述：给$t$组数据，每一组数据给两个字符串$W$和$T$，求字符串$W$在字符串$T$的出现次数 题解：直接上kmp就完事了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;#define dbg(x) cout &lt;&lt; #x"=" &lt;&lt; x &lt;&lt; endl;int t;string W, T;int m,n;const int MAX_M = 1e4+100;int nxt[MAX_M];void solve()&#123; m = W.size(); int i,j; j = nxt[0] = -1; i = 0; while(i &lt; m)&#123; while(j != -1 &amp;&amp; W[i] != W[j]) j = nxt[j]; nxt[++i] = ++j; &#125; int ans = 0; n = T.size(); for(i = 0, j = 0; i &lt; n; ++i)&#123; if(j &lt; m &amp;&amp; W[j] == T[i])&#123; ++j; &#125; else &#123; while(j &gt; 0)&#123; j = nxt[j]; if(W[j] == T[i])&#123; ++j; break; &#125; &#125; &#125; if(j == m) ++ans; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; W &gt;&gt; T; solve(); &#125; return 0;&#125; 2.hdu1711题目描述：有两个序列一个是长度为$n$的数字序列$a$，一个是长度是$m$的数字序列$b$，求最小的$k$使得$a[k…k+m-1] = b[1…m]$ 题解：就是求$b$在$a$中第一次出现的位置，直接上kmp就完事了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define dbg(x) cout &lt;&lt; #x"=" &lt;&lt; x &lt;&lt; endl;const int MAX_N = 1e6+100;const int MAX_M = 1e4+100;int a[MAX_N], b[MAX_M];int nxt[MAX_M];int n,m;int T;void solve()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; for(int i = 0; i &lt; m; ++i) cin &gt;&gt; b[i]; int i = 0, j = nxt[0] = -1; while(i &lt; m)&#123; while(j != -1 &amp;&amp; b[i] != b[j]) j = nxt[j]; nxt[++i] = ++j; &#125; for(i = 0, j = 0; i &lt; n; ++i)&#123; if(j &lt; m &amp;&amp; a[i] == b[j])&#123; ++j; &#125; else &#123; while(j &gt; 0)&#123; j = nxt[j]; if(a[i] == b[j])&#123; ++j; break; &#125; &#125; &#125; if(j == m) &#123; cout &lt;&lt; i-m+2 &lt;&lt; endl; return; &#125; &#125; cout &lt;&lt; "-1" &lt;&lt; endl;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; T; while(T--) solve(); return 0;&#125;/*a[k...k+m-1] = b[1...m]*/ 3.poj1961题目描述：求一个字符串的前缀中的周期性字符串个数 题解：利用$next$数组的性质求解 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;typedef long long LL;#define dbg(x) cout &lt;&lt; #x"=" &lt;&lt; x &lt;&lt; endl;const int MAX_N = 1e6+100;int nxt[MAX_N];int n;string s;void solve(int t)&#123; cin &gt;&gt; s; int i = 0, j = nxt[0] = -1; while(i &lt; n)&#123; while(j != -1 &amp;&amp; s[i] != s[j]) j = nxt[j]; nxt[++i] = ++j; &#125; cout &lt;&lt; "Test case #" &lt;&lt; t &lt;&lt; endl; for(int i = 2; i &lt;= n; ++i)&#123; if(i%(i-nxt[i]) == 0)&#123; int k = i/(i-nxt[i]); if(k &gt; 1) cout &lt;&lt; i &lt;&lt; " " &lt;&lt; k &lt;&lt; endl; &#125; &#125; cout &lt;&lt; endl;&#125; int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int t = 0; while(cin &gt;&gt; n &amp;&amp; n) &#123; solve(++t); &#125; return 0;&#125; 4.poj2406题目描述：求一个字符串由几个周期性字符串构成 题解：解法大致同上一题 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;typedef long long LL;#define dbg(x) cout &lt;&lt; #x"=" &lt;&lt; x &lt;&lt; endl;const int MAX_N = 1e6+100;char s[MAX_N];int nxt[MAX_N]; int main()&#123; //freopen("in.txt", "r", stdin); while(~scanf("%s", s) &amp;&amp; s[0] != '.')&#123; int i = 0, j = nxt[0] = -1; int n = strlen(s); while(i &lt; n)&#123; while(j != -1 &amp;&amp; s[i] != s[j]) j = nxt[j]; nxt[++i] = ++j; &#125; printf("%d\n", n%(n-nxt[n]) ? 1 : n/(n-nxt[n])); &#125; return 0;&#125; 5.hdu3336题目描述：求一个字符串中前缀在该字符串中出现的次数总和 题解：解法1： $dp[i]$ 表示长度是$i$的前缀的出现次数 $nxt[i]$表示前缀是$i$的字符串的前缀和后缀相等的最大长度 也就是说只要是长度为$i$的前缀在字符串中出现 容易知道$dp[i]$的初始值均为1 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define dbg(x) cout &lt;&lt; #x"=" &lt;&lt; x &lt;&lt; endl;const int MAX_N = 2e5+100;const int MOD = 10007;int T;int n;char s[MAX_N];int nxt[MAX_N];int dp[MAX_N];void solve()&#123; int i = 0, j = nxt[0] = -1; while(i &lt; n)&#123; while(j != -1 &amp;&amp; s[i] != s[j]) j = nxt[j]; nxt[++i] = ++j; &#125; int ans = 0; for(int i = 1; i &lt;= n; ++i) dp[i] = 1; for(int i = n; i &gt;= 1; --i)&#123; dp[nxt[i]] = dp[nxt[i]] + dp[i]; ans = (ans + dp[i]) % MOD; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; T; while(T--) &#123; cin &gt;&gt; n; cin &gt;&gt; s; solve(); &#125; return 0;&#125; 解法2： $dp[i]$表示前$i$个字符中前缀的匹配次数，显然$dp[0]=0$ 动态转移方程$dp[i]=dp[nxt[i]]+1$ 也就是说：前$i$个字符中前缀的匹配次数等于前$nxt[i]$中前缀的匹配次数加上1， 加上的1显然就是长度为$i$的前缀 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define dbg(x) cout &lt;&lt; #x"=" &lt;&lt; x &lt;&lt; endl;const int MAX_N = 2e5+100;const int MOD = 10007;int T;int n;char s[MAX_N];int nxt[MAX_N];int dp[MAX_N];void solve()&#123; int i = 0, j = nxt[0] = -1; while(i &lt; n)&#123; while(j != -1 &amp;&amp; s[i] != s[j]) j = nxt[j]; nxt[++i] = ++j; &#125; int ans = 0; dp[0] = 0; for(int i = 1; i &lt;= n; ++i)&#123; dp[i] = dp[nxt[i]] + 1; ans = (ans + dp[i]) % MOD; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123;// freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; T; while(T--) &#123; cin &gt;&gt; n; cin &gt;&gt; s; solve(); &#125; return 0;&#125; 6.hdu3746题目描述：求最少在一个字符串后面条件多少个字符使得该字符串是一个周期性字符串 题解：由next数组的周期性可以知道。令$rem = n - next[n]$，可以知道当前字符串被分成若干段长度是$rem$的字符串，但是最后一段长度不一定是$rem$，所以只要看模数是多少，补齐使得对$rem$取余是0就行了 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define dbg(x) cout &lt;&lt; #x"=" &lt;&lt; x &lt;&lt; endl;const int MAX_N = 1e5+100;int T;char s[MAX_N];int nxt[MAX_N];void solve()&#123; int i = 0, j = nxt[0] = -1; int n = strlen(s); while(i &lt; n)&#123; while(j != -1 &amp;&amp; s[i] != s[j]) j = nxt[j]; nxt[++i] = ++j; &#125; int rem = n-nxt[n]; int mod = n%rem; if(nxt[n] == 0) cout &lt;&lt; n &lt;&lt; endl; else cout &lt;&lt; (rem-mod) % rem &lt;&lt; endl;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; T; while(T--) &#123; cin &gt;&gt; s; solve(); &#125; return 0;&#125; 7.hdu2594题目描述：求$s1$的前缀和$s2$的后缀的最大匹配 题解：下面的做法是错误的，但是交上去还是对了，数据弱得一皮，过不了下面这一组数据 xxoooxxxxxxxxxooo 将$s1$和$s2$拼接成为$s$，求$s$的$nxt$数组。如果$nxt[n]==0$那么答案就是0这个显而易见。如果$nxt[n] &lt;= min(|s1|, |s2|)$，那么答案长度就是$nxt[n]$，(错误分析开始)如果$nxt[n] &gt; min(|s1|,|s2|)$，那么长度取$min(|s1|, |s2|)$ 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define dbg(x) cout &lt;&lt; #x"=" &lt;&lt; x &lt;&lt; endl;const int MAX_N = 1e5+100;string s1, s2;int nxt[MAX_N];int main()&#123; // freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); while(cin &gt;&gt; s1 &gt;&gt; s2)&#123; int x = s1.size(); int y = s2.size(); string s = s1+s2; int n = s.size(); int i = 0, j = nxt[0] = -1; while(i &lt; n)&#123; while(j != -1 &amp;&amp; s[i] != s[j]) j = nxt[j]; nxt[++i] = ++j; &#125; if(nxt[n]) &#123; int len = min(min(x, y), nxt[n]); cout &lt;&lt; s.substr(0, len) &lt;&lt; " " &lt;&lt; len &lt;&lt; endl; &#125; else cout &lt;&lt; "0" &lt;&lt; endl; &#125; return 0;&#125; 正确做法: 将$s1$和$s2$连接成$s$，求$s$的$next$数组，从$n$开始跳，直到跳到某个$j$使得$next[j] &lt;= mn(|s1|, |s2|)$。这个其实用到了$next$数组的那个周期性的性质。每次跳的步数是$n-next[n]$，也就是说每次不要的字符串长度是$n-next[n]$这么长，最后得到的字符串长度$&lt;=min(|s1|, |s2|)$而且相等。kmp的$next$数组简直就是米奇妙妙屋 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define dbg(x) cout &lt;&lt; #x"=" &lt;&lt; x &lt;&lt; endl;const int MAX_N = 1e5+100;string s1, s2;int nxt[MAX_N];int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); while(cin &gt;&gt; s1 &gt;&gt; s2)&#123; int x = s1.size(); int y = s2.size(); int mn = min(x, y); string s = s1+s2; int n = s.size(); int i = 0, j = nxt[0] = -1; while(i &lt; n)&#123; while(j != -1 &amp;&amp; s[i] != s[j]) j = nxt[j]; nxt[++i] = ++j; &#125; int len = nxt[n]; j = n; while(len &gt; mn)&#123; // nxt[j] &lt;= mn j = nxt[j]; len = nxt[j]; &#125; if(len) cout &lt;&lt; s.substr(0, len) &lt;&lt; " " &lt;&lt; len &lt;&lt; endl; else cout &lt;&lt; "0" &lt;&lt; endl; &#125; return 0;&#125;/*(xxooo)xxxxxxx(xxooo)*/ 8.poj2185题目描述：给一个字符串矩阵，求一个最小的矩阵使得把这个矩阵循环重复铺开之后它的一个子矩阵是给的那个矩阵 题解：按行看，把每一行当一个字母，得到一个字符串，求这个字符串的$next$数组，则答案矩阵的$r = R - nxt[R]$，同样道理按列看，求得$c = C - nxt[C]$，答案为$r * c$。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;typedef long long LL;#define dbg(x) cout &lt;&lt; #x"=" &lt;&lt; x &lt;&lt; endl;const int MAX_R = 1e4+100;const int MAX_C = 100;int nxt[MAX_R];int R,C;string s[MAX_R];string t[MAX_C];int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; R &gt;&gt; C; for(int i = 0; i &lt; R; ++i)&#123; cin &gt;&gt; s[i]; &#125; int i = 0, j = nxt[0] = -1; while(i &lt; R)&#123; while(j != -1 &amp;&amp; s[i] != s[j]) j = nxt[j]; nxt[++i] = ++j; &#125; int r = R - nxt[R]; for(int j = 0; j &lt; C; ++j)&#123; t[j] = ""; for(int i = 0; i &lt; R; ++i)&#123; t[j] += s[i][j]; &#125; &#125; i = 0, j = nxt[0] = -1; while(i &lt; C)&#123; while(j != -1 &amp;&amp; t[i] != t[j]) j = nxt[j]; nxt[++i] = ++j; &#125; int c = C - nxt[C]; cout &lt;&lt; r * c &lt;&lt; endl; return 0;&#125; 9.hdu4763题目描述：在一个字符串$s$中求一个子串$t$，使得$t$在$s$的前，中，后位置都有匹配。 题解：根据$next$数组的含义，$next[i]$表示字符串$s$的长度是$i$的前缀中的相等的最长前缀和后缀。所以答案就是$min(next[n], max(next[1…n-1]))$。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define dbg(x) cout &lt;&lt; #x"=" &lt;&lt; x &lt;&lt; endl;const int MAX_N = 1e6+100;char s[MAX_N];int nxt[MAX_N];int T;int main()&#123; // freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; s; int n = strlen(s); int i = 0, j = nxt[0] = -1; while(i &lt; n)&#123; while(j != -1 &amp;&amp; s[i] != s[j]) j = nxt[j]; nxt[++i] = ++j; &#125; int mx = nxt[1]; for(int i = 2; i &lt;= n-1; ++i) mx = max(mx, nxt[i]); cout &lt;&lt; min(mx, nxt[n]) &lt;&lt; endl; &#125; return 0;&#125; 10.hdu6153题目描述：有两个字符串$s1$和$s2$，令$s2$的某一个后缀的权值是长度乘上该后缀在$s1$中的出现次数，求$s2$的所有后缀的权值和对$1e9+7$取模的值 题解：首先想办法求$s2$中某一个后缀在$s1$中的出现次数。将$s1$和$s2$都逆序，问题就转换横求$s2$中的某一个前缀在$s1$中出现的次数。和hdu3336类似，hdu3336求的是 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define dbg(x) cout &lt;&lt; #x"=" &lt;&lt; x &lt;&lt; endl;const int MAX_N = 1e6+100;const LL MOD = 1e9+7;int nxt[MAX_N];LL dp[MAX_N];LL N[MAX_N];char s1[MAX_N], s2[MAX_N];int T;void solve()&#123; cin &gt;&gt; s1 &gt;&gt; s2; int n = strlen(s1), m = strlen(s2); reverse(s1, s1+n); reverse(s2, s2+m); for(int i = 0; i &lt;= m; ++i) dp[i] = 0; int i = 0, j = nxt[0] = -1; while(i &lt; m)&#123; while(j != -1 &amp;&amp; s2[i] != s2[j]) j = nxt[j]; nxt[++i] = ++j; &#125; for(i = 0, j = 0; i &lt; n; ++i)&#123; if(j &lt; m &amp;&amp; s1[i] == s2[j])&#123; dp[++j]++; &#125; else &#123; while(j &gt; 0)&#123; j = nxt[j]; if(s1[i] == s2[j])&#123; dp[++j]++; break; &#125; &#125; &#125; &#125; for(i = m; i &gt;= 1; --i)&#123; dp[nxt[i]] += dp[i]; &#125; LL ans = 0; for(i = 1; i &lt;= m; ++i)&#123; ans = (ans + i * dp[i] % MOD) % MOD; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; // freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; T; while(T--) solve(); return 0;&#125; 11.hdu5510题目描述：题解：]]></content>
      <categories>
        <category>ACM算法模板合集</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM算法模板合集目录]]></title>
    <url>%2F2020%2F01%2F23%2FACM%E6%A8%A1%E6%9D%BF%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%2FACM%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%90%88%E9%9B%86%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[前言​ 算一算也是打了两年acm，没有获得什么大成就。所以想学一遍ACM算法模板上的所有知识，以及找一些习题来做，不知道这个系列什么时候完成，反正会一直努力更新中。 目录字符串处理 KMP算法]]></content>
      <categories>
        <category>ACM算法模板合集</category>
      </categories>
      <tags>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯云社区博客同步声明]]></title>
    <url>%2F2020%2F01%2F22%2F%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%8D%B3%E5%B0%86%E5%90%8C%E6%AD%A5%E8%87%B3%E8%85%BE%E8%AE%AF%E4%BA%91%2B%E7%A4%BE%E5%8C%BA%EF%BC%8C%E9%82%80%E8%AF%B7%E5%A4%A7%E5%AE%B6%E4%B8%80%E5%90%8C%E5%85%A5%E9%A9%BB%EF%BC%9Ahttpscloud%2F</url>
    <content type="text"><![CDATA[我的博客即将同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=271mewktykisc]]></content>
      <categories>
        <category>腾讯云</category>
      </categories>
      <tags>
        <tag>声明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小黑盒和长亭科技面经]]></title>
    <url>%2F2020%2F01%2F22%2F%E9%9D%A2%E7%BB%8F%2F%E5%B0%8F%E9%BB%91%E7%9B%92%E5%92%8C%E9%95%BF%E4%BA%AD%E7%A7%91%E6%8A%80%2F</url>
    <content type="text"><![CDATA[首先是小黑盒的电话面试Q：浅拷贝构造与深拷贝构造 类中有指针的时候，需要用深拷贝开辟一块新内存 Q：什么是SQL注入,怎么解决SQL注入 什么是SQL注入？ SQL注入（SQLi）是一种注入攻击，，可以执行恶意SQL语句。它通过将任意SQL代码插入数据库查询，使攻击者能够完全控制Web应用程序后面的数据库服务器。攻击者可以使用SQL注入漏洞绕过应用程序安全措施；可以绕过网页或Web应用程序的身份验证和授权，并检索整个SQL数据库的内容；还可以使用SQL注入来添加，修改和删除数据库中的记录。 SQL注入漏洞可能会影响使用SQL数据库（如MySQL，Oracle，SQL Server或其他）的任何网站或Web应用程序。犯罪分子可能会利用它来未经授权访问用户的敏感数据：客户信息，个人数据，商业机密，知识产权等。SQL注入攻击是最古老，最流行，最危险的Web应用程序漏洞之一。 SQL注入攻击的类型 SQL注入攻击可以通过多种方式执行。在选择特定攻击方法之前，攻击者可能会观察系统的行为。 带内注入 这是典型的攻击，攻击者可以通过相同的通信通道发起攻击并获得结果。这是通过两种带内技术完成的： ● 基于错误的SQL注入：从显示的错误消息中获取有关数据库的信息 ● 基于联合的SQL注入：依赖于攻击者能够将UNION ALL被盗信息的结果与合法结果连接起来。 这两种技术都依赖于攻击者修改应用程序发送的SQL，以及浏览器中显示的错误和返回的信息。如果应用程序开发人员或数据库开发人员无法正确地参数化他们在查询中使用的值，那么它会成功。两者都是试错法，可以检测到错误。 盲注入 也称为推理SQL注入，盲注入攻击不会直接从目标数据库中显示数据；相反，攻击者会仔细检查行为中的间接线索。HTTP响应中的详细信息，某些用户输入的空白网页以及数据库响应某些用户输入需要多长时间，这些都可以是线索，具体取决于攻击者的目标。他们还可以指向攻击者尝试的另一个SQLi攻击途径。 带外注入 这种攻击有点复杂，当攻击者无法在单个直接查询 - 响应攻击中实现其目标时，攻击者可能会使用此攻击。通常，攻击者会制作SQL语句，这些语句在呈现给数据库时会触发数据库系统创建与攻击者控制的外部服务器的连接。以这种方式，攻击者可以收集数据或可能控制数据库的行为。 二阶注入就是一种带外注入攻击。在这种情况下，攻击者将提供SQL注入，该注入将由数据库系统的单独行为存储和执行。当二级系统行为发生时（它可能类似于基于时间的作业或由其他典型管理员或用户使用数据库触发的某些事情）并且执行攻击者的SQL注入，那就是当“伸出”到系统时攻击者控制发生了。 如何防止SQL注入攻击？ 以下建议可以帮助防止SQL注入攻击成功： 不要使用动态SQL 避免将用户提供的输入直接放入SQL语句中；最好使用准备好的语句和参数化查询，这样更安全。 不要将敏感数据保留在纯文本中 加密存储在数据库中的私有/机密数据；这样可以提供了另一级保护，以防攻击者成功地排出敏感数据。 限制数据库权限和特权 将数据库用户的功能设置为最低要求；这将限制攻击者在设法获取访问权限时可以执行的操作。 避免直接向用户显示数据库错误 攻击者可以使用这些错误消息来获取有关数据库的信息。 对访问数据库的Web应用程序使用Web应用程序防火墙（WAF） 这为面向Web的应用程序提供了保护，它可以帮助识别SQL注入尝试；根据设置，它还可以帮助防止SQL注入尝试到达应用程序（以及数据库）。 定期测试与数据库交互的Web应用程序 这样做可以帮助捕获可能允许SQL注入的新错误或回归。 将数据库更新为最新的可用修补程序 这可以防止攻击者利用旧版本中存在的已知弱点/错误。 总结：SQL注入是一种流行的攻击攻击方法，但是通过采取适当的预防措施，例如确保数据加密，保护和测试Web应用程序，以及您是最新的补丁程序，您可以采取有意义的步骤来保持您的数据安全。 Q：从输入一个URL到访问到资源经历的过程 应用层：http 传输层：tcp 网络层：ip 数据链路层：arp 物理层：比特流 Q：URL转ip地址用的什么协议？该协议传输层用的什么协议？为什么？ DNS协议。 DNS系统采用递归查询请求的方式来响应用户的查询，其一般过程如下： (1)客户端首先向首选域名服务器查询。 (2)首选域名服务器检查本地资源记录，如果存在则作权威回答，如果不存在，则检查本地缓存，如果有记录则直接返回结果。若本地资源记录和缓存记录都不存在，则向根域名服务器查询。 (3)根域名服务器返回相应顶级域的权威域名服务器的地址，首选域名服务器继续向该顶级权威域名服务器查询。 (4)顶级权威域名服务器返回次级域的权威域名服务器地址，首选域名服务器如此迭代查询，直到得到对查询域名的权威回答，保存在本地缓存中并返回给客户端，完成此次查询。目前绝大多数的网络都会开放DNS服务，DNS数据包不会被防火墙等网络安全防护设备拦截，因此，可以基于DNS协议建立隐蔽通道，从而顺利穿过防火墙，在客户端和服务器之间隐蔽地传输数据。 DNS区域传输的时候使用TCP协议： 1.辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。 2.TCP是一种可靠连接，保证了数据的准确性。 域名解析时使用UDP协议： 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。 Q：什么是索引，为什么要使用索引，索引使用多了会造成什么后果？ 索引是对数据库表中一个或多个列的值进行排序的结构。 设置索引付出的代价：1：增加了数据库的存储空间 2：插入和修改的时候需要花费较多的时间（因为索引也要随之变动） 好处：提高了表的搜索效率 Q：TCP为什么是3次握手？ 3次握手可以实现功能，4次的话比较多余，如果是2次握手的话会出现问题，具体问题如下解释： A发一个消息给B，网络原因阻塞，然后A超时重传。当A和B通信完了之后，这个阻塞的消息到达了B，B以为是A的一个新请求，所以一直会给他一个确认，等待和A建立连接发数据，但是对于A来言，他不会去理睬这个确认，所以B的资源就被浪费了。 Q：什么是逻辑地址，什么是物理地址，页面置换算法有哪些？ 逻辑地址（Logical Address） 是指由程序产生的与段相关的偏移地址部分。 物理地址就是内存中真实的地址 页面置换算法有：FIFO，OPT，LRU，NRU Q：线程/进程之间通信方法？死锁怎么预防？使用多线程需要注意哪些问题？ 进程间通信： 管道，命名管道，信号量，消息队列，信号，共享内存，套接字，全双工管道 线程间通信： 锁机制，信号量机制，信号机制 Q：递归转迭代需要用什么数据结构？为什么？ 用栈，递归本来就是函数栈的调用 Q：服务端80端口被占用怎么办？ netstat可以查看端口状态 Q：什么命令可以查看进程运行状态？ ps命令 准备长亭科技视频面试的时候的YYQ：topK问题 1.排序，取第k大，时间复杂度O(nlogn) 2.使用堆，复杂度O(nlogk) 3.冒泡，复杂度O(k*n) 4.BFPRT算法，复杂度O(n) Q：写一个快排 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 1e6+100;int n;int a[MAX_N];#define dbg(x) cout &lt;&lt; #x"=" &lt;&lt; x &lt;&lt; endl;int partition(int *a, int l, int r)&#123; int key = a[l]; while(l &lt; r)&#123; while(l &lt; r &amp;&amp; key &lt;= a[r]) --r; a[l] = a[r]; while(l &lt; r &amp;&amp; a[l] &lt;= key) ++l; a[r] = a[l]; &#125; a[l] = key; return l;&#125;void quickSort(int *a, int l, int r)&#123; int p; // 中间的位置 if(l &lt; r)&#123; p = partition(a, l, r); quickSort(a, l, p-1); quickSort(a, p+1, r); &#125;&#125;int main()&#123; //freopen("in.txt", "r", stdin); cin &gt;&gt; n; for(int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; quickSort(a, 0, n-1); for(int i = 0; i &lt; n; ++i)&#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; Q：写一个0/1背包 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int T;const int MAX_N = 1e3+100;int N,V; // N:个物品 V:容量int v[MAX_N], w[MAX_N]; // v:价值, w:重量int f[MAX_N];int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; N &gt;&gt; V; for(int i = 0; i &lt;= V; ++i) f[i] = 0; for(int i = 0; i &lt; N; ++i)&#123; cin &gt;&gt; v[i]; &#125; for(int i = 0; i &lt; N; ++i)&#123; cin &gt;&gt; w[i]; &#125; for(int i = 0; i &lt; N; ++i)&#123; for(int j = V; j &gt;= w[i]; --j)&#123; f[j] = max(f[j], f[j-w[i]]+v[i]); &#125; &#125; cout &lt;&lt; f[V] &lt;&lt; endl; &#125; return 0;&#125; 面完长亭科技之后记得的问题，以为凉了但是还是得实习offer了Q：死锁的必要条件 互斥条件 请求与保持条件 不剥夺条件 循环等待条件 Q：写三路快排 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 1e6+100;int n;int a[MAX_N];#define dbg(x) cout &lt;&lt; #x"=" &lt;&lt; x &lt;&lt; endl;/*[l, lt-1] &lt; v[gt, r] &gt; v[lt, gt-1] = vx x x x x x x x x x*/void partition(int *a, int l, int r, int &amp;lt, int &amp;gt)&#123; int key = a[l]; lt = l; gt = r + 1; int i = l+1; while( i &lt; gt )&#123; if(a[i] &lt; key)&#123; swap(a[i++], a[lt+1]); lt++; &#125; else if(a[i] &gt; key)&#123; swap(a[i], a[gt-1]); gt--; &#125; else i++; &#125; swap(a[l] , a[lt]);&#125;void quickSort(int *a, int l, int r)&#123; int lt, gt; if(l &lt; r)&#123; partition(a, l, r, lt, gt); quickSort(a, l, lt-1); quickSort(a, gt, r); &#125;&#125;int main()&#123; freopen("in.txt", "r", stdin); cin &gt;&gt; n; for(int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; quickSort(a, 0, n-1); for(int i = 0; i &lt; n; ++i)&#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; Q：写LCA(二叉树就行) 123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root == NULL || root == p || root == q) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); if(left != NULL &amp;&amp; right != NULL) return root; else if(left != NULL) return left; else if(right != NULL) return right; else return NULL; &#125;&#125;; Q：红黑树的定义 面试得offer了就没看，坑待填 Q：正则表达式是什么文法 面试得offer了就没看，坑待填]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>小黑盒</tag>
        <tag>长亭科技</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[银联高校极客挑战赛-复赛-D-多项式]]></title>
    <url>%2F2019%2F08%2F10%2FACM%E9%A2%98%E7%9B%AE%2F%E9%A2%98%E8%A7%A3(%E8%AE%A1%E8%92%9C%E5%AE%A2)%2F%E9%93%B6%E8%81%94%E9%AB%98%E6%A0%A1%E6%9E%81%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B-%E5%A4%8D%E8%B5%9B-D-%E5%A4%9A%E9%A1%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[$f[u][j]$表示以$u$为根的子树中$u$到所有$v$(子树中的节点)的路径和的$j$次方的和。可以得到一个动态转移方程:考虑二项式展开:$(a+b+c)^j = \sum_{k = 0}^j C(j, k) (a+b)^k c^{j-k}$ 类似的:$(a+b+c)^j + (d+e+c)^j= \sum_{k = 0}^j C(j, k) ((a+b)^k + (d+e)^k) c^{j-k}$ 所以通过这个性质可以得到动态转移方程:记$fa[v]$表示节点$v$的父亲结点.$w$表示$(u, v)$之间的权值 $$f[u][j] = \sum_{fa[v]==u} \sum_{k=0}^jC(j, k) f[v][k] w^{j-k}$$ 得到了从结点$u$到它的子树的结点的路径$K$次方权值和之后,我们还需要计算从结点$u$到它除去它的子树的结点也就是它的父亲的那边的那些结点的路径$K$次方权值和。 $g[v][j]$表示从结点v到除去结点$v$的子树中的结点(也就是$v$到$v$的父亲结点那个方向的结点)边权的$j$次方的和 记$v$结点的父亲结点是$u$. 记$u$和$v$之间的边权是$w$ 所以我们可以得到动态转移方程. $$t[j] = g[u][j] + f[u][j] - \sum_{k=0}^jC(j, k) f[v][k] w^{j-k}$$ $$g[v][j] = \sum_{k = 0}^j C(j, k) w ^ k t[j-k]$$ (备注:关于这个动态转移方程的解释如下) $g[u][j]$表示从结点$u$到父亲结点方向的$j$次方权值和. $f[u][j]$表示从结点$u$到它的子树方向结点的$j$次方权值和. 现在$v$是$u$的一个孩子结点. 那么通过我们计算得到的上面式子的$t$就是从结点$u$出发到除去$v$为根的子树的结点(包括$v$)的所有结点的$j$次方权值和.我们现在要算从$v$出发到除去自己子树下面的结点的$j$次方权值和.再加上$u$到$v$之间的权值的$j$次方即可 所以最后答案显然是: $$ \frac{\sum_{i = 1}^n f[i][K] + g[i][K]}{n^2} $$ 当然计算过程中要进行取模运算，以及最后的要进行模逆元的运算。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x) cout &lt;&lt; #x"=" &lt;&lt; x &lt;&lt; endl;#define SZ(x) (x).size()typedef long long LL;const LL MOD = 998244353;const int MAX_N = 1e5+100;const int MAX_K = 15;int n,K;LL f[MAX_N][MAX_K], g[MAX_N][MAX_K];LL ans;struct P&#123; int v; LL w;&#125;;vector&lt;P&gt; G[MAX_N];int fa[MAX_N];LL C[MAX_K][MAX_K];LL W[MAX_K], h[MAX_K], t[MAX_K];LL powN(LL base, LL n)&#123; LL res = 1; while(n)&#123; if(n&amp;1) res = res * base % MOD; base = base * base % MOD; n &gt;&gt;= 1; &#125; return res;&#125;LL inv(LL x)&#123; return powN(x, MOD-2);&#125;void add(LL &amp;x, LL y)&#123; x += y; if(x &gt;= MOD) x -= MOD;&#125;// 计算f[u][j]void dfs1(int u)&#123; f[u][0] = 1; for(P it : G[u])&#123; int v = it.v; LL w = it.w; if(fa[u] == v) continue; fa[v] = u; dfs1(v); W[0] = 1; for(int i = 1; i &lt;= K; ++i) W[i] = W[i-1] * w % MOD; for(int j = 0; j &lt;= K; ++j)&#123; for(int k = 0; k &lt;= j; ++k)&#123; add(f[u][j], C[j][k] * f[v][k] % MOD * W[j-k] % MOD); &#125; &#125; &#125; add(ans, f[u][K]);&#125;// 计算g[v][j]void dfs2(int u)&#123; for(P it : G[u])&#123; int v = it.v; LL w = it.w; if(fa[u] == v) continue; W[0] = 1; for(int i = 1; i &lt;= K; ++i) W[i] = W[i-1] * w % MOD; memset(h, 0, sizeof h); for(int j = 0; j &lt;= K; ++j)&#123; for(int k = 0; k &lt;= j; ++k)&#123; add(h[j], C[j][k] * f[v][k] % MOD * W[j-k] % MOD); &#125; &#125; memset(t, 0, sizeof t); for(int j = 0; j &lt;= K; ++j) &#123; t[j] = g[u][j] + f[u][j] - h[j]; t[j] = (t[j] + MOD) % MOD; &#125; for(int j = 0; j &lt;= K; ++j)&#123; for(int k = 0; k &lt;= j; ++k)&#123; add(g[v][j], C[j][k] * W[k] % MOD * t[j-k] % MOD); &#125; &#125; add(ans, g[v][K]); dfs2(v); &#125;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0);cin.tie(0); cin &gt;&gt; n &gt;&gt; K; int u, v; LL w; for(int i = 1; i &lt; n; ++i)&#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; G[u].push_back((P)&#123;v, w&#125;); G[v].push_back((P)&#123;u, w&#125;); &#125; for(int i = 0; i &lt; MAX_K; ++i) C[i][0] = C[i][i] = 1; for(int i = 2; i &lt; MAX_K; ++i)&#123; for(int j = 1; j &lt; i; ++j)&#123; C[i][j] = (C[i-1][j] + C[i-1][j-1]) % MOD; &#125; &#125; ans = 0; dfs1(1); dfs2(1); LL inv_ = inv(n); cout &lt;&lt; ans * inv_ % MOD * inv_ % MOD &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>题解(计蒜客)</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-计蒜之道-复赛A--外教-Michale-变身大熊猫(最长上升子序列+树状数组)]]></title>
    <url>%2F2019%2F08%2F10%2FACM%E9%A2%98%E7%9B%AE%2F%E9%A2%98%E8%A7%A3(%E8%AE%A1%E8%92%9C%E5%AE%A2)%2F2019-%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%93-%E5%A4%8D%E8%B5%9BA--%E5%A4%96%E6%95%99-Michale-%E5%8F%98%E8%BA%AB%E5%A4%A7%E7%86%8A%E7%8C%AB(%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%2B%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84)%2F</url>
    <content type="text"><![CDATA[ps:计蒜之道复赛2题拿T-shirt.但是我好菜啊。只拿了一题 本题要求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#pragma GCC optimize("O2") #include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x) cerr &lt;&lt; #x"=" &lt;&lt; x &lt;&lt; endl;typedef long long LL;int n;const LL MOD = 998244353;typedef pair&lt;LL, LL&gt; P;#define len first#define cnt second#define val first#define id secondconst int MAX_N = 5*1e5+100;const LL INF = 1e9;P a[MAX_N];P bit[MAX_N];int dp[MAX_N];P L[MAX_N], R[MAX_N];void upd(P &amp;a, P b)&#123; if(b.len &gt; a.len)&#123; a = b; &#125; else if(b.len == a.len)&#123; a.cnt = (a.cnt + b.cnt) % MOD; &#125;&#125;void add(int i, P p)&#123; while(i &lt;= n)&#123; upd(bit[i], p); i += i &amp; -i; &#125;&#125;P query(int i)&#123; P res; while(i)&#123; upd(res, bit[i]); i -= i &amp; -i; &#125; return res;&#125;bool cmp(P a, P b)&#123; return a.val &lt; b.val || (a.val == b.val &amp;&amp; a.id &gt; b.id);&#125;LL powN(LL base, int n)&#123; LL res = 1LL; while(n)&#123; if(n&amp;1) res = res * base % MOD; base = base * base % MOD; n &gt;&gt;= 1; &#125; return res;&#125; int main()&#123; //freopen("in.txt","r",stdin); ios::sync_with_stdio(0); cin.tie(0); scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) dp[i] = INF; for(int i = 0; i &lt; n; ++i)&#123; scanf("%lld", &amp;a[i].val); *lower_bound(dp, dp+n, a[i].val) = a[i].val; a[i].id = i+1; &#125; int mx = lower_bound(dp, dp+n, INF) - dp; sort(a, a+n, cmp); LL ans = 0; for(int i = 0; i &lt; n; ++i)&#123; P p = query(a[i].id-1); if(++p.len == 1) p.cnt = 1; // p.len表示以当前作为结尾的上升序列的最大长度.p.cnt表示有多少个这样的序列 if(p.len == mx)&#123; ans = (ans + p.cnt) % MOD; &#125; add(a[i].id, p); L[a[i].id] = p; &#125; for(int i = 1; i &lt;= n; ++i) &#123; bit[i].len = 0; bit[i].cnt = 0; &#125; for(int i = n-1; i &gt;= 0; --i)&#123; P p = query(n-a[i].id); if(++p.len == 1) p.cnt = 1; add(n+1-a[i].id, p); R[a[i].id] = p; &#125; LL q = powN(ans, MOD-2); for(int i = 1; i &lt;= n; ++i)&#123; if(L[i].len + R[i].len == mx+1)&#123; printf("%lld ", L[i].cnt * R[i].cnt % MOD * q % MOD); &#125; else printf("0 "); &#125; putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>题解(计蒜客)</category>
      </categories>
      <tags>
        <tag>最长上升子序列</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[烦躁与不安]]></title>
    <url>%2F2019%2F08%2F10%2F%E9%9A%8F%E7%AC%94%2F%E7%83%A6%E8%BA%81%E4%B8%8E%E4%B8%8D%E5%AE%89%2F</url>
    <content type="text"><![CDATA[现在是2019年8月10日的凌晨，很烦躁所以拿起电脑码字，以求缓解烦躁与不安的心情。我十分明白我在烦躁什么，但是本就柔弱的正义一方的意志不再有能力安慰虚弱的本体。虽然说不是第一次失眠，但确实是暑假以来准备认真考研的第一次失眠。很显然，最近的我学习完全提不起劲。令我烦躁的事情让我觉得我对我遇到的事情缺乏处理，产生严重的自我怀疑。虽然说从很长一段时间开始我每天就活在自我怀疑中。好像记得很清楚，上一次发生像现在这种情况是高三的时候，压力很大，所以晚上打着灯写了一些第二天自己看着觉得很傻杯的东西。可能第二天的我看着现在写的这些文字也会觉得自己很傻杯，不过现在的我觉得码字很舒服，所以也挺好的鸭。我最怕什么？最怕孤独，最怕自己菜，更怕自己怀疑自己。我觉得我有时候是一个自大的人，总是时不时的吹嘘自己，但是其实内心对自己的吹嘘并不是很赞同，只是满足一时的快感罢了。呀！我换了一种思路了，虽然看起来不是什么新奇的思路，但是听起来还是让烦躁的人有些许舒服，也算是自我安慰吧。这个思路就是：人生因为不止一种情绪而比变得精彩，再强烈的自我怀疑之后收获的成功，将是最快乐的，那时候，只想把”I did it!”印在脑门上让所有人看到。即使一直在自我怀疑中度过，我相信生命的运转不可能一成不变，它总会带来一些令人惊喜的五彩斑斓的色彩。自己安慰自己，总是能恰倒好处，现在的我仍然没有困意，但是至少烦躁减轻了许多。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>倾诉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛32]]></title>
    <url>%2F2018%2F12%2F05%2FACM%E9%A2%98%E7%9B%AE%2F%E9%A2%98%E8%A7%A3(%E7%89%9B%E5%AE%A2%E7%BD%91)%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B32%2F</url>
    <content type="text"><![CDATA[牛客练习赛32 emm.还是要及时补博客鸭.好多博客都忘记写.当时做题的思想过一段时间就忘了呀. A Phrase String AC 题目大意:构造一个01串.满足最低位和最高位是1.是回文串.长度是$max(v,k)$.v,k都是偶数.求01串转换成10进制最小. 题解:tag:贪心贪心的从中间往尽量的填1. 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;int s[100100];int v,k;typedef long long LL;const int MOD = 1e9+7;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; v &gt;&gt; k; int x = max(v, k); int f = x/2 - (k-2)/2; memset(s, 0, sizeof s); s[0] = 1; s[x-1] = 1; for(int i = f, x = 0; x &lt; (k-2); ++i, ++x)&#123; s[i] = 1; &#125; LL ans = 0; LL two = 1LL; for(int i = 0; i &lt; x; ++i)&#123; if(s[i]) ans = (ans + two) % MOD; two = two*2LL % MOD; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; B Xor Path WA 题目大意:给定一棵n个点的树，每个点有权值。定义path(i,j)表示i到j的最短路径上.所有点的点权异或和.求最后所有path(i,j)的异或和. 题解:tag:树 123 E A FB C D G H J 因为是异或.所以我们只要计算每个点参与异或了多少次.参与异或次数是奇数的话.是有贡献的.比如计算A参与异或了多少次.sz[i]表示以i为根的子树结点个数.sz[B]个结点和N-sz[A],sz[C],sz[D]个结点之间的最短路都要经过A.同理.sz[C]个结点和sz[B],sz[D],N-sz[A]个结点也要经过A.但是B-&gt;C和C-&gt;B(这里字母表示以它为根的整个子树的所有结点)重复计算了.所以应该这样计算: $$B(C+D+(N-A)) + C(D+(N-A)) + D*(N-A) + (N-1)$$ 说明一下:上面的N表示N个结点.A,B,C等字母表示以该字母为根的子树的结点个数.最后加上(N-1)是因为.A出发到其他所有结点的最短路肯定要经过A.注意叶子结点的特殊情况处理. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX_N = 5*1e5+100;vector&lt;int&gt; G[MAX_N];int A[MAX_N], sz[MAX_N];int N, ans;void dfs(int u, int fa)&#123; sz[u] = 1; // 自己 vector&lt;int&gt; vi; // 存以u为根的所有子树的结点个数.以及除去u为根的子树之外的结点个数 int len = G[u].size(); if(len == 1) vi.push_back(0); // 这个点是叶子结点.它的子树结点设置成0.为了统一下面的计算 for(int i = 0; i &lt; len; ++i)&#123; int v = G[u][i]; if(v == fa) continue; // 访问过 dfs(v, u); // 计算改孩子结点为根的子树 sz[u] += sz[v]; // 加上 vi.push_back(sz[v]); // 加入vi &#125; vi.push_back(N - sz[u]); // 除去以u为根的子树的结点个数.\sum&#123;vi_&#123;i&#125;^len1 == N-1&#125; int len1 = vi.size(); LL tmp = 0; int all = N-1; // 所有点经过u的次数 for(int i = 0; i &lt; len1; ++i)&#123; all -= vi[i]; tmp += 1LL*vi[i]*all; &#125; tmp += N-1; // 其他N-1到他的最短距离. if(tmp&amp;1) ans ^= A[u]; // 个数是奇数是有贡献的&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; N; int u,v; for(int i = 0; i &lt; N-1; ++i)&#123; cin &gt;&gt; u &gt;&gt; v; G[u].push_back(v); G[v].push_back(u); &#125; for(int i = 1; i &lt;= N; ++i) cin &gt;&gt; A[i]; ans = 0; dfs(1, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; C Balls AC 题目大意:有一个盒子，里面有一个黑球和一个白球。每次随机取出盒子中的一个球，并将两个与取出球同色的球放进盒子（就是随机一种颜色将其个数+1）。求n次取球后，盒子中白色球数目的期望。 题解:tag:数学emm.mmp.取n次之后盒子里面有n+2个球.黑白球一样期望一样.所以是$(n+2)/2$. 1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;int n;int main()&#123; //freopen("in.txt", "r", stdin); scanf("%d", &amp;n); printf("%.7f", (1.0*n+2.0)/2.0); return 0;&#125;]]></content>
      <categories>
        <category>题解(牛客网)</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>数学</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 524(Div. 2)]]></title>
    <url>%2F2018%2F11%2F25%2FACM%E9%A2%98%E7%9B%AE%2F%E9%A2%98%E8%A7%A3(codeforces)%2FCodeforces%20Round%20524(Div.%202)%2F</url>
    <content type="text"><![CDATA[Codeforces Round #524 (Div. 2) A. Petya and Origami题目大意:需要邀请n个人来参加派对.需要制作邀请卡.一张邀请卡需要2红, 5绿, 8蓝. 每个笔记本有k个某种颜色.求最少需要多少个笔记本. 题解答案显示是$ \lceil 2n/k \rceil + \lceil 5n/k \rceil + \lceil 8n/k \rceil $ 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int n,k;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n &gt;&gt; k; int x = 2*n/k; if(x * k &lt; 2*n) ++x; int y = 5*n/k; if(y * k &lt; 5*n) ++y; int z = 8*n/k; if(z * k &lt; 8*n) ++z; cout &lt;&lt; x + y + z&lt;&lt; endl; return 0;&#125; B. Margarite and the best present题目大意:有一个序列. $a_i = i*(-1)^i$. 给定l, r. 求$\sum_{i = l} ^ ra_i$. 题解将这个序列看成两个等差序列.利用等差序列求和公式即可. 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int q;int l,r;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); while(cin &gt;&gt; q)&#123; while(q--)&#123; cin &gt;&gt; l &gt;&gt; r; int len = r - l + 1; int x = len/2, y = len - x; int ans = 0, ans1, ans2; ans1 = (x-y)*(l+r)/2; ans2 = (-y*(l+r-1) + x*(l+r+1))/2; if(l&amp;1)&#123; if(r&amp;1)&#123; ans = ans1; &#125; else &#123; ans = ans2; &#125; &#125; else &#123; if(r&amp;1)&#123; ans = -ans2; &#125; else &#123; ans = -ans1; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; C. Masha and two friends题目大意: AC 一开始有一个棋盘有黑白两种颜色。一开始将区域一(x1 y1) (x2 x2)这个区域(左下角和右下角的点构成一个矩形区域)全部涂成白色。然后将区域二(x3 y3) (x4 y4)这个区域全部涂成黑色.求最后棋盘上黑白的格子各有多少. 题解计算区域一(x1 y1) (x2 y2)区域中一开始有白色格子w1 黑色格子b1计算区域二(x3 y3) (x4 y4)区域中一开始有白色格子w3 黑色格子b3计算上面两个区域相交的区域三(x5 y5) (x6 x6)区域中一开始有白色格子w2 黑色格子b2 一开始棋盘上有orw个白格子.orb个黑格子. 区域一涂成白色. orw += b1, orb -= b1 区域二和区域一二相交的地方区域三涂成黑色 2.1 获得区域二的白色 orb += w3, orw -= w3 2.2 获得相交部分的黑色 orb += b2, orw -= b2 在orb基础上增加的黑格子的数量是w3 + b2 - b1对应的.在orw基础上减少的白格子的数量是-(w3 + b2 - b1) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;LL n,m;LL bans, wans;LL x_1,y_1,x_2,y_2,x_3,y_3,x_4,y_4,x_5,y_5,x_6,y_6;LL b_1,b_2,b_3,w_1,w_2,w_3,orw,orb;int t;// 统计区间x1,y1,x2,y2之间黑白的个数void tot(LL x_1, LL y_1, LL x_2, LL y_2, LL &amp;w, LL &amp;b)&#123; LL x = x_2-x_1+1; LL y = y_2-y_1+1; LL l = (x*y)/2; w = l; b = l; if(x&amp;1 &amp;&amp; y&amp;1) &#123; if((x_1+y_1)&amp;1) &#123; // b色 ++b; &#125; else ++w; &#125;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n &gt;&gt; m; cin &gt;&gt; x_1 &gt;&gt; y_1 &gt;&gt; x_2 &gt;&gt; y_2 &gt;&gt; x_3 &gt;&gt; y_3 &gt;&gt; x_4 &gt;&gt; y_4; x_5 = max(x_1, x_3); y_5 = max(y_1, y_3); x_6 = min(x_2, x_4); y_6 = min(y_2, y_4); tot(x_1, y_1, x_2, y_2, w_1, b_1); tot(x_3, y_3, x_4, y_4, w_3, b_3); w_2 = b_2 = 0; if(x_6 &gt;= x_5 &amp;&amp; y_6 &gt;= y_5) tot(x_5, y_5, x_6, y_6, w_2, b_2); //cout &lt;&lt; "w_1=" &lt;&lt; w_1 &lt;&lt; " " &lt;&lt; b_1 &lt;&lt; endl; // cout &lt;&lt; "w_2=" &lt;&lt; w_2 &lt;&lt; " " &lt;&lt; b_2 &lt;&lt; endl; //cout &lt;&lt; "w_3=" &lt;&lt; w_3 &lt;&lt; " " &lt;&lt; b_3 &lt;&lt; endl; orb = n*m/2; orw = n*m - orb; // cout &lt;&lt; orw &lt;&lt; " " &lt;&lt; orb &lt;&lt; endl; orb += (w_3 - b_1 + b_2); orw += (b_1 - w_3 - b_2); cout &lt;&lt; orw &lt;&lt; " " &lt;&lt; orb &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解(codeforces)</category>
      </categories>
      <tags>
        <tag>cfdiv2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[河北工业大学ACM集训队日常训练day1030]]></title>
    <url>%2F2018%2F11%2F04%2FACM%E9%A2%98%E7%9B%AE%2F%E9%A2%98%E8%A7%A3(hebut%E6%A0%A1%E5%86%85)%2F%E6%B2%B3%E5%8C%97%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6ACM%E9%9B%86%E8%AE%AD%E9%98%9F%E6%97%A5%E5%B8%B8%E8%AE%AD%E7%BB%83day1030%2F</url>
    <content type="text"><![CDATA[emmm.昨天刚到青岛.今天热身赛结束.非常想记录的一点就是.这个酒店太豪了.早餐特别豪.还有浴池.orz.要加油努力赚钱买大房子呀.补了一下题.记录一下. 河北工业大学ACM集训队日常训练day1030原:Codeforces Round #490 (Div. 3) A.Mishka and Contest题目大意:easy~ 题解:easy~ 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int n, k;int a[110];int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); while(cin &gt;&gt; n &gt;&gt; k)&#123; for(int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; int ans = 0; int i; for(i = 1; i &lt;= n; ++i)&#123; if(a[i] &lt;= k) ++ans; else break; &#125; for(int j = n; j &gt; i; --j)&#123; if(a[j] &lt;= k) ++ans; else break; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; C.Alphabetic Removals题目大意:easy~ 题解:easy~ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 4*1e5+100;int n,k;char s[MAX_N];int t[26];int can[26];int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); while(cin &gt;&gt; n &gt;&gt; k)&#123; cin &gt;&gt; s; memset(t, 0, sizeof t); int len = strlen(s); for(int i = 0; i &lt; len; ++i)&#123; ++t[s[i] - 'a']; &#125; for(int i = 0; i &lt; 26; ++i) can[i] = t[i]; for(int i = 0; i &lt; 26; ++i)&#123; if(t[i] != 0) &#123; if(k - t[i] &gt;= 0) &#123; can[i] = 0; k -= t[i]; &#125; else &#123; can[i] -= k; break; &#125; &#125; &#125; for(int i = 0; i &lt; len; ++i)&#123; int cur = s[i] - 'a'; if(can[cur] &lt; t[cur]) &#123; ++can[cur]; &#125; else &#123; putchar(s[i]); &#125; &#125; putchar('\n'); &#125; return 0;&#125; E.Reachability from the Capital题目大意:有一个有向图.求最少添加几条边使得从s可以到达其他所有点. 题解:(1)dfs标记所有从s可达的点是good(2)对于每个bad的结点.统计其他同样是bad的结点可以到达它的数量.v结点计算出的值是cnt(v)(3)一次遍历非增序列cnt(v),从大到小遍历.如果它还是bad.从它dfs.标记所有可达的点是good.ans加1.相当于加了一条边(s,v) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 5*1e3+100;typedef pair&lt;int, int&gt; P;vector&lt;int&gt; G[MAX_N];vector&lt;P&gt; bad;bool has[MAX_N];bool color[MAX_N];int cnt;int n,m,s;void dfs(int u)&#123; has[u] = true; for(int i = 0; i &lt; G[u].size(); ++i)&#123; int v = G[u][i]; if(!has[v]) dfs(v); &#125;&#125;// 统计从bad的点u出发能到达的bad点void dfs2(int u)&#123; ++cnt; color[u] = true; for(int i = 0; i &lt; G[u].size(); ++i)&#123; int v = G[u][i]; if(!color[v] &amp;&amp; !has[v]) dfs2(v); &#125;&#125;int main()&#123; // freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int u,v; while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; s)&#123; memset(has, false, sizeof has); bad.clear(); for(int i = 0; i &lt;= n; ++i) G[i].clear(); for(int i = 0; i &lt; m; ++i)&#123; cin &gt;&gt; u &gt;&gt; v; G[u].push_back(v); &#125; dfs(s); for(int i = 1; i &lt;= n; ++i)&#123; if(!has[i]) &#123; cnt = 0; memset(color, false, sizeof color); dfs2(i); bad.push_back(P(cnt, i)); &#125; &#125; sort(bad.begin(), bad.end(), greater&lt;P&gt;()); int ans = 0; for(auto &amp;x: bad)&#123; int u = x.second; if(!has[u])&#123; ++ans; dfs(u); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; F.Cards and Joy题目大意:有n个人.有k*n张牌.第i张牌的权值是c_i第j个人喜欢的数字是f_j有一个等级序列.h1,h2,…,hk每个人发k张牌.如果对于第j个人.他分到的牌的权值是他喜欢的数字f_j的牌的数量是t.他的等级就是h[t].注意h[0] = 0.求一种方案.使得n个人的等级和最大输出最大的等级和. 题解:如果喜欢某个数字的人数是x.这个数字的卡牌有y个.也就是这y张卡牌怎么分给这x个人使得等级之和最大.可以看出.和数字本身是几没有关系.只和x,y有关系.dp[x][y] ::= 喜欢某个数字的人数是x(0 &lt;= x &lt;= n),是这个数字的卡牌有y(0 &lt;= y &lt;= k*n)张时候最优的方案得到等级和最大.如果我们求出了dp[x][y].$ans = \sum_{i = 1}^{1e5} dp[f[i]][c[i]]$ 容易知道dp[0][y] = dp[x][0] = 0.状态转移方程:$dp[x][y] = \max dp[x-1][y-i] + h[i], 0 &lt;= i &lt;= k$解释一下:就是有x个人y张牌的时候的最大值.是安排第x个人i张喜欢的牌.加上剩下x-1个人安排y-i张牌.类似背包时间复杂度$O(n^2*k^2)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;// http://codeforces.com/problemset/problem/999/Ftypedef long long LL;const int MAX_N = 1e5+10;int f[MAX_N], c[MAX_N];int dp[510][5100];int h[15];int n,k;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int x; cin &gt;&gt; n &gt;&gt; k; memset(c, 0, sizeof c); memset(f, 0, sizeof f); memset(dp, 0, sizeof dp); for(int i = 0; i &lt; n*k; ++i) &#123; cin &gt;&gt; x; ++c[x]; &#125; for(int i = 0;i &lt; n; ++i)&#123; cin &gt;&gt; x; ++f[x]; &#125; h[0] = 0; for(int i = 1; i &lt;= k; ++i)&#123; cin &gt;&gt; h[i]; &#125; for(int i = 1; i &lt;= n; ++i)&#123; for(int j = 1; j &lt;= n*k; ++j)&#123; for(int l = 0; l &lt;= min(j, k); ++l)&#123; dp[i][j] = max(dp[i][j], dp[i-1][j-l] + h[l]); &#125; &#125; &#125; LL ans = 0; for(int i = 0; i &lt; MAX_N; ++i)&#123; if(f[i] != 0) ans += dp[f[i]][c[i]]; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>题解(hebut校内)</category>
      </categories>
      <tags>
        <tag>校内选拔赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[河北工业大学ACM选拔赛10月末]]></title>
    <url>%2F2018%2F10%2F28%2FACM%E9%A2%98%E7%9B%AE%2F%E9%A2%98%E8%A7%A3(hebut%E6%A0%A1%E5%86%85)%2F%E6%B2%B3%E5%8C%97%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6ACM%E9%80%89%E6%8B%94%E8%B5%9B10%E6%9C%88%E6%9C%AB%2F</url>
    <content type="text"><![CDATA[河北工业大学ACM选拔赛 emmm.我校ACM集训队喜提实验室orz. C.强迫症题目大意:给树染色.相邻结点的颜色不同.求最后的颜色.后面的颜色会覆盖前面的.没有染色成功的输出0 题解由于是一棵树,一个树结点和他相邻的结点就是以这个结点作为根的直接孩子还有他的父亲.所以考虑先把无根树转换成有根树.这样就得到了每个结点的直接孩子.每个结点维护一个多重集合.里面存它的所有直接孩子的颜色.所以我们可以以$O(1)$的复杂度得到他的父亲的颜色.以$O(logN)$的复杂度得到他的孩子里面任意一个颜色.对于每个结点$x$.想要将$x$染成$y$.如果$x$的父亲$fa[x]$的颜色是$y$.或者$x$的孩子结点中有颜色是$y$的点.那么这个点我们不能染.否则.如果这个点曾经染过别的颜色.现在要更新.需要维护父亲$fa[x]$的多重集合.先删除$x$之前的颜色.再插入新的颜色.所以.总的复杂度大概是$O(MlogN)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 1e5+100;int N,M;int fa[MAX_N];vector&lt;int&gt; G[MAX_N];multiset&lt;int&gt; S[MAX_N];int color[MAX_N];void dfs(int u, int f)&#123; fa[u] = f; for(int i = 0; i &lt; G[u].size(); ++i)&#123; int v = G[u][i]; if(v != f) dfs(v, u); &#125;&#125;int main()&#123; //freopen("in.txt", "r", stdin); int u,v; int x,y; while(~scanf("%d%d", &amp;N, &amp;M))&#123; for(int i = 0;i &lt;= N; ++i) &#123; G[i].clear(); S[i].clear(); &#125; memset(color, 0, sizeof color); for(int i = 0;i &lt; N-1; ++i)&#123; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1, 0); for(int i = 0;i &lt; M; ++i)&#123; scanf("%d%d", &amp;x, &amp;y); // 判断 if(color[fa[x]] == y || S[x].find(y) != S[x].end()) continue; // 维护父亲 if(color[x]) S[fa[x]].erase(S[fa[x]].find(color[x])); S[fa[x]].insert(y); color[x] = y; &#125; for(int i = 1;i &lt;= N; ++i)&#123; printf("%d\n", color[i]); &#125; &#125; return 0;&#125; F.选举题目大意n个人,m个城市.第i行j列代表第i个城市给第j的编号的人投出的票数.第一轮.每个城市胜出且编号小的贡献加一.第二轮每个人贡献最大且编号最小的是最终的答案.输出每组样例胜出的人的编号. 题解题目大意就是题解.一场cf的div 2的A 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;// Elections#define MAX_N 105int n,m;int sum[MAX_N];int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int x; while(cin &gt;&gt; n &gt;&gt; m)&#123; // n个候选人. m个城市 memset(sum, 0, sizeof(sum)); for(int i = 1; i &lt;= m; ++i)&#123; int idx = 1, maxx = 0; for(int j = 1; j &lt;= n; ++j)&#123; cin &gt;&gt; x; if(maxx &lt; x)&#123; idx = j; maxx = x; &#125; &#125; ++sum[idx]; &#125; int ansidx = 1; int maxx = sum[1]; for(int i = 2; i &lt;= n; ++i)&#123; if(maxx &lt; sum[i])&#123; maxx = sum[i]; ansidx = i; &#125; &#125; cout &lt;&lt; ansidx &lt;&lt; endl; &#125; return 0;&#125; G.信号与系统题目大意 题解emm.大概就是看图按照这个意思理解.一道cf div2的C题. 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define MAX_N 55char s[MAX_N];// emm.这个函数有一个隐藏特性.就是如果参数c不是26个字母的话.返回c的ASCII值int idx(char c)&#123; if(c &gt;= 'A' &amp;&amp; c &lt;= 'Z') return c - 'A' +1; if(c &gt;= 'a' &amp;&amp; c &lt;= 'z') return c - 'a' +1;&#125;int main()&#123; //freopen("in.txt", "r", stdin); while(~scanf("%s", s))&#123; char a[5] = "@[`&#123;"; LL res = 0; for(int i = 0; s[i]; ++i)&#123; char b = s[i]; int f1 = (a[0] &lt; b) &amp; (a[1] &gt; b); int f2 = (a[2] &lt; b) &amp; (a[3] &gt; b); res += (f1 * idx(b) - f2 * idx(b)); &#125; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; H.大数GCD题目大意$1 &lt;= a &lt;= b &lt;= 10^{100}$. 求$gcd(a, a+1, a+2, …, b)$. 题解emmm.看题目被大数GCD吓一跳.想用大数写一个欧几里得.细读的话会发现.当$a &lt;= b$的时候$gcd(a,a+1,a+1,…b) = gcd(gcd(a,a+1),a+2,..,d) = gcd(1,a+2,..,d) = 1$.当$a==b$的时候.两个相等的数的最大公约数就是$a$.一道cf的div2A 1234567891011121314#include &lt;bits/stdc++.h&gt;// 1966: Complicated GCDusing namespace std;int main() &#123; //freopen("in.txt", "r", stdin); string a, b; cin &gt;&gt; a &gt;&gt; b; if (a == b) cout &lt;&lt; a; else cout &lt;&lt; 1; return 0;&#125; I 计算之神 代码里面注释的是原题链接.这道题是当时暑假参加ccpc-wannafly的时候做的题.当时没有做出来.orz.后面牛客重现赛的时候做出来的. 题目大意$$ f(l, r) = (\sum_{i=l}^r{a_i})*w_{r-l+1} $$求解:$$ \sum_{l=1}^r{\sum_{r=l}^n{f(l, r)}} $$ 题解两个式子看起来很复杂.无脑暴力一定超时.emmm.具体计算下次再更新.大概就是去掉重复的计算.上代码.orz. 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std; /*https://www.nowcoder.com/acm/contest/204/G*/const int MAX_N = 3*1e5+100;typedef long long LL;const LL MOD = 1e9+7;int n;LL a[MAX_N], w[MAX_N], sum[MAX_N]; inline LL getSum(int l, int r)&#123; return (sum[r] - sum[l-1]) % MOD;&#125; int main()&#123; // freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n; memset(sum, 0, sizeof(sum)); for(int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; sum[i] = (sum[i-1] + a[i]) % MOD; &#125; for(int i = 1; i &lt;= n; ++i) cin &gt;&gt; w[i]; LL ans = 0LL, x = 0LL; for(int i = 1; i &lt;= n &gt;&gt; 1; ++i)&#123; x = (x + getSum(i, n-i+1)) % MOD; ans += (((w[i] + w[n-i+1]) % MOD) * (x % MOD)) % MOD; &#125; if(n &amp; 1) &#123; int i = (n &gt;&gt; 1) + 1; ans += w[i] * (x + a[i]) % MOD; &#125; cout &lt;&lt; ans% MOD &lt;&lt; endl; return 0;&#125; J.莱昂哈德·欧拉 emm.这道题出自牛客的一场小白月赛.记得那次出题人背B题的锅.被骂得很严重 题目大意求$[l,r]$之间有约束的数字的个数. 题解裸数位dp.emmm.后面细更 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;// https://www.nowcoder.com/acm/contest/214/Etypedef long long LL;const LL MOD = 20020219;const int INF = 63;#define MAX_N 25LL f[MAX_N][11][INF+1];int t;LL l,r;int n;int lim[11],x,len;int num[MAX_N];LL dfs(int pos, bool limit, int pre, int cnt)&#123; if(cnt &gt; lim[pre]) return 0; if(pos == 0) return 1; if(!limit &amp;&amp; f[pos][pre][cnt] != -1) return f[pos][pre][cnt]; // 计算过了 int up = limit ? num[pos] : 9; LL tmp = 0; for(int i = 0;i &lt;= up; ++i)&#123; tmp = (tmp + dfs(pos-1, limit &amp;&amp; num[pos] == i, i, i == pre ? cnt+1 : 1) + MOD) % MOD; &#125; return limit ? tmp : f[pos][pre][cnt] = tmp % MOD;&#125;LL solve(LL x)&#123; if(x == -1) return 0; int pos = 0; while(x)&#123; num[++pos] = int(x%10); x /= 10; &#125; // pre初始值是0.orz.就过了.因为对0没有限制.不能设置成-1.因为数组下标没有-1 return dfs(pos, true, 0, 1) % MOD;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; n; for(int i = 0;i &lt; 10; ++i) lim[i] = INF; for(int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; x &gt;&gt; len; lim[x] = min(lim[x], len); &#125; memset(f, -1, sizeof f); cout &lt;&lt; (solve(r) - solve(l-1) + MOD) % MOD &lt;&lt; endl; &#125; return 0;&#125; L 超市活动题目大意在$n*m$的格子中取数满足取得数字格子之间没有公共边.求取出数字的最大和. 题解n和m比较小.网络流.emmm.后面细更.这道题目的代码我没动手.拿的别人的代码.昨天晚上突然很怕今天有人AK。所以加上了这道题目. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 50*50;const int INFS = 0x7FFFFFFF;struct edge &#123; int from, to, cap, flow; edge(int _from, int _to, int _cap, int _flow) : from(_from), to(_to), cap(_cap), flow(_flow) &#123;&#125;&#125;;class Dinic &#123;public: void initdata(int n, int s, int t) &#123; this-&gt;n = n, this-&gt;s = s, this-&gt;t = t; edges.clear(); for (int i = 0; i &lt; n; i++) G[i].clear(); &#125; void addedge(int u, int v, int cap) &#123; edges.push_back(edge(u, v, cap, 0)); edges.push_back(edge(v, u, 0, 0)); G[u].push_back(edges.size() - 2); G[v].push_back(edges.size() - 1); &#125; bool BFS() &#123; for (int i = 0; i &lt; n; i++) vis[i] = false, d[i] = 0; queue&lt;int&gt; Q; Q.push(s); vis[s] = true; while (!Q.empty()) &#123; int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); i++) &#123; edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; !vis[e.to]) &#123; vis[e.to] = true; d[e.to] = d[x] + 1; Q.push(e.to); &#125; &#125; &#125; return vis[t]; &#125; int DFS(int x, int aug) &#123; if (x == t || aug == 0) return aug; int flow = 0; for (int i = 0; i &lt; G[x].size(); i++) &#123; edge&amp; e = edges[G[x][i]]; if (d[e.to] == d[x] + 1) &#123; int f = DFS(e.to, min(aug, e.cap - e.flow)); if (f &lt;= 0) continue; e.flow += f; edges[G[x][i]^1].flow -= f; flow += f; aug -= f; if (aug == 0) break; &#125; &#125; return flow; &#125; int maxflow() &#123; int flow = 0; while (BFS()) &#123; flow += DFS(s, INFS); &#125; return flow; &#125;private: vector&lt;edge&gt; edges; vector&lt;int&gt; G[MAXN]; int n, s, t, d[MAXN]; bool vis[MAXN];&#125;;Dinic dc;int row, col;int dir[4][2] = &#123;1, 0, -1, 0, 0, 1, 0, -1&#125;;bool check(int x, int y) &#123; if (1 &lt;= x &amp;&amp; x &lt;= row &amp;&amp; 1 &lt;= y &amp;&amp; y &lt;= col) &#123; return true; &#125; return false;&#125;int main() &#123; //freopen("in.txt", "r", stdin); scanf("%d%d", &amp;row, &amp;col); int sum = 0; int s = 0, t = row*col + 1; dc.initdata(t + 1, s, t); for (int i = 1; i &lt;= row; i++) &#123; for (int j = 1; j &lt;= col; j++) &#123; int a; scanf("%d", &amp;a); sum += a; if ((i+j) &amp; 1) dc.addedge((i-1)*col+j, t, a); else &#123; dc.addedge(s, (i-1)*col+j, a); for (int k = 0; k &lt; 4; k++) &#123; int x = i + dir[k][0]; int y = j + dir[k][1]; if (check(x, y)) dc.addedge((i-1)*col+j, (x-1)*col+y, INFS); &#125; &#125; &#125; &#125; printf("%d\n", sum - dc.maxflow()); return 0;&#125;]]></content>
      <categories>
        <category>题解(hebut校内)</category>
      </categories>
      <tags>
        <tag>校内选拔赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wannafly挑战赛27]]></title>
    <url>%2F2018%2F10%2F27%2FACM%E9%A2%98%E7%9B%AE%2F%E9%A2%98%E8%A7%A3(%E7%89%9B%E5%AE%A2%E7%BD%91)%2FWannafly%E6%8C%91%E6%88%98%E8%B5%9B27%2F</url>
    <content type="text"><![CDATA[Wannafly挑战赛27 emm.题目说得很明白 A 灰魔法师 AC 题目大意:给出长度为n的序列a, 求有多少对数对 (i, j) (1 &lt;= i &lt; j &lt;= n) 满足 ai + aj 为完全平方数。 题解先找出1到21e5之间所有的完全平方数.有400多个.然后二分计算答案.注意long long.注意$a_i$可能重复.注意计算答案的时候需要分开计算的地方.一个神奇的事情.以为int转成long long.只要一个int数1LL就行了.后面发现是1LL*int.还有一个就是昨天发现的一个神奇的地方.默认返回了ASCII码值.活久见.1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int fun(char c)&#123;&#125;int main()&#123; // freopen("in.txt", "r", stdin); cout &lt;&lt; fun('a') &lt;&lt; endl; cout &lt;&lt; fun('b') &lt;&lt; endl; return 0;&#125; 输出:9798 回到正题.正经代码.复杂度$O((400+)*nlogn)$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std; typedef long long LL;const int MAX_N = 1e5;int n;vector&lt;int&gt; a;vector&lt;int&gt; num;LL len[MAX_N]; void init()&#123; for(int i = 1;i &lt;= 2*MAX_N; ++i)&#123; int x = sqrt(i); if(x*x == i) num.push_back(i); &#125;&#125; int main()&#123; // freopen("in.txt", "r", stdin); init(); int x; while(cin &gt;&gt; n)&#123; memset(len, 0, sizeof len); a.clear(); for(int i = 0; i &lt; n; ++i)&#123; cin &gt;&gt; x; ++len[x]; if(len[x] == 1) a.push_back(x); &#125; sort(a.begin(), a.end()); int sz = a.size(); LL res = 0; LL ans = 0; for(int i = 0; i &lt; num.size(); ++i)&#123; int v = num[i]; for(int j = 0; j &lt; sz; ++j)&#123; if(a[j] &gt; v) continue; vector&lt;int&gt;::iterator idx = lower_bound(a.begin(), a.end(), v - a[j]); if(idx != a.end()) &#123; if(*idx == v - a[j]) &#123; int x = a[j], y = v-a[j]; if(x == y) ans += len[x] * (len[x]-1) / 2LL; else res += len[x] * len[y]; &#125; &#125; &#125; &#125; cout &lt;&lt; res/2LL + ans &lt;&lt; endl; &#125; return 0;&#125; B 紫魔法师 AC 题目大意给一个图(每条边最多被包含于一个环，无自环，无重边，保证连通)，要求用最少的颜色对其顶点染色，满足每条边两个端点的颜色不同，输出最小颜色数即可 题解如果$n==1$.一种颜色.如果是二分图.$2$种颜色.否则.就是有奇数环.就需要$3$种颜色.所以.二分染色即可.emmm.第一次二分染色写错.orz. 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 1e5+100;int color[MAX_N];vector&lt;int&gt; G[MAX_N];int n,m;bool dfs(int u, int c)&#123; color[u] = c; int sz = G[u].size(); for(int i = 0; i &lt; sz; ++i)&#123; int v = G[u][i]; if(!color[v]) &#123; if(!dfs(v, 3-c)) return false; &#125; if(color[v] == color[u]) return false; &#125; return true;&#125;int main()&#123; //freopen("in.txt", "r", stdin); int u,v; while(cin &gt;&gt; n &gt;&gt; m)&#123; for(int i = 1; i &lt;= n; ++i) G[i].clear(); memset(color, 0 ,sizeof color); for(int i = 1; i &lt;= m; ++i)&#123; cin &gt;&gt; u &gt;&gt; v; G[u].push_back(v); G[v].push_back(u); &#125; if(n == 1) &#123;puts("1"); continue;&#125; if(dfs(1, 1)) puts("2"); else puts("3"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解(牛客网)</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-#569-(Div--2)-C--Valeriy-and-Deque(双端队列+循环节)]]></title>
    <url>%2F2018%2F10%2F19%2FACM%E9%A2%98%E7%9B%AE%2F%E9%A2%98%E8%A7%A3(codeforces)%2FCodeforces-Round-%23569-(Div--2)-C--Valeriy-and-Deque(%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%2B%E5%BE%AA%E7%8E%AF%E8%8A%82)%2F</url>
    <content type="text"><![CDATA[ps:没看别人写的。刚刚自己写1A.昨晚刚看了这个题目感觉就会做啊但是想到B题也会做。最后还有50min的时候想用20分钟写这个.然后写了写想到B题自己也会。不如继续B题,马上解决了再来搞C.没想到最后栽在了B题。导致最后B,C都没有搞出来。血亏掉分. 这是一个双端队列的操作容易看出题目描述的操作在第一个最大值达到队首的时候的状态假设此时的时刻是t.容易知道t &lt;= n.我们保存1..t-1次的答案在v中,假设t时刻队列的情况是a1 a2 a3 a4 … an.容易知道接下来的操作总是最大的那个在对首.然后后面的一直循环往复.假设此时a1 &gt;= max{ai, (2 &lt;= i &lt;= n)}:a1 a2 a3 a4 .. an如果a1 = a2.按照题目要求.我们需要把a2放在队首.把a1放在队尾.但是由于a1=a2.将a1放在对首.将a2放在队尾等价。所以题目所描述的操作.等价于.a1 &gt;= ai将a1放在队首.ai放在对尾部.所以会出现下面的局面.时刻 序列t a1 a2 a3 a4 .. ant+1 a1 a3 a4 .. an a2t+2 a1 a4 .. an a2 a3t+3 a1 .. an a2 a3 a4t+n-2 a1 an a2 a3… an-1 t+n-1 a1 a2 a3 a4 .. an….. 所以接下来就是以n-1作为循环长度的序列. 那么对于询问m.如果m &lt;= t-1.那么答案就在v中取即可.m &gt; t-1. m -= (t-1).a2 a3 a4 .. an1 2 3 .. n-1m % (n-1).如果m=0.输出a1 和 an否则.输出a1 和 m+1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#pragma GCC optimize("O2") #include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x) cerr &lt;&lt; #x"=" &lt;&lt; x &lt;&lt; endl;typedef long long LL;const int MAX_N = 1e5+100;int que[4*MAX_N];int n,q;LL m;int a[MAX_N];int main()&#123; //freopen("in.txt","r",stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n &gt;&gt; q; int s = 0, t = 0; int mx = 0; for(int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; a[i]; mx = max(mx, a[i]); que[t++] = a[i]; &#125; vector&lt;pair&lt;int, int&gt; &gt; v; int tim = 1; // 一开始是1时刻 while(que[s] != mx)&#123; int A = que[s++]; int B = que[s++]; v.push_back(make_pair(A, B)); if(A &gt; B)&#123; que[--s] = A; que[t++] = B; &#125; else &#123; que[--s] = B; que[t++] = A; &#125; ++tim; &#125; int idx = 0; for(int i = s; i &lt; t; ++i)&#123; a[++idx] = que[i]; &#125; while(q--)&#123; cin &gt;&gt; m; if(m &lt;= tim-1)&#123; if(m-1 &lt; v.size()) &#123; cout &lt;&lt; v[m-1].first &lt;&lt; " " &lt;&lt; v[m-1].second &lt;&lt; endl; &#125; &#125; else &#123; m -= (tim-1); m %= (n-1); if(m == 0) cout &lt;&lt; a[1] &lt;&lt; " " &lt;&lt; a[n] &lt;&lt; endl; else cout &lt;&lt; a[1] &lt;&lt; " " &lt;&lt; a[m+1] &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解(codeforces)</category>
      </categories>
      <tags>
        <tag>双端队列，循环节</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-#569-(Div--2)-B--Nick-and-Array(贪心)]]></title>
    <url>%2F2018%2F10%2F19%2FACM%E9%A2%98%E7%9B%AE%2F%E9%A2%98%E8%A7%A3(codeforces)%2FCodeforces-Round-%23569-(Div--2)-B--Nick-and-Array(%E8%B4%AA%E5%BF%83)%2F</url>
    <content type="text"><![CDATA[ps:关于本题,昨晚熬夜到1:05打cf想涨分结果脑袋抽了,一直B题wa9.mmp.没有想到0可以变成-1.没有想到修改绝对值最大的那个负数rating掉到1340.mmp 首先正的变成负的。在绝对值上会增加1.所以先把正的变成负的是奇数的情况下.全部是负的.将谁修改成正的.修改成正的绝对值要减1.看下面的情况:$-2, -3, -4$修改-2$1 -3 -4 = 12$修改-3$-2 -3 3 = 18$表面上看是修改最小的那个,也就是绝对值最大的那个为正的假设数字按照绝对值递增排列，按照大小从大到小排序.$a_i &lt; 0$$a_1, a_2, a_3, a_4, a_5 …a_i…a_n$证明修改an要优于修改$a_i(i \neq n). a_n &lt;= a_i. |a_n| &gt;= |a_i|$记除去$a_i$和$a_n$的数字之间相乘的结果是$C. C &lt; 0$修改$a_i$.$a_i = -a_i-1. ans1 = C(-a_i-1)a_n = -Ca_na_i -Ca_n$修改$an$. $a_n = -a_n-1. ans2 = C(-an-1)ai = -Canai -Cai$容易知道$-Ca_n &lt; 0, -Ca_i &lt; 0, -Ca_na_i &gt; 0. $并且$-Ca_n &lt;= -Ca_i$所以$ans1 &lt;= ans2.$所以修改$a_n$最优 1234567891011121314151617181920212223242526272829303132333435#pragma GCC optimize("O2") #include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x) cerr &lt;&lt; #x"=" &lt;&lt; x &lt;&lt; endl;typedef long long LL;const int MAX_N = 1e5+100;int a[MAX_N];int main()&#123;// freopen("in.txt","r",stdin); ios::sync_with_stdio(0); cin.tie(0); int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; a[i]; if(a[i] &gt;= 0) a[i] = -a[i]-1; &#125; if(n&amp;1)&#123; int mn = -1; int id = 0; for(int i = 1; i &lt;= n; ++i)&#123; if(mn &gt;= a[i])&#123; mn = a[i]; id = i; &#125; &#125; a[id] = -a[id]-1; &#125; for(int i = 1; i &lt;= n; ++i)&#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>题解(codeforces)</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hebuter Daily Training 201810]]></title>
    <url>%2F2018%2F10%2F19%2FACM%E9%A2%98%E7%9B%AE%2F%E9%A2%98%E8%A7%A3(hebut%E6%A0%A1%E5%86%85)%2FHebuter%20Daily%20Training%20201810%2F</url>
    <content type="text"><![CDATA[emmm.daily trainning第一天. 题目原题是cf上的Codeforces Beta Round #9 (Div. 2 Only) A Die Roll题目大意:有三个人Y,W,D.每个人都很想去一个地方.但是不好请假.所以能去一个地方就很好了.Y想出来一个方法.每个人掷骰子.点数最多的赢.就可以去他想去的地方.Y,W已经投掷了.求D获胜的概率.输出.0/1表示不可能获胜1/1表示一定获胜. 题解:根据题意的Note可知.假设$a = \max(Y, W);如果D &gt;= a$.是$D$获胜.所以只要求$(6-(a-1))/6$.分子分母约分.假设$x = 6 - a + 1. y = 6. z = gcd(x, y);ans = (x/z)/(y/z). $可以知道不可能有$0/1$的情况 `12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int Y,W; cin &gt;&gt; Y &gt;&gt; W; int a = max(Y, W); int x = 6 - a + 1, y = 6, z = __gcd(x, y); cout &lt;&lt; x/z &lt;&lt; "/" &lt;&lt; y/z &lt;&lt; endl; return 0;&#125; B Interestring graph and Apples.题目大意:一个无向图被称作interesting.当且仅当它的顶点只属于一个funny ring.funny ring的定义就是一个环可以遍历所有顶点只有一次.一个圈也是一个funny ring.最少添加多少条边使得当前图成为interesting.输出字典序最小的添加顺序. 题解:可以肯定的是interesting graph就是一个funny ring.它有n个顶点n条边.因为n个顶点n-1条边是树.多一条边就有一个环.如果再多一条边就是多余两个环了.不满足定义. 一个图是一个funny ring当且仅当满足下面两个条件A1. 每个点的度数是2.A2. 图是连通的 现在我们找到当一个图不是funny ring.但是通过添加边.可以转换成funny ringB1. m &lt; n. 边的数量少于点的数量.B2. 没有环B3. 每个点的度数都不超过2 我们需要添加一些边使得这些条件都满足.并且这个添加序列是字典序最小的.所以我们按照如下规则添加边(i,j). i,j两个点的度数都小于2.(打破条件B3) i,j属于两个不同的连通分量(打破条件B2) (i,j)字典序最小 我们什么时候不能再添加边.当没有环的时候.每个连通分量是一颗树.因此至少有一个点的度数小于2(根).如果有两个连通分量.连接的话就可以打破条件B1-B3所以图连通,没有环,每个点的度数不超过2.意味着获得的图知识一条链.我们可以连接它的结束的点获得一个funny ring. 通过上面的描述.算法: 检查是否满足条件A1,A2.如果满足.输出”YES” 和 0 检查是否满足B1.B2.不满足.输出”NO” 输出”YES” 和 n-m.(加入n-m条边) 按照描述添加边i,j.当(i,j)添加成功.输出”i j” 找到点i,j度数不超过2(i和j可以相等.如果n = 1). 输出 “i j” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 55int n,m;int fa[MAX_N];int in[MAX_N];vector&lt;int&gt; G[MAX_N];bool has[MAX_N];struct P&#123; int u,v;&#125;;void init()&#123;for(int i = 0; i &lt; n; ++i) fa[i] = i;&#125;int findd(int x) &#123;return x == fa[x] ? x : fa[x] = findd(fa[x]);&#125;void unite(int x, int y) &#123;x = findd(x); y = findd(y); fa[x] = y;&#125;bool same(int x, int y) &#123;return findd(x) == findd(y);&#125;bool dfs(int u, int fa)&#123; int sz = G[u].size(); has[u] = true; for(int i = 0; i &lt; sz; ++i)&#123; int v = G[u][i]; if(v == fa) continue; if(has[v] || dfs(v, u)) return true; &#125; return false;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int u,v; while(cin &gt;&gt; n &gt;&gt; m)&#123; init(); memset(has, false, sizeof(has)); memset(in, 0, sizeof(in)); for(int i = 0; i &lt; n; ++i) G[i].clear(); for(int i = 0; i &lt; m; ++i)&#123; cin &gt;&gt; u &gt;&gt; v; ++in[--u]; ++in[--v]; unite(u, v); G[u].push_back(v); G[v].push_back(u); &#125; bool flag = false; bool two = true; // 是不是都是2 int i; for(i = 0; i &lt; n; ++i) &#123; two &amp;= (in[i] == 2 &amp;&amp; same(0, i)); if(in[i] &gt; 2) &#123;flag = true; break;&#125; &#125; if(two)&#123; // 满足所有点在一个联通快并且是一个环 puts("YES\n0"); continue; &#125; if(flag || m &gt;= n) &#123;puts("NO"); continue;&#125; // 判断是不是有环 for(int i = 0; i &lt; n; ++i)&#123; if(!has[i]) &#123; if(dfs(i, -1)) &#123;flag = true; break;&#125; &#125; &#125; if(flag) &#123;puts("NO"); continue;&#125; puts("YES"); printf("%d\n", n - m); vector&lt;P&gt; vp; for(int i = 0; i &lt; n; ++i)&#123; if(in[i] &gt;= 2) continue; for(int j = 0; j &lt; i; ++j)&#123; if(in[j] &lt; 2 &amp;&amp; !same(i, j)) &#123; unite(i, j); // 连接i,j ++in[i]; ++in[j]; vp.push_back((P)&#123;i, j&#125;); &#125; &#125; &#125; // 最后都在一个联通块.只剩下两个或者一个度数&lt;2的 u = v = -1; for(int i = 0; i &lt; n; ++i)&#123; if(in[i] &lt; 2) &#123; if(u == -1) u = i; else &#123;v = i; break;&#125; &#125; &#125; // 只有一个结点的时候 if(v == -1) v = u; vp.push_back((P)&#123;u, v&#125;); for(int i = 0; i &lt; n-m; ++i)&#123; if(vp[i].u &gt; vp[i].v) swap(vp[i].u, vp[i].v); printf("%d %d\n", vp[i].u+1, vp[i].v+1); &#125; &#125; return 0;&#125; emmm.第二天. C.三角形题目大意:在$n*m$边长的网格中选择三个点可以组成的三角形个数。 题解$n*m$边长的网格有 $(n+1)(m+1)$ 个点 我们要选择三个来组成三角形. 方案数就是$total=C_{(n+1)(m+1)}^3$. 但是这是所有情况.有些三个点是共线的.所以我们只要找出三个点共线的方案数$other$. 答案$ans=total-other$ 在属于$other$的有下面三种情况: 横着的线有$m+1$条(横轴是$n$.纵轴是$m$).$other_1=(m+1)C_{n+1}^3$ 竖着的先有$n+1$条.$other_2=(n+1)C_{m+1}^3$ 斜着的.有斜率是正的斜着的.也有斜率是负的.但是我们只要算出斜率是正的.乘$2$即可. 解释一下第三种情况的计算： 斜线可以画一画图. 我们以$(0,0)$ 到 $(x,y)$ 的线$l_1$作为标准.$l_1$这样的线有$(n+1-x)(m+1-y)$条. (emmm.这里也可以画一画). 这条线上的点是格点的有$x=gcd(x,y)-1$个 (emmm.这个结论详见《挑战程序设计竞赛》2.6章:数学问题的解题窍门). 所以只要$x&gt;=1$.那么两端的点就可以和这$x$个点中任意一个组成一种方案. $l1$这种线的方案数就是$2x(n+1-x)(m+1-y)$ 所有$1&lt;=x&lt;=n.1&lt;=y&lt;=m$计算出来$other_3$. 最后$ans=total-(other_1+other_2+other_3)$. 时间复杂度$O(n*m)$ emm.顺便提一下.注意结果溢出.orz 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;LL n, m;LL C3(LL n) &#123; return n*(n-1)*(n-2)*1LL/6LL;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n &gt;&gt; m; ++n; ++m; LL ans = C3(n*m) - m*C3(n) - n*C3(m); for(int i = 1; i &lt; n; ++i)&#123; for(int j = 1; j &lt; m; ++j)&#123; int x = __gcd(i, j) - 1; // (0, 0) 到 (i, j)中格子数目.不包含两端 if(x &gt;= 1) &#123; // 多于一个 ans -= (n - i) * (m - j) * x * 2LL; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>题解(hebut校内)</category>
      </categories>
      <tags>
        <tag>校内选拔赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约数之和]]></title>
    <url>%2F2018%2F10%2F19%2F%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%2F97.%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[约数之和题目描述假设现在有两个自然数A和B，S是$A^B$的所有约数之和。 请你求出S mod 9901的值是多少。 输入格式在一行中输入用空格隔开的两个整数A和B。 输出格式输出一个整数，代表S mod 9901的值。 数据范围$0≤A,B≤5×10^7$ 输入样例：12 3 输出样例：115 注意: A和B不会同时为0。 题解考虑将$A$进行质因数分解. $A = \prod_{i = 1} ^ {n} p_i ^ {a_i} = p_1 ^ {a_1} p_2 ^ {a_2} p_3 ^ {a_3} … p_n ^ {a_n}$ 那么 $A^B = \prod_{i = 1} ^ {n} p_i ^ {a_i B} = p_1 ^ {a_1 B} p_2 ^ {a_2 B} p_3 ^ {a_3 B} … p_n ^ {a_n * B}$ $S$定义为$A^B$的约数和，那么 $S = \prod_{i = 1}^n \sum_{j=0}^{a_i*B} p_i^j $ $S= (p_1^0+p_1^1+…+p_1^{a_1B})(p_2^0+p_2^1+…+p_2^{a_2B})…(p_n^0+p_n^1+…+p_n^{a_nB})$ 式子看似复杂，简单的讲就是相当于在式子中的每一个因子项。也就是每一个括号里面取一个。然后取得$n$相乘起来就得到了一个$A^B$的约数。 现在我们的问题就是求:$\sum_{j=0}^{a_i*B}p_i^j$ 容易看出。这是一个等比数列前n项和。省赛就做过一个这个玩意儿。当时想复杂了。想成用等比数列前$n$项和公式，但是当时它那个题目的模数是输入，也就是模数可能是合数。这题中模数确定是9901。是一个素数。可以考虑使用等比数列求和公式。当然，可以使用分治， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x) cerr &lt;&lt; #x"=" &lt;&lt; x &lt;&lt; endl;typedef long long LL;#define p first#define a secondconst int MOD = 9901;LL powN(LL a, LL n)&#123; LL res = 1LL; while(n)&#123; if(n&amp;1) res = res * a % MOD; a = a * a % MOD; n &gt;&gt;= 1; &#125; return res;&#125;// 计算p^0+p^1+...+p^aLL cal(LL p, LL a)&#123; if(a == 0) &#123; return 1; &#125; int h = a &gt;&gt; 1; if(!(a&amp;1))&#123; --h; &#125; LL ans = cal(p, h); LL ah = powN(p, h+1); ans = (ans + ah * ans % MOD) % MOD; if(!(a&amp;1))&#123; ans = (ans + powN(p, a)) % MOD; &#125; return ans;&#125;int main()&#123; //freopen("in.txt", "r", stdin); LL A,B; cin &gt;&gt; A &gt;&gt; B; if(A == 0 || A == 1)&#123; cout &lt;&lt; A &lt;&lt; endl; return 0; &#125; map&lt;LL, LL&gt; mp; for(LL i = 2; i*i &lt;= A; ++i)&#123; while(A%i == 0)&#123; mp[i]++; A /= i; &#125; &#125; if(A &gt; 1) mp[A]++; LL ans = 1LL; for(auto x : mp)&#123; x.a *= B; ans = ans * cal(x.p, x.a) % MOD; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛进阶指南</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wannafly挑战赛26]]></title>
    <url>%2F2018%2F10%2F13%2FACM%E9%A2%98%E7%9B%AE%2F%E9%A2%98%E8%A7%A3(%E7%89%9B%E5%AE%A2%E7%BD%91)%2FWannafly%E6%8C%91%E6%88%98%E8%B5%9B26%2F</url>
    <content type="text"><![CDATA[Wannafly挑战赛26Wannafly挑战赛26 emm.现在本来还是比赛时间.但是只搞出A题的我.指向写个博客然后去写项目.orz A. 御坂网络 ACWA 三次是因为.1.代码确实写错 2. 算n-1个点到这个点的距离去了. 3. emm.想到了正确的算法.但是应该输出没有换行.然后想想算距离是double.有精度损失呀.换种方式吧.就过了. 题目大意:平面坐标中有$$n$$个点.是否可以选择一个点作为圆心.其他$$n-1$$个点在这个圆上. 题解:圆的方程： $$ (x - a) + (y - b) = r^2$$所以只要$O(n^2)$暴力匹配这个方程就行. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define MAX_N 1100int n;struct Point&#123; LL x,y;&#125;p[MAX_N];LL d[MAX_N][MAX_N];LL dis(Point a, Point b)&#123; return (a.x - b.x)*(a.x - b.x)*1LL + (a.y - b.y) * (a.y - b.y)*1LL;&#125;int main()&#123; // freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n; for(int i = 0; i &lt; n; ++i)&#123; cin &gt;&gt; p[i].x &gt;&gt; p[i].y; &#125; for(int i = 0; i &lt; n; ++i)&#123; for(int j = 0; j &lt; n; ++j)&#123; if(i == j) continue; d[i][j] = dis(p[j], p[i]); &#125; &#125; for(int i = 0; i &lt; n; ++i)&#123; LL ans; ans = (i == 0) ? d[i][1] : d[i][0]; int j; for(j = 0; j &lt; n; ++j)&#123; if(j == i) continue; if(ans != d[i][j]) break; &#125; if(j == n) &#123; cout &lt;&lt; i+1; return 0; &#125; &#125; cout &lt;&lt; "-1"; return 0;&#125;]]></content>
      <categories>
        <category>题解(牛客网)</category>
      </categories>
      <tags>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典训练指南打卡day1]]></title>
    <url>%2F2018%2F10%2F10%2F%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E8%AE%AD%E7%BB%83%E6%8C%87%E5%8D%97%2F%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E8%AE%AD%E7%BB%83%E6%8C%87%E5%8D%97%E6%89%93%E5%8D%A1day1%2F</url>
    <content type="text"><![CDATA[emm.最近有点小烦躁.今年还只能打两场了.青岛和沈阳.想要拿牌子.题目不知如何刷起.太多了呀.自己太菜了呀.所以来一个打卡系列吧.打卡刘汝佳&lt;&lt;算法竞赛 入门经典 训练指南&gt;&gt;. so. 打卡day1. Meteor UVALive - 3905题目大意:有一个矩形照相机.矩形照相机照到的范围是$(0,0)$到$(w,h)$.有$n$个流星.第i个流星的初始坐标$(x_i, y_i)$,速度$(a_i, b_i)$.所以.$t(t &gt;= 0)$时刻第$i$个流星的位置就是$(x_{ti}, y_{ti}) = (x_i, y_i) + t*(a_i, b_i).$求某一时刻矩形照相机最多可以照到的流星数量.(在边界上照到的不算) 题解:转换一下问题.每一个流星在矩形照相机中的时间段是确定的(如果可以进入矩形照相机).假设在这n个流星中有k个流星在一定时间段可以照到.第$i$个流星能照到的时间段是$(L_i, R_i) 1 \leq i \leq k. 1 \leq k \leq n.$所以我们只要求出这$k$个开区间的最大交集的数量.就是某一时刻最多有多少个区间有交集.假设我们已经计算出这k个开区间.考虑下面的算法: 每一个区间有两个端点.将每一个区间的左右端点分别看作一个事件.按照坐标优先级第一从小到大.坐标相同的按照右端点优先原则排序. 有一个扫描线.一个计数器cnt=0.答案保存ans=0.从小到大开始扫描事件.当遇到当前事件是左端点时.cnt加上1.更新ans取大.当遇到当前事件是右端点时.cnt减去1. 这样扫描完就得到答案.复杂度$O(log(n))$ 计算区间: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;int T;int w,h,n,a,b;struct Event&#123; double x; int type; // 0表示左端点.1表示右端点 bool operator&lt;(const Event&amp; b)const&#123; // 第一优先级.端点坐标从小到大.第二优先级.先处理右端点 return x &lt; b.x || (x == b.x &amp;&amp; type &gt; b.type); &#125;&#125;;// 计算到达边界的时间void update(int x, int a, int w, double &amp;L, double &amp;R)&#123; /* x + t1*a &gt; 0 x + t2*a &lt; w */ if(a == 0)&#123; if(x &lt;= 0 || x &gt;= w) R = L-1; // a是0.而且一开始就在外面 &#125; else if(a &gt; 0)&#123; L = max(L, -(double)x/a); R = min(R, (double)(w-x)/a); &#125; else &#123; L = max(L, (double)(w-x)/a); R = min(R, -(double)x/a); &#125;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int x,y; double L,R; cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; w &gt;&gt; h &gt;&gt; n; vector&lt;Event&gt; v; for(int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; a &gt;&gt; b; L = 0; R = 1e9; // 0 &lt; x+t*a &lt; w, 0 &lt; y+t*a &lt; h update(x, a, w, L, R); update(y, b, h, L, R); if(R &gt; L)&#123; // 区间成立 // 加入左右端点 v.push_back((Event)&#123;L, 0&#125;); v.push_back((Event)&#123;R, 1&#125;); &#125; &#125; sort(v.begin(), v.end()); // 排好序 int ans = 0; int cnt = 0; for(auto &amp;x : v)&#123; if(x.type == 0) &#123; ++cnt; // 左端点的时候加上 ans = max(ans, cnt); &#125; else --cnt; // 右端点的时候减去 &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛入门经典训练指南</category>
      </categories>
      <tags>
        <tag>算法书籍习题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoderBeginnerContest112]]></title>
    <url>%2F2018%2F10%2F07%2FACM%E9%A2%98%E7%9B%AE%2F%E9%A2%98%E8%A7%A3(atcoder)%2FAtCoderBeginnerContest112%2F</url>
    <content type="text"><![CDATA[AtCoder Beginner Contest 112比赛链接 emm.第一次在AtCoder上的比赛. rank:754th rating:113. AC. WA.表示比赛时候的状态 A - Programming Education AC 题目大意: 输入1的时候输出”Hello World”. 输入2的时候会输入a,b.计算a+b. 题解: emm.入门操作.beginner出这个题还是很不错的.1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int kind,a,b; while(cin &gt;&gt; kind)&#123; if(kind == 1)&#123; cout &lt;&lt; "Hello World" &lt;&lt; endl; &#125; else &#123; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; (a+b) &lt;&lt; endl; &#125; &#125; return 0;&#125; B - Time Limit Exceeded AC 题目大意:给两个数N,T. N组数.每组两个数$c_i$和$t_i$.求所有不超过T的$t_i$中$c_i$的最小值. 题解: emm.入门操作.beginner出这个题还是很不错的. 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 105int N,T;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int c,t; while(cin &gt;&gt; N &gt;&gt; T)&#123; int ans = INT_MAX; for(int i = 1; i &lt;= N; ++i)&#123; cin &gt;&gt; c &gt;&gt; t; if(t &lt;= T) ans = min(ans, c); &#125; if(ans == INT_MAX) cout &lt;&lt; "TLE" &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; C - Pyramid WA ps: 到最后没做出这道题.想暴力.然后看到 The center coordinates and the height of the pyramid can be uniquely identified 这句话.理解成中心点的坐标和h可能是无穷的.orz应该是:可以唯一地识别金字塔的中心坐标和高度. by google translate 题目大意:有N个点.$(x_i, y_i,h_i)$. $h_i$表示这个点的高度.求一个点$(C_x, C_y, H)$满足.$h_i = max(H-|x_i - C_x| + |y_i - C_y|, 0)$. 题解:由于$0 &lt;= C_x, C_y &lt;= 100.$所以暴力即可. 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 110int n;int x[MAX_N], y[MAX_N], h[MAX_N];int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); while(cin &gt;&gt; n)&#123; for(int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; h[i]; if(h[i] &gt; 0) &#123; swap(h[i], h[1]); swap(x[i], x[1]); swap(y[i], y[1]); &#125; &#125; for(int cx = 0; cx &lt;= 100; ++cx)&#123; for(int cy = 0; cy &lt;= 100; ++cy)&#123; int ch = h[1] + abs(x[1] - cx) + abs(y[1] - cy); bool is = true; for(int i = 2; i &lt;= n; ++i)&#123; if(max(ch - abs(x[i] - cx) - abs(y[i] - cy), 0) != h[i]) &#123; is = false; break; &#125; &#125; if(is)&#123; cout &lt;&lt; cx &lt;&lt; " " &lt;&lt; cy &lt;&lt; " " &lt;&lt; ch &lt;&lt; endl; return 0; &#125; &#125; &#125; &#125; return 0;&#125; D - Partition AC 题目大意:两个数N,M.可以有多种方案找N个数之和是M.每种方案N个数的最大公约数是x.这多种方案中x最大$$ \sum_{i=1}^{N}a_i = M $$$$ ans = max(gcd(a_1, a_2,…,a_N))$$ 题解:可以确定.答案不超过M/N.如果答案是x.那么.这个N个数一定是x的倍数.所以只要从M/N到1枚举.第一个满足M每次减去x的k倍.最后如果M是0.说明当前x是答案.因为是从大到小枚举.所以第一个肯定是最大的. 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 105int N,M;bool can(int x)&#123; int m = M; m -= x; while(m &gt; 0 &amp;&amp; m/x)&#123; m -= (m/x * x); &#125; return m == 0;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); while(cin &gt;&gt; N &gt;&gt; M)&#123; for(int ans = M/N; ans &gt;= 1; --ans)&#123; if(can(ans)) &#123; cout &lt;&lt; ans &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解(atcoder)</category>
      </categories>
      <tags>
        <tag>atcoderABC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客集训派对day3]]></title>
    <url>%2F2018%2F10%2F04%2FACM%E9%A2%98%E7%9B%AE%2F%E9%A2%98%E8%A7%A3(%E7%89%9B%E5%AE%A2%E7%BD%91)%2F%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E6%B4%BE%E5%AF%B9day3%2F</url>
    <content type="text"><![CDATA[原比赛链接emmm.国庆刷题狂欢,来自暑假ccpc-wannafly camp day 3的题目 A.Knight题目描述有一张无限大的棋盘，你要将马从(0,0)移到(n,m)。每一步中，如果马在(x,y)，你可以将它移动到(x+1,y+2),(x+1,y-2),(x-1,y+2),(x-1,y-2),(x+2,y+1),(x+2,y-1),(x-2,y+1)或(x-2,y-1)。你需要最小化移动步数。 输入描述:第一行一个整数t表示数据组数 (1≤ t≤ 1000)。每组数据一行两个整数n,m (|n|,|m|≤ 109)。 输出描述:每组数据输出一行一个整数表示最小步数。 示例1输入20 44 2输出22 不妨假设 x&gt;=y&gt;=0。当 x&lt;=2y 时，定义每一步的冗余值 wi=3-dx-dy，那么∑wi=∑(2-dx)=3步数-x-y，显然我们只需要最小化冗余值。我们先只用(+2,+1)(若 x 为奇数则加一步(+1,+2))走到(x,y’)，然后通过将(+2,+1)替换为 2 个(+1,+2)使得0&lt;=y-y’&lt;3。若 y-y’=0，则冗余值为 0，显然最小。若 y-y’=1，则将(+1,+2)替换为(+2,+1)和(-1,+2)或将 2 个(+2,+1)替换为(+1,+2),(+1,+2),(+2,-1)，冗余值为 2，显然最小。（此处需要特判(2,2)）若 y-y’=2，则加上(+2,+1)和(-2,+1)，冗余值为 4，由于不存在冗余值为 1的步，所以最小。当 x&gt;2y 时，定义每一步的冗余值 wi=2-dx，那么∑wi=∑(2-dx)=2步数-x，显然我们只需要最小化冗余值。我们先只使用(+2,+1)走到(2y,y)，然后用(+2,+1)和(+2,-1)走到(x’,y)使得 0&lt;=x-x’&lt;4。若 x-x’=0 则冗余值为 0，显然最小。若 x-x’=1 则将之前的(+2,+1)改为(+1,+2)和(+2,-1)，冗余值为 1，显然最小。（此处需要特判(1,0)）若 x-x’=2 则加上(+1,+2)和(+1,-2)，冗余值为 2，由 x/2+y 的奇偶性可知最小。若 x-x’=3 则加上(+2,+1),(+2,+1),(-1,-2)，冗余值为 3，由 x/2+y 的奇偶性可知最小。时间复杂度 O(t) 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll fun(ll x, ll y) &#123; if (x == 1 &amp;&amp; y == 0) &#123; return 3; &#125; if (x == 2 &amp;&amp; y == 2) &#123; return 4; &#125; ll delta = x - y; if (y&gt;delta) &#123; return delta - 2 * floor(((double)(delta-y)) / 3.0); &#125; else &#123; return delta - 2 * floor(((double)(delta-y)) / 4.0); &#125;&#125;int main()&#123; //freopen("in.txt", "r", stdin); int t; cin &gt;&gt; t; while (t--) &#123; ll x, y; cin &gt;&gt; x &gt;&gt; y; x = abs(x); y = abs(y); if (x &lt; y) &#123; swap(x, y); &#125; cout &lt;&lt; fun(x, y) &lt;&lt; endl; &#125; return 0;&#125; D. Shopping题目描述你要买n件物品，其中有一些是凳子。商场正在举行促销活动，如果购物车中有至少一个凳子，那么你可以半价购买这个购物车中最贵的一个物品。你有m辆购物车，请最小化你的花费。 输入描述:第一行一个整数t表示数据组数 (1 ≤ t ≤ 100)。每组数据第一行两个整数n,m (1 ≤ n,m ≤ 1000)，接下来n行每行两个整数ai,bi，分别表示第i件物品的价格以及它是否是凳子 (1 ≤ ai ≤ 105, 0 ≤ bi ≤ 1)。 输出描述:每组数据输出一行一个实数表示最小花费，保留一位小数。 示例1 输入25 11 02 13 14 05 05 101 02 13 14 05 0 输出12.510.5 显然可以将最贵的 min(m,凳子个数)个物品打折。时间复杂度 O(tn) 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std; int t;int n,m; int main()&#123; //freopen("in.txt", "r", stdin); scanf("%d", &amp;t); int a,b; while(t--)&#123; scanf("%d%d", &amp;n, &amp;m); vector&lt;int&gt; v; int cnt = 0; for(int i = 0; i &lt; n; ++i)&#123; scanf("%d%d", &amp;a, &amp;b); if(b == 1) ++cnt; v.push_back(a); &#125; sort(v.begin(), v.end()); double ans = 0.0; int sz = v.size(); m = min(m, cnt); for(int i = sz-1,j=1; i &gt;= 0; --i,++j)&#123; if(j &lt;= m) ans += v[i]/2.0; else ans += v[i]; &#125; printf("%.1lf\n", ans); &#125; return 0;&#125; H.Travel题目描述魔方国有n座城市，编号为。城市之间通过n-1条无向道路连接，形成一个树形结构。澜澜打算在魔方国进行m次旅游，每次游览至少一座城市。为了方便，每次旅游游览的城市必须是连通的。此外，澜澜希望游览所有城市恰好一次。澜澜想知道有多少种旅游方案满足条件，两个方案不同当且仅当存在某一次旅游游览了不同的城市。澜澜不会数数，所以只好让你来帮他数方案。 输入描述:第一行一个整数t表示数据组数 (1 ≤ t ≤ 100)。每组数据第一行两个整数n,m ，接下来n-1行每行两个整数ai,bi表示一条道路 (1≤ ai,bi≤ n)。 输出描述:每组数据输出一行一个整数表示方案数对109+7取模的结果。 示例1 输入23 11 21 33 21 21 3 输出14 把树分成 m 个连通块的方案数是 C(n-1,m-1)，乘上 m!就行了。时间复杂度 O(∑n) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL MOD = 1e9 + 7;#define MAX_N 100100LL f[MAX_N];void init()&#123; f[0] = f[1] = 1LL; for(int i = 2; i &lt; MAX_N; ++i) f[i] = i * f[i - 1] % MOD;&#125;LL powN(LL a, LL n)&#123; LL base = a, res = 1LL; while(n)&#123; if(n &amp; 1) res = res * base % MOD; base = base * base % MOD; n &gt;&gt;= 1; &#125; return res;&#125;LL inv(LL a, LL MOD)&#123; return powN(a, MOD - 2LL);&#125;LL C(LL n, LL m)&#123; if(m == 0) return 1; if(n &lt; 0 || n &lt; m) return 0; return (f[n] % MOD) * (inv(f[m], MOD) * inv(f[n - m], MOD) % MOD) % MOD;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int t,a,b; LL n,m; cin &gt;&gt; t; init(); while(t--)&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n - 1; i++) cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; (C(n-1, m-1) * f[m]) % MOD&lt;&lt; endl; &#125; return 0;&#125; I.Metropolis题目描述魔方国有n座城市，编号为。城市之间通过n-1条无向道路连接，形成一个树形结构。在若干年之后，其中p座城市发展成了大都会，道路的数量也增加到了m条。大都会之间经常有贸易往来，因此，对于每座大都会，请你求出它到离它最近的其它大都会的距离。 输入描述:第一行三个整数n,m,p (1 ≤ n,m ≤ 2*105,2 ≤ p ≤ n)，第二行p个整数表示大都会的编号 (1≤ xi≤ n)。接下来m行每行三个整数ai,bi,li表示一条连接ai和bi，长度为li的道路 (1 ≤ ai,bi ≤ n,1 ≤ li ≤ 109)。保证图是连通的。 输出描述:输出一行p个整数，第i个整数表示xi的答案。示例1 输入5 6 32 4 51 2 41 3 11 4 11 5 42 3 13 4 3 输出3 3 5 把所有大都会设为源点跑多源最短路，记下每个点是由哪个源点扩展的。如果从源点 i 出发走到了一个由另一个源点 j 扩展到的点 k，那么从 i 出发经过 k 的最短距离肯定是 dis[i][j]，那么就没有必要继续走下去了。所以只要枚举所有两端由不同源点扩展的边更新答案就行了。时间复杂度 O((n+m)logn) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define MAX_N 200100const LL INF = 1e15;struct Edge&#123;int to; LL cost;&#125;;typedef pair&lt;LL, int&gt; P;int T;int n,m,k;int p[MAX_N];int is[MAX_N];LL d[MAX_N];LL ans[MAX_N];vector&lt;Edge&gt; G[MAX_N];void dijstra()&#123; for(int i = 1; i &lt;= n; ++i) d[i] = INF; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que; for(int i = 1; i &lt;= k; ++i)&#123; que.push(P(d[p[i]] = 0, p[i])); &#125; while(!que.empty())&#123; P p = que.top(); que.pop(); int v = p.second; if(p.first &gt; d[v]) continue; for(int i = 0; i &lt; G[v].size(); ++i)&#123; Edge e = G[v][i]; if(d[e.to] &gt; d[v] + e.cost)&#123; d[e.to] = d[v] + e.cost; is[e.to] = is[v]; // e.to是由v扩展的 que.push(P(d[e.to], e.to)); &#125; else if(is[v] != is[e.to])&#123; // 不同源点扩展的边 ans[is[v]] = min(ans[is[v]], d[v] + d[e.to] + e.cost); ans[is[e.to]] = min(ans[is[e.to]], d[v] + d[e.to] + e.cost); &#125; &#125; &#125;&#125;int main()&#123; //freopen("in.txt", "r", stdin); int u,v; LL c; scanf("%d%d", &amp;n, &amp;m); for(int i = 0; i &lt;= n; ++i) G[i].clear(); scanf("%d", &amp;k); for(int i = 1; i &lt;= k; ++i)&#123; scanf("%d", &amp;p[i]); ans[p[i]] = INF; is[p[i]] = p[i]; &#125; for(int i = 1; i &lt;= m; ++i)&#123; scanf("%d%d%lld", &amp;u, &amp;v, &amp;c); G[u].push_back((Edge)&#123;v, c&#125;); G[v].push_back((Edge)&#123;u, c&#125;); &#125; dijstra(); for(int i = 1; i &lt;= k; ++i)&#123; printf("%lld%c", ans[p[i]], "\n "[i &lt; k]); &#125; return 0;&#125; J. Graph Coloring I题目描述修修在黑板上画了一些无向连通图，他发现他可以将这些图的结点用两种颜色染色，满足相邻点不同色。澜澜不服气，在黑板上画了一个三个点的完全图。修修跟澜澜说，这个图我能找到一个简单奇环。澜澜又在黑板上画了一个n个点m条边的无向连通图。很可惜这不是一道数数题，修修做不出来了。澜澜非常得意，作为一位毒瘤出题人，有了好题当然要跟大家分享，于是他把这道题出给你做了。 输入描述:第一行两个整数n,m (1≤ n,m≤ 3*105)，接下来m行每行两个整数ai,bi表示一条边 (1≤ ai,bi≤ n)。保证图连通，并且不存在重边和自环。输出描述:如果你能把图二染色，第一行输出0，第二行输出n个整数表示每个点的颜色 (0≤ xi≤ 1)。如果有多种合法方案，你可以输出任意一种。如果你能找到一个简单奇环，第一行输出环长k，第二行输出k个整数表示环上结点编号 (1≤ yi≤ n)，你需要保证yi和yi+1之间有边，y1和yn之间有边。如果有多种合法方案，你可以输出任意一种。如果两种情况都是可行的，你只需要输出任意一种。如果两种情况都是不可行的，请输出一行一个整数-1。 示例1 输入3 21 21 3 输出00 1 1 示例2复制3 31 21 32 3 输出31 2 3 判一下是不是二分图就行了。时间复杂度 O(n+m) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 3*1e5+100;int color[MAX_N];vector&lt;int&gt; G[MAX_N];vector&lt;int&gt; p;int n,m;int s,e;bool dfs(int u, int c)&#123; color[u] = c; p.push_back(u); for(int i = 0; i &lt; G[u].size(); ++i)&#123; int v = G[u][i]; if(color[u] == color[v]) &#123;s = v, e = u;return false;&#125; if(!color[v])&#123; if(!dfs(v, 3 - c)) return false; &#125; &#125; p.erase(--p.end()); return true;&#125;int main()&#123; //freopen("in.txt", "r", stdin); scanf("%d%d", &amp;n, &amp;m); int u,v; for(int i = 1; i &lt;= m; ++i)&#123; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; memset(color, 0, sizeof(color)); if(dfs(1, 1))&#123; puts("0"); for(int i = 1; i&lt;= n; ++i)&#123; printf("%d%c", color[i]-1, "\n "[i &lt; n]); &#125; &#125; else &#123; int i = -1; int sz = p.size(); while(p[++i] != s); printf("%d\n", sz - i); for(;i &lt; sz; ++i)&#123; printf("%d%c", p[i], "\n "[i &lt; sz-1]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解(牛客网)</category>
      </categories>
      <tags>
        <tag>ccpc-wannafly-camp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018ccpc-wannafly-round]]></title>
    <url>%2F2018%2F08%2F03%2F%E6%97%A5%E8%AE%B0%2F2018ccpc-wannafly-round1%2F</url>
    <content type="text"><![CDATA[前言今天是训练营的第一天，早上去了一个大教室，上了一节”如何学习算法”的课,课上的最后一个初中cf橙名大佬上去互动来着.初中人家在打算法比赛,我初中的时候在干啥,难以回忆,差距呀!!!课上击鼓传花回答了一个问题”为什么学习算法”.我内心的答案是,”好玩,神奇,能赚钱”.还有听到一句话就是:”不怕学霸有多霸,就怕学霸放暑假”,好像是这样说的.作为菜鸡的自己瑟瑟发抖,自己被别人超越了很多个暑假. 比赛中午在酒店吃了自助餐之后,躺了一小会儿就去上次打省赛的机房去了,一开始比赛方的服务器没准备好,所以早上讲课的老师就在vj上开了一场练习赛,我A了一道暴力判断回文串的水题之后,大概就开始正赛了.值得一提的是,我们旁边坐了一个小学生!!!小学生!!!再次震惊,上次震惊是5月份的省赛,我真的以为小学生就能A签到题,最后发现虽然他是在教练指导下A的,但是他真的会写C语言代码.不得不说,别人家的小时候.正式打比赛.一看I题题目是最短路,然后那道题没有样例.然后第一手队友说dijkstra模板,我说给我&lt;&lt;挑战程序设计竞赛&gt;&gt;这本书,我A一个,最后发现不行,单源最短路径一次时间复杂度是O(|E|log|V|),但是它有Q组询问,Q有1e6这么大吧,E和V也是大概1e6.然后我去看榜单,A了一个签到G题,答案就是找出序列的最大的那个然后乘2.后面我就在做A,一开始以为是DP,后来贪心,后来写了贪心的代码,样列过了,队友的样例也过了,但是就是红的WA.~~最后题解是费用流,自己菜鸡,没有看费用流.其他题也是中等题没有做出来.难题就GG,想都不要想.我们队做出三个签到. 总结渐渐的成为一个ACMer,也大概一年了,从啥都不知道到现在.发现百度之星进决赛可以百度的校招绿色通道.还有美团的比赛.所以打比赛还是很不错的,如果可以靠打比赛进入一个好公司的话,就不想考研了,下一年的目标就是每天5道cf.然后坚持一年下来.加油吧!!!]]></content>
      <categories>
        <category>ACMer日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1125-smallest-Sufficient-Team]]></title>
    <url>%2F2018%2F03%2F25%2FACM%E9%A2%98%E7%9B%AE%2F%E9%A2%98%E8%A7%A3(%E5%8A%9B%E6%89%A3)%2F1125--Smallest-Sufficient-Team%2F</url>
    <content type="text"><![CDATA[$S$表示一个二进制集合.$S$中第$i$位是$1$表示该集合包含标号是$i$的技能 令$dp[S]$表示要获得集合$S$表示的技能的最小花费.也就是最少需要选多少人 假设技能个数是$n$,那么要求的答案就是$dp[(1 &lt;&lt; n)-1]$ 对于状态转移方程: 假设当前第$i$个人的技能集合是$now$.我们就拿当前的技能集合 $now$去更新每一个$dp[now|j], 0 &lt;= j &lt; (1 &lt;&lt; n)$的值. 因为要记录最后所选的答案.所以拿一个$team$数组维护一下 时间复杂度$O(m*2^n)$.$m$是人的个数,$n$是技能个数 ps:看了mike-meng大佬的题解.所以加了自己的见解 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; smallestSufficientTeam(vector&lt;string&gt;&amp; req_skills, vector&lt;vector&lt;string&gt;&gt;&amp; people) &#123; unordered_map&lt;string, int&gt; mp; int n = req_skills.size(); for(int i = 0; i &lt; n; ++i) mp[req_skills[i]] = i; vector&lt;int&gt; dp(1 &lt;&lt; n, -1); vector&lt;int&gt; team[1 &lt;&lt; n]; dp[0] = 0; // 一个技能都没有的最小花费是0 for(int i = 0; i &lt; people.size(); ++i)&#123; int now = 0; for(string s : people[i])&#123; int x = mp[s]; now |= (1 &lt;&lt; x); &#125; for(int j = 0; j &lt; (1 &lt;&lt; n); ++j)&#123; if(dp[j] &gt;= 0)&#123; // 当前集合计算过 int x = now | j; // 要更新的集合 if(dp[x] == -1 || dp[x] &gt; dp[j]+1)&#123; // 集合没有计算过,或者当前选择更优 dp[x] = dp[j]+1; team[x] = team[j]; team[x].push_back(i); &#125; &#125; &#125; &#125; return team[(1 &lt;&lt; n)-1]; &#125;&#125;;]]></content>
      <categories>
        <category>题解(力扣)</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[M斐波那契数列]]></title>
    <url>%2F2018%2F03%2F25%2FACM%E9%A2%98%E7%9B%AE%2F%E9%A2%98%E8%A7%A3(%E6%9C%AA%E5%88%86%E7%B1%BB)%2FM%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目传送门 Problem DescriptionM斐波那契数列F[n]是一种整数数列，它的定义如下： F[0] = aF1 = bF[n] = F[n-1] * F[n-2] ( n &gt; 1 ) 现在给出a, b, n，你能求出F[n]的值吗？ Input输入包含多组测试数据；每组数据占一行，包含3个整数a, b, n（ 0 &lt;= a, b, n &lt;= 10^9 ） Output对每组测试数据请输出一个整数F[n]，由于F[n]可能很大，你只需输出F[n]对1000000007取模后的值即可，每组数据输出一行。 Sample Input0 1 06 10 2 Sample Output060 题目解决题目分析: 注意到n的范围最大到10^9,所以简单的进行递推时间和空间上都无法处理到限制范围内. 这道题涉及到取余运算,所以我们应该知道取余运算的其中一个性质:$$(ab) \mod p = ((a \mod p) (b \mod p)) \mod p$$ 注意到该递推式和斐波那契数列有相似之处. 知识点:1.斐波那契数列的矩阵运算1.斐波那契数列$fib(0) = 0$$fib(1) = 1$$fib(n) = fib(n-1)+fib(n-2)$| n | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | … | … | n-1 | n || —–: | —–: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: || fib(n) | 0 | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 | 34 | 55 | 89 | 144 | 233 | 377 | … | … | fib(n-1) | fib(n) | 2.将斐波那契数列写到矩阵中1.考虑按照以下表达式构造n个矩阵:$$ A_{n} = \begin{bmatrix} fib(n) &amp; fib(n+1) \ fib(n+1) &amp; fib(n+2) \ \end{bmatrix}$$ 2.得到如下矩阵$A_{0} = \begin{bmatrix}0 &amp; 1 \1 &amp; 1 \ \end{bmatrix} $ &nbsp; $A_{1} = \begin{bmatrix}1 &amp; 1 \1 &amp; 2 \ \end{bmatrix} $ &nbsp; $ A_{2} = \begin{bmatrix}1 &amp; 2 \2 &amp; 3 \ \end{bmatrix} $ &nbsp; $A_{3} = \begin{bmatrix}2 &amp; 3 \3 &amp; 5 \ \end{bmatrix} $ &nbsp; $A_{4} = \begin{bmatrix}3 &amp; 5 \5 &amp; 8 \ \end{bmatrix} $ … &nbsp; … &nbsp; … $A_{n} = \begin{bmatrix}fib(n) &amp; fib(n+1) \ fib(n+1) &amp; fib(n+2) \ \end{bmatrix} $ 3.矩阵乘法运算$A_{1} = \begin{bmatrix}1 &amp; 1 \1 &amp; 2 \ \end{bmatrix} = A_{0}A_{0}$ &nbsp;&nbsp;&nbsp; $ A_{2} = \begin{bmatrix}1 &amp; 2 \2 &amp; 3 \ \end{bmatrix} = A_{0}A_{0}A_{0}$ &nbsp;&nbsp; $A_{3} = \begin{bmatrix}2 &amp; 3 \3 &amp; 5 \ \end{bmatrix} = A_{0}A_{0}A_{0}A_{0} $ $ A_{4} = \begin{bmatrix}3 &amp; 5 \5 &amp; 8 \ \end{bmatrix} = A_{0}A_{0}A_{0}A_{0}A_{0}$ &nbsp;&nbsp; $A_{n} = \begin{bmatrix}fib(n) &amp; fib(n+1) \fib(n+1) &amp; fib(n+2) \ \end{bmatrix} = A_{0} ^ {n+1}$ \begin{array}{|rrrrrrrr|}\hline\color{red}{综上所述,要想求解f(n),求得A(n)或者A(n-2)即可} &amp;\hline\end{array} 2.快速幂:Q:&nbsp;&nbsp;&nbsp;求解 $ x ^ N $A:&nbsp;&nbsp;&nbsp;O(N)的算法:1234ans = 1; for(i = 1; i &lt;= n; i++)&#123; ans *= x;&#125; A:&nbsp;&nbsp;&nbsp;O(logN)的算法: 将N转换成二进制表示形式 $$ N = 2 ^ {k_{1}} + 2 ^ {k_{2}} + 2 ^ {k_{3}} + …. + 2 ^ {k_{n}}$$ 要求解$x ^ N $,相当与计算$$ x ^ N = x ^ {2 ^ {k_{1}} + 2 ^ {k_{2}} + 2 ^ {k_{3}} + …. + 2 ^ {k_{n}}} = x^{2 ^ {k_{1}}}x^{2 ^ {k_{2}}}x^{2 ^ {k_{3}}}…x^{2 ^ {k_{n}}}$$ 所以只要在依次求$x ^ {2^i} $ 的同时进行计算就好了,最终得到了O(logN)的计算幂运算的算法 举个例子:计算 $ x ^ {22} $ 十进制下的22的二进制表示 : $ 22_{10} = 10110_{2}$ $ N = 22 = 2^{4} + 2^{2} + 2^{1}$ $ x^{22} = x^{2^{4} + 2^{2} + 2^{1}} = x^{16}x^{4}x^{2}$ 可以看到如果是O(N)的算法,当前例子需要计算22次,而O(logN)的算法只需要计算5次 \begin{array}{|rrrrrrrr|}\hline&amp; \color{red}{CODE:}&amp;\hline\end{array}123456789101112131415161718192021222324typedef long long LL;// 计算x^n,复杂度O(logN)LL powN(LL x, LL n)&#123; LL r = 1; // 计算结果 while(n)&#123; if(n&amp;1) r *= x; // 如果n的二进制表示i(i &gt;= 0)的位置是1,则乘上x^(2^i) x *= x; // 将x平方 n &gt;&gt;= 1; // 右移一位 &#125; return r; // 返回结果&#125;// 计算x^n mod p, ( a * b ) % p = ( ( a % p ) * ( b * p ) ) % p 复杂度O(logN)LL mod_powN(LL x, LL n, LL p)&#123; LL r = 1; // 计算结果 while(n)&#123; if(n&amp;1) r = r * x % p; // 如果n的二进制表示i(i &gt;= 0)的位置是1,则乘上x^(2^i) x = x * x % p; // 将x平方 n &gt;&gt;= 1; // 右移一位 &#125; return r; // 返回结果&#125; 3.费马小定理:费马小定理是数论中的一个定理：假如a是一个整数，p是一个质数，那么 $a^{p}-a$是p的倍数，可以表示为$$ a ^ p \equiv a (\mod p) $$如果a不是p的倍数，这个定理也可以写成$$ a ^ {p-1} \equiv 1 (\mod p)$$费马小定理是欧拉定理的一个特殊情况：如果n和a的最大公因数是1，那么$$ a^{φ(n)} \equiv 1 (\mod n) $$这里φ(n)是欧拉函数。欧拉函数的值是所有小于或等于n的正整数中与n互质的数的个数。假如n是一个素数（质数），则φ(n) = n-1，即费马小定理注: $\equiv$是同余符号 $ a \mod p = b \mod p$ 可表示为 $ a \equiv b (\mod p)$ 推导以下表达式:当p是质数时:$$ a ^ n \equiv a ^ {(n \mod (p-1))} (\mod p) $$成立 证:$$ n = k(p-1) + (n \mod (p-1)) (k为整数) $$$$ a ^ n \equiv a ^ {k(p-1) + (n \mod (p-1))} \equiv {a ^ {p-1}} ^ {k} a ^ {(n \mod (p-1))} (\mod p)$$由费马小定理可知:$$ {a ^ {p-1}} ^ {k} \equiv a ^ {p-1} \equiv 1(\mod p)$$得证:$$ a ^ n \equiv a ^ {(n \mod (p-1))} (\mod p) $$ 回到题目:1.分析我们注意到虽然题目中的M斐波那契数列和斐波那契数列有异曲同工之处,但是一个计算的是乘法,一个是加法,但加法和乘法之间有着密切的联系. 2.算一算先计算前几项的值:$$ f(0) = a = a ^ 1 b ^ 0 $$$$ f(1) = b = a ^ 0 b ^ 1 $$$$ f(2) = a b = a ^ 1 b ^ 1 $$$$ f(3) = a b b = a ^ 1 b ^ 2 $$$$ f(4) = a a b b b = a ^ 2 b ^ 3 $$$$ f(4) = a a a b b b b b= a ^ 3 b ^ 5 $$$$ ……………………………………………………..$$$$ f(n) = f(n-1)f(n-2) = a ^ x b ^ y $$|n| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 11 | 12 | 13 | … | … | n-1 | n ||——–| —–: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: ||x| 1 | 0 | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 | 34 | 55 | 89 | … | … | fib(n-2) | fib(n-1) ||y| 0 | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 | 34 | 55 | 89 | 144 | … | … | fib(n-1) | fib(n) | 不难得出:$$ f(0) = a $$$$ f(1) = b $$$$ f(n) = f(n-1)f(n-2) = a ^ {fib(n-1)} b ^ {fib(n)} (n &gt;= 2) $$ 通过上面费马小定理证明的结论,当p是质数时:$$ a ^ n \equiv a ^ {(n \mod (p-1))} (\mod p) $$所以我们实际上需要计算的就是下面的表达式(p = 1000000007):$$ f(n) \mod p= f(n-1)f(n-2) \mod p = a ^ {fib(n-1) \mod p-1} b ^ {fib(n) \mod p-1} \mod p(n &gt;= 2) $$ 1.计算类似于计算整数的快速幂算法计算矩阵的幂 $A_{n-1} = A_{0} ^ {n}$$A_{0} = \begin{bmatrix}0 &amp; 1 \1 &amp; 1 \ \end{bmatrix}$ &nbsp;&nbsp; $A_{n-1} = \begin{bmatrix}fib(n-1) &amp; fib(n) \fib(n) &amp; fib(n+1) \ \end{bmatrix} = A_{0} ^ {n}$ 计算矩阵的幂时,我们实际上需要得到的结果是:$$ A_{n-1} \mod p-1 = \begin{bmatrix}fib(n-1) \mod p-1 &amp; fib(n) \mod p-1 \fib(n) \mod p-1 &amp; fib(n+1) \mod p-1 \ \end{bmatrix} = (A_{0} \mod p-1) ^ {n} \mod p-1 $$ 如果理解了上面的快速幂算法的话,这实现起来将会非常简单 2.得到$fib(n-1) \mod p-1$ 和 $fib(n) \mod p-1$ 之后,设这两个数为x,y,用整数的快速幂算法计算:$$a ^ x b^y \mod p = (a ^ x \mod p b^y \mod p) \mod p$$ \begin{array}{|rrrrrrrr|}\hline&amp; \color{red}{CODE:}&amp;\hline\end{array} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MOD1 = 1e9+7; // pconst int MOD2 = 1e9+6; // p-1LL a,b,n;typedef struct Matrix&#123; // 矩阵结构体 LL arr[2][2];&#125;Matrix;Matrix unit = &#123; // 单位矩阵 1,0, 0,1&#125;;Matrix A0 = &#123; // A0矩阵 0,1, 1,1&#125;;// 矩阵a*bMatrix matrixMulti(Matrix a, Matrix b)&#123; int i,j,k; Matrix tmp; for(i = 0; i &lt; 2; i++)&#123; for(j = 0; j &lt; 2; j++)&#123; tmp.arr[i][j] = 0; for(k = 0; k &lt; 2; k++)&#123; tmp.arr[i][j] += (a.arr[i][k]*b.arr[k][j])%MOD2; tmp.arr[i][j] %= MOD2; &#125; &#125; &#125; return tmp;&#125;// 矩阵快速幂,计算的结果对MOD2取余Matrix matrixPow(Matrix a, LL n)&#123; Matrix r = unit, base = a; while(n)&#123; if(n&amp;1) r = matrixMulti(r,base); base = matrixMulti(base, base); n &gt;&gt;= 1; &#125; return r;&#125;// 整数快速幂,计算的结果对MOD1取余LL powN(LL a, LL n)&#123; LL r = 1, base = a%MOD1; while(n)&#123; if(n&amp;1) r = r*base%MOD1; base = base*base%MOD1; n &gt;&gt;= 1; &#125; return r;&#125;int main()&#123; //freopen("in.txt", "r", stdin); Matrix An_1; while(~scanf("%lld%lld%lld", &amp;a, &amp;b, &amp;n))&#123; // 输入a,b,n An_1 = matrixPow(A0,n); // 计算An_1 printf("%lld\n", powN(a, An_1.arr[0][0]) * powN(b, An_1.arr[1][0]) % MOD1); &#125; return 0;&#125; 思考:Q: 为什么要使用费马小定理?A: 因为 $ x \mod p-1 &lt;= x $ 所以可以减少计算整数幂时候的计算次数,不使用费马小定理会超时. 作者 @何军2018 年 03月 24日]]></content>
      <categories>
        <category>题解(未分类)</category>
      </categories>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019中国大学生程序设计竞赛（CCPC）---网络选拔赛-1004-path]]></title>
    <url>%2F2018%2F03%2F25%2FACM%E9%A2%98%E7%9B%AE%2F%E9%A2%98%E8%A7%A3(XCPC)%2F2019%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%EF%BC%88CCPC%EF%BC%89---%E7%BD%91%E7%BB%9C%E9%80%89%E6%8B%94%E8%B5%9B-1004-path%2F</url>
    <content type="text"><![CDATA[考虑维护按照边权最小的堆，维护结点信息如下: 12345int u; // 上一个结点int v; // 当前结点LL lst; // 到上一个结点u的距离LL now; // 到当前结点v的距离int id; // 上一个结点u下一次需要扩展的下标 一开始，先将每个结点从最短的那条边扩展，然后对于每次操作。取队头元素，当前的路径距离就是第$idx$小的路径，用队头元素进行扩展: 从结点$v$最短的一条边扩展 从结点u的$id$下标编号进行扩展 扩展的时候维护上述信息。 这种贪心策略就是很对。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std; typedef long long LL;#define dbg(x) cout &lt;&lt; #x"=" &lt;&lt; x &lt;&lt; endl;#define SZ(x) (int)(x).size()struct Node&#123; int u; // 上一个结点 int v; // 当前结点 LL lst; // 到上一个结点u的距离 LL now; // 到当前结点v的距离 int id; // 上一个结点u下一次需要扩展的下标 bool operator&lt;(const Node &amp;b)const&#123; return now &gt; b.now; &#125; void pt()&#123; dbg(u) dbg(v) dbg(lst) dbg(now) dbg(id) dbg("----") &#125;&#125;;typedef pair&lt;LL, int&gt; P;#define w_ first #define v_ secondconst int MAX_M = 5*1e4+100;int Q[MAX_M], A[MAX_M];int n,m,q;vector&lt;P&gt; G[MAX_M];void solve()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for(int i = 1; i &lt;= n; ++i) G[i].clear(); int u,v; LL w; priority_queue&lt;Node&gt; que; for(int i = 1; i &lt;= m; ++i)&#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; G[u].push_back(make_pair(w, v)); &#125; int mxK = 0; for(int i = 1; i &lt;= q; ++i)&#123; cin &gt;&gt; Q[i]; mxK = max(mxK, Q[i]); &#125; for(int i = 1; i &lt;= n; ++i)&#123; sort(G[i].begin(), G[i].end()); if(SZ(G[i]))&#123; // 从G[i]最小的扩展出一条边 P e = G[i][0]; que.push((Node)&#123;i, e.v_, 0, e.w_, 1&#125;); &#125; &#125; int idx = 0; /* int u; // 上一个结点 int v; // 当前结点 LL lst; // 到上一个结点u的距离 LL now; // 当当前结点v的距离 int id; // 上一个结点u需要扩展的下标 */ while(idx &lt; mxK)&#123; Node p = que.top(); que.pop(); A[++idx] = p.now; // 从v扩展当前结点最小的边 if(SZ(G[p.v])) &#123; P e = G[p.v][0]; que.push((Node)&#123;p.v, e.v_, p.now, p.now+e.w_, 1&#125;); &#125; // 通过G[p.u][p.id]扩展 if(p.id &lt; SZ(G[p.u]))&#123; P e = G[p.u][p.id]; que.push((Node)&#123;p.u, e.v_, p.lst, p.lst+e.w_, p.id+1&#125;); &#125; &#125; for(int i = 1; i &lt;= q; ++i)&#123; cout &lt;&lt; A[Q[i]] &lt;&lt; endl; &#125;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int T; cin &gt;&gt; T; while(T--) solve(); return 0;&#125;]]></content>
      <categories>
        <category>题解(XCPC)</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[骰子作画]]></title>
    <url>%2F2018%2F03%2F17%2Fdemo%2F%E9%AA%B0%E5%AD%90%E4%BD%9C%E7%94%BB%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package Hebut_HappyBirthday;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import java.io.PrintStream;import java.lang.invoke.ConstantCallSite;import java.util.ArrayList;import javax.imageio.ImageIO;public class HebutHappyBirthday &#123; public BufferedImage hebutImg; public static int rgb2gray(int argb) &#123; int alpha = (argb &gt;&gt; 24) &amp; 0xFF; int red = (argb &gt;&gt; 16) &amp; 0xFF; int green = (argb &gt;&gt; 8) &amp; 0xFF; int blue = argb &amp; 0xFF; return (int)(0.3*red + 0.59*green + 0.11*blue); &#125; public static int sixStepGary(int x) &#123; int i; int c = 256/10; for(i = 0; i &lt;= 9; i++) &#123; if(i*c &lt; x &amp;&amp; x &lt;= (i+1)*c) return i; &#125; return 9; &#125; public static String getXChar(int x, int i) &#123; String str[] = new String[10]; str[0] = " "; str[1] = " 0"; str[2] = "0 0"; str[3] = "0 "; str[4] = "0 0"; str[5] = "000"; if(x == 0 || (x == 1 &amp;&amp; i != 2) || (x == 2 &amp;&amp; i == 2) || (x == 4 &amp;&amp; i == 2)) return str[0]; if((x == 2 &amp;&amp; i == 1) || (x == 3 &amp;&amp; i == 1)) return str[1]; if(i == 2 &amp;&amp; (x == 1 || x == 2 || x == 3 || x == 5)) return str[2]; if(i == 3 &amp;&amp; (x == 2 || x == 3)) return str[3]; if((x == 8 &amp;&amp; i == 2) || x == 6 || (x == 7 &amp;&amp; (i == 1 || i == 3)) || (x == 5 &amp;&amp; (i == 1 || i == 3)) || x == 4) return str[4]; if(x == 9 || (x == 8 &amp;&amp; (i == 1 || i == 3)) || (x == 7 &amp;&amp; i == 2)) return str[5]; return null; &#125; public HebutHappyBirthday() throws Exception &#123; hebutImg = ImageIO.read(new File("/media/hejun/新加卷/hebut520.jpg")); final int MAX_N = 10000; int i,j,k,l,ii,jj = 0,kk,ll,n = 1; int[][] rgb = new int[MAX_N][MAX_N]; int[][] ansrgb = new int[MAX_N][MAX_N]; int width = hebutImg.getWidth(); int height = hebutImg.getHeight(); int minx = hebutImg.getMinX(); int miny = hebutImg.getMinY(); //System.out.println(minx + " " + miny + " " + width + " " + height); for(i = minx; i &lt; height; i++) &#123; for(j = miny; j &lt; width; j++) &#123; rgb[i][j] = rgb2gray(hebutImg.getRGB(j, i));//获得像素值 &#125; &#125; int sum,count; for(i = minx, ii = 0; i &lt; height; i += n, ii++) &#123; for(j = miny, jj = 0; j &lt; width; j += n, jj++) &#123; sum = count = 0; for(k = i, kk = 0; kk &lt; n &amp;&amp; k &lt; height; k++, kk++) &#123; for(l = j, ll = 0; ll &lt; n &amp;&amp; l &lt; width; l++, ll++) &#123; sum += rgb[k][l]; count++; &#125; &#125; ansrgb[ii][jj] = sixStepGary(sum/count); &#125; &#125; String str; for(i = 0; i &lt; ii; i++) &#123; for(k = 1; k &lt;= 3; k++) &#123; str = ""; for(j = 0; j &lt; jj; j++) &#123; str += getXChar(ansrgb[i][j], k); &#125; System.out.println(str); &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; HebutHappyBirthday hebutHappyBirthday = new HebutHappyBirthday(); &#125;&#125;]]></content>
      <categories>
        <category>Demo</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学问题]]></title>
    <url>%2F2017%2F09%2F09%2FACM%E9%A2%98%E7%9B%AE%2F%E9%A2%98%E8%A7%A3(%E6%9C%AA%E5%88%86%E7%B1%BB)%2F%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目地址 数学问题时间限制：2000/1000 MS（Java / Others）内存限制：32768/32768 K（Java / Others）总提交：1321接受提交：476 问题描述给定一个正整数n，请计算k个满足多少正整数 ķ^k≤ N。 输入没有超过50个测试用例。 每种情况只包含一行中的积分整数n。 1 ≤ N ≤ 1e18 产量对于每个测试用例，输出整数表示正整数k满足的数量 k^k≤ N 在一条线上。 样品输入14 样品输出12 错误答案：1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; // 正整数 long long n; int k = 1, sum = 0; while (scanf("%I64d", &amp;n) != EOF &amp;&amp; n &gt;= 1 &amp;&amp; n &lt;= 1e18) &#123; while (k &lt;= n) &#123; if (pow(k, k) &lt;= n) &#123; sum++; k++; &#125; else &#123; break; &#125; &#125; printf("%d\n", sum); sum = 0; k = 1; &#125; return 0;&#125; 正确答案：123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;long long a[20];void deal()&#123; for (int i = 1; i &lt;= 15; i++) // 计算k的k次方 &#123; long long result = 1; for (int j = 1; j &lt;= i; j++) &#123; result *= i; &#125; a[i] = result; &#125; a[16] = (long long)1e18 * 9; // 界限是1e18&#125;int main()&#123; deal(); long long n; while (cin &gt;&gt; n) &#123; for (int i = 1; i &lt;= 16; i++) &#123; if (a[i] &gt; n) &#123; cout &lt;&lt; i - 1 &lt;&lt; endl; break; &#125; &#125; &#125;&#125; 出错原因：1. 你会发现两种方法的最大不同： 第一种是每一次算出一个k的k次方来和n比较，使用pow()函数计算k的k次方 第二种是把k^k(1&lt;=k&lt;=15)放在一个数组中，并且在最后一个数中放a[16] = 1e18 * 9计算k的k次方的函数是自己写的 2. 第二种成功的方法为什么(1&lt;=k&lt;=15)，并且在数组下标16位放1e16*9： 15^15 = 437,893,890,380,859,375 ，一共18位，但是比1e18小 16^16 = 18,446,744,073,709,511,616 ，一共20位, 比1e18大 long long的最大值：9,223,372,036,854,775,807，一共19位 这样就确定了k的范围，并且解释了为什么在数组下标16位放1e16*9 当然你也可以这样写，只要最大的数字比1e18大就好 1a[16] = (long long)1e18 + 1; // 界限是1e18 但是这样不是最严谨，尽量放大一点是最严谨的 2. 重点要解释的问题，使用pow()函数为什么会出错： pow()函数返回的是double类型的数，使用pow()函数打印15的15次方你会发现： 再拿计算器计算 两个结果不一样，对比下面两张图你就会发现 当数字大到15^15时两个计算的结果就不同，所以这就导致了第一种方法出现错误答案的原因！ 总结：解题时注意关注数据类型的取值范围和精度问题，还有题目中的数据的取值范围。]]></content>
      <categories>
        <category>题解(未分类)</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[春风十里，不如绿你小游戏]]></title>
    <url>%2F2017%2F08%2F29%2Fdemo%2F%E6%98%A5%E9%A3%8E%E5%8D%81%E9%87%8C%EF%BC%8C%E4%B8%8D%E5%A6%82%E7%BB%BF%E4%BD%A0%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[开始游戏]]></content>
      <categories>
        <category>Demo</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH2框架整合--实现登录]]></title>
    <url>%2F2017%2F08%2F17%2Fssh2%2FSSH2%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88--%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[知识点回顾 开始整合（使用Maven）使用Maven新建一个项目:（关于Eclipse中使用Maven可参看这篇文章）新建好一个空的Maven项目结构是这样的 接下来你需要在pom.xml中配置项目需要的jar包，eclipse会为你下载，以后开发时，你可以(到Maven的官网查找需要的包进行下载)pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com&lt;/groupId&gt; &lt;artifactId&gt;SSH2LoginDemo&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;SSH2LoginDemo Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;!-- 导入junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 导入基本的javax.servlet --&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入Mysql的连接驱动包 --&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;6.0.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.struts/struts2-spring-plugin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-spring-plugin&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- http://projects.spring.io/spring-framework/ --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- http://projects.spring.io/spring-framework/ --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-orm --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;5.2.9.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.javassist/javassist --&gt; &lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.22.0-CR1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- druid连接池 --&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.26&lt;/version&gt; &lt;/dependency&gt; &lt;!-- j2ee的注解 --&gt; &lt;!-- https://mvnrepository.com/artifact/javax.annotation/javax.annotation-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;SSH2LoginDemo&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 新建四个文件放在src/main/resource中- applicationContext.xml（配置spring） - jdbc.properties（数据库连接的属性文件） - log4j.properties（日志记录属性文件） - struts.xml（struts2的配置文件） 先写上日志记录需要的属性文件，其他三个文件具体内容在编码时给出log4j.properties 123456789101112### direct log messages to stdout ###log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### direct messages to file mylog.log ###log4j.appender.file=org.apache.log4j.FileAppenderlog4j.appender.file.File=D:\mylog.loglog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### set log levels - for more verbose logging change &apos;info&apos; to &apos;debug&apos; ###log4j.rootLogger=warn, stdout 之后你需要在src/main/webapp/WEB-INF/web.xml中添加Spring的核心监听器和Struts2的过滤器web.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt; &lt;display-name&gt;SSH2LoginDemo&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- needed for ContextLoaderListener --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Bootstraps the root web application context before servlet initialization --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置struts2拦截器-核心过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; 具体编码前，我们先创建包和文件结构，结构图如下： 开始编码：一. 视图层(登录：login.jsp ，登录成功：loginSuccess.jsp ，登录失败：回到login.jsp) login.jsp12345678910111213141516171819&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@taglib prefix="s" uri="/struts-tags" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 如果登录失败，显示登录失败信息 --&gt; &lt;h1&gt;&lt;s:property value="fieldErrors.loginFail"/&gt;&lt;/h1&gt; &lt;form action="user_login" method="post"&gt; 用户名：&lt;input type="text" name="username"&gt; 密码：&lt;input type="password" name="password"&gt; &lt;input type="submit" value="登录"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; loginSuccess.jsp 123456789101112131415&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib prefix="s" uri="/struts-tags" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;登录成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 欢迎消息，显示登陆用户的用户名 --&gt; &lt;h1&gt;欢迎你:&lt;s:property value="username"/&gt;&lt;/h1&gt; &lt;s:debug&gt;&lt;/s:debug&gt;&lt;/body&gt;&lt;/html&gt; 二.控制层(UserAction)，通过Struts.xml配置请求的ActionStruts.xml 12345678910111213141516171819&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN" "http://struts.apache.org/dtds/struts-2.5.dtd"&gt;&lt;struts&gt; &lt;!-- 开发模式 --&gt; &lt;constant name="struts.devMode" value="true"&gt;&lt;/constant&gt; &lt;!-- action的配置 --&gt; &lt;package name="ssh" namespace="/" extends="struts-default"&gt; &lt;!-- 为了安全起见，Struts2对Action中可执行的方法进行了声明，此处声明为全部 --&gt; &lt;global-allowed-methods&gt;regex:.*&lt;/global-allowed-methods&gt; &lt;!-- 匹配方法，Action交给了Spring管理，所以class属性这样写 --&gt; &lt;action name="user_*" class="userAction" method="&#123;1&#125;"&gt; &lt;!-- 成功跳转到登录成功页面 --&gt; &lt;result name="success"&gt;/loginSuccess.jsp&lt;/result&gt; &lt;!-- 失败回到登录页面 --&gt; &lt;result name="error"&gt;/login.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; UserAction.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.action;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Controller;import com.domain.User;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ModelDriven;import com.service.UserService;/** * 控制层继承ActionSupport,实现模型驱动 * @author 何军 * */@Controller // 该注解告诉Spring这是一个控制器类型的Component@Scope("prototype") // 把Action交给Spring管理，默认是单例的，该注解指定为Action多例public class UserAction extends ActionSupport implements ModelDriven&lt;User&gt;&#123; // 实现模型驱动需要new一个实体类的对象，通过getModel返回 private User user = new User(); // 自动装载UserService对象 @Autowired private UserService userService; // 返回模型user对象 public User getModel() &#123; return user; &#125; // 登录方法 public String login() &#123; // 调用Service层的方法得到用户 User existUser = userService.login(user); // 如果没有得到用户 if (existUser == null) &#123; // 加入错误提示信息 this.addFieldError("loginFail", "用户名或者密码错误"); return ERROR; &#125; else &#123; // 登录成功，将用户信息压入栈中 ActionContext.getContext().getValueStack().push(existUser); return SUCCESS; &#125; &#125;&#125; 三.业务逻辑层(UserService)，UserServiceImpl实现UserService中的方法UserService.java 123456789package com.service;import com.domain.User;public interface UserService &#123; User login(User user);&#125; UserServiceImpl.java 1234567891011121314151617181920212223package com.service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.dao.UserDao;import com.domain.User;import com.service.UserService;// 该注解说明这是一个Service类型的Commpent@Service public class UserServiceImpl implements UserService&#123; // 自动装载UserDao @Autowired private UserDao userDao; public User login(User user) &#123; // 通过用户名和密码查找用户 User existUser = userDao.findUserByUsernamAndPassword(user); return existUse; &#125;&#125; 四.数据库操作层(UserDao)，UserDaoImpl实现UserDao中的方法UserDao.java 123456789package com.dao;import com.domain.User;public interface UserDao &#123; User findUserByUsernamAndPassword(User user);&#125; UserDaoImpl.java 12345678910111213141516171819202122232425262728293031package com.dao.impl;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.orm.hibernate5.HibernateTemplate;import org.springframework.stereotype.Repository;import com.dao.UserDao;import com.domain.User;// Dao层@Repositorypublic class UserDaoImpl implements UserDao&#123; // 自动装配hibernateTemplate,这个Bean需要在applicationContext.xml中注册 @Autowired private HibernateTemplate hibernateTemplate; public User findUserByUsernamAndPassword(User user) &#123; // hql语句 String hql = "from User where username=? and password=?"; // 查找对象 List&lt;User&gt; users = (List&lt;User&gt;) hibernateTemplate.find(hql, user.getUsername(), user.getPassword()); if (users.size() &gt; 0) &#123; // 查找到的对象用户名和密码唯一，所以如果找到的话，List中的第一个对象就是要找的对象 return users.get(0); &#125; return null; &#125;&#125; 五.实体层（User）User.java 12345678910111213141516171819202122232425262728293031323334353637383940package com.domain;import java.io.Serializable;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table;// 声明实体类映射@Entity@Table(name="User")public class User implements Serializable&#123; private Integer id; // id private String username; // 用户名 private String password; // 密码 // 主键 @Id @GeneratedValue(strategy=GenerationType.AUTO) // 主键生成策略 public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; 六.建立数据库关联在数据库中创建一个名字为_ssh的数据库jjdbc.properties 1234567891011121314151617jdbc.driver=com.mysql.cj.jdbc.Driver#\u5B9A\u4E49\u8FDE\u63A5\u7684URL\u5730\u5740\uFF0C\u8BBE\u7F6E\u7F16\u7801\u96C6\uFF0C\u65F6\u95F4\u57DF\uFF0C\u5141\u8BB8\u591A\u6761SQL\u8BED\u53E5\u64CD\u4F5C\u0153jdbc.url=jdbc:mysql://localhost:3306/_ssh?characterEncoding=utf-8&amp;serverTimezone=UTC&amp;allowMultiQueries=true#jdbc:mysql://localhost:3306/thcardb?characterEncoding=utf-8&amp;serverTimezone=UTC&amp;allowMultiQueries=truejdbc.username=root#jdbc.password=asd123asdjdbc.password=123#\u5B9A\u4E49\u521D\u59CB\u8FDE\u63A5\u6570initialSize=0#\u5B9A\u4E49\u6700\u5927\u8FDE\u63A5\u6570maxActive=20#\u5B9A\u4E49\u6700\u5927\u7A7A\u95F2maxIdle=20#\u5B9A\u4E49\u6700\u5C0F\u7A7A\u95F2minIdle=1#\u5B9A\u4E49\u6700\u957F\u7B49\u5F85\u65F6\u95F4maxWait=60000 将数据库相关的全部配置作为Bean交给Spring处理，applicationContext.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd"&gt; &lt;!-- 自动扫描包下面的Bean --&gt; &lt;context:component-scan base-package="com"/&gt; &lt;!-- 加载jdbc的属性文件 --&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="location" value="classpath:jdbc.properties" /&gt; &lt;/bean&gt; &lt;!-- druid配置数据源 --&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;!-- &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"&gt;&lt;/property&gt; --&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置SessionFactory --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt; &lt;!-- 配置数据源 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 其它hibernate配置 --&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.MySQL5Dialect&lt;/prop&gt; &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.format_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt; &lt;prop key="javax.persistence.validation.mode"&gt;none&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name="packagesToScan" value="com.domain"/&gt; &lt;/bean&gt; &lt;!-- 注册hibernateTemplate这个Bean --&gt; &lt;bean id="hibernateTemplate" class="org.springframework.orm.hibernate5.HibernateTemplate"&gt; &lt;property name="sessionFactory" ref="sessionFactory" /&gt; &lt;/bean&gt; &lt;/beans&gt; 测试： 启动，自动生成了表 在数据库中加一条数据 输入错误的用户名密码测试 输入正确的用户名密码测试 总结：MVC思想是贯穿WEB开发的，回想自己当初刚刚接触WEB开发时，学习thinkphp5框架一脸懵。当时刚刚大一结束，对编程的接触就是用C语言完成了一个通讯录管理程序。用C语言实现了简单的增删改查。接触WEB开发，先学html+css，学得不怎么样，连盒子模型都没有理解透，就开始接触Boostrap框架。后来隔了一个寒假，回去开始学习thinkphp5，连框架的概念都没有的我每天学习十分得痛苦。现在，离我离开实验室应该是4个月。我自己从零开始接触了java，四个月时间，我的进步还是可观的，回想大学这一年，发生的事情真的好多。]]></content>
      <categories>
        <category>ssh2</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>hibernate</tag>
        <tag>struts2</tag>
        <tag>ssh2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Boostrap]]></title>
    <url>%2F2017%2F08%2F13%2Fweb%E5%89%8D%E7%AB%AF%2FBoostrap%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[一.响应式布局—查看Demo1.响应式布局的设计原则- 移动优先 在设计的初期就要考虑页面如何在多终端显示 - 渐进增强 充分发挥硬件设备的最大功能 2.头部声明 栅格系统进行响应式开发,头部设置响应的viewport 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;&gt; 3.网页开发中的单位： px px是相对于屏幕分辨率，大小无法跟随屏幕的放大和缩小，所有浏览器都支持 em 1em=16px(但不完全是,每个浏览器不一样)，em会继承父级元素的字体大小，IE部分浏览器不支持em rem rem和em类似,rem会继承根元素的字体大小，html{font-size:62.5%}(稳定)]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>boostrap</tag>
        <tag>响应式布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页制作的总结]]></title>
    <url>%2F2017%2F08%2F13%2Fweb%E5%89%8D%E7%AB%AF%2Fhtml%2Bcss%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一. 盒子模型 在css中，width和height指的是内容区域的宽度和高度，增加内边距，边框和外边距不会影响内容区域的尺寸，但是会增加元素框的尺寸。 二.清除浮动，清除默认样式12345678910111213```` /*清除默认样式*/body&#123; margin: 0px; padding: 0px;&#125;/*清除浮动*/.clearfix &#123; zoom: 1; display: table;&#125;```` 三.使用float应该注意 float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。注释：假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止。 注意，图片本身有高度和宽度。其他浮动元素会碰到它的边框停下。 这就是文字环绕图片的原理。 浮动会让元素塌陷。即被浮动元素的父元素不具有高度。例如一个父元素包含了浮动元素，它将塌陷具有零高度。你可以按以下方法处理： 在浮动元素后加个div设置clear: both; height:0,overflow:hidden 使用clearfix; 设置父元素浮动; 四.制作弹出层 需要的知识点： 定位：absolute,relative,fixed 事件：onload,onclick DOM操作：getElementById(),scrollHeight(),clientHeight(),createElement(),appendChild(),removeChild().静止定位：相对与当前状态的屏幕静止。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax+servlet实现百度智能提示搜索框--来自慕课课程]]></title>
    <url>%2F2017%2F08%2F08%2Fweb%E5%89%8D%E7%AB%AF%2Fajax%2Bservlet%E5%AE%9E%E7%8E%B0%E7%99%BE%E5%BA%A6%E6%99%BA%E8%83%BD%E6%8F%90%E7%A4%BA%E6%90%9C%E7%B4%A2%E6%A1%86--%E6%9D%A5%E8%87%AA%E6%85%95%E8%AF%BE%E8%AF%BE%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[查看Demo12345/** * @author xiaohejun * Man Always Remember Love Because of Romance Only. * */ 一.实现效果： 1.serach.jsp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;搜索&lt;/title&gt; &lt;style type="text/css"&gt; #myDiv &#123; position:absolute; left: 50%; top: 50%; margin-left: -200px; margin-top: -50px; &#125; .mouseOver&#123; background: #708090; color: #FFFAFA; &#125; .mouseOut&#123; background: #FFFAFA; color: #000000; &#125; &lt;/style&gt; &lt;script type="text/javascript"&gt; var xmlHttp; /*获得用户关联信息*/ function getMoreContents() &#123; // 首先获得用户输入 var content = document.getElementById("keyword"); if(content.value == "")&#123; return; &#125; // 然后给服务器发送用户输入类容，用ajax异步发送请求，获得一个对象，骄傲做xmlHttp xmlHttp = createXmlHttp(); // 要给服务器发送数据,escape()方法对字符串进行编码 var url="search?keyword=" + decodeURI(content.value); // 和服务器建立链接,true参数表示javascript脚本会在send()方法之后继续执行，而且不会等待来自服务器的响应 xmlHttp.open("GET",url); // 绑定一个回调方法，这个会调方法会在xmlHttp状态改变0-4，我们只关心4（complete）这个状态，完成之后，调用回调方法 xmlHttp.onreadystatechange=callback; xmlHttp.send(null); &#125; // 清空之前的数据 function clearContent() &#123; var tbody = document.getElementById("content_table_body"); var size = tbody.childNodes.length; for (var i = size-1; i &gt;= 0;i--) &#123; tbody.removeChild(tbody.childNodes[i]); &#125; document.getElementById("popDiv").style.border = "none"; &#125; //回调函数 function callback() &#123; if(xmlHttp.readyState==4)&#123; // 服务器响应成功 if(xmlHttp.status==200)&#123; // 交互成功，获得响应数据 var result = xmlHttp.responseText; // 解析成JSON格式 var json = eval("("+result+")"); // 获得数据之后，就可以动态显示这些数据，把这些数据展示到输入框的下面 setContent(json); &#125; &#125; &#125; // 设置关联数据的展示 function setContent(contents) &#123; clearContent(); setLocation(); var size = contents.length; for (var i = 0; i &lt; size; i++) &#123; var nextNode = contents[i]; var tr = document.createElement("tr"); var td = document.createElement("td"); td.setAttribute("border","0"); td.bgColor = "white"; td.onmouseover = function () &#123; this.className = 'mouseOver'; &#125;; td.onmouseout = function () &#123; this.className = 'mouseOut'; &#125; td.onmousedown = function() &#123; document.getElementById("keyword").value = this.innerHTML; &#125; var text = document.createTextNode(nextNode); td.appendChild(text); tr.appendChild(td); document.getElementById('content_table_body').appendChild(tr); &#125; &#125; // 获得xmlHttp对象 function createXmlHttp() &#123; // 对于大多数浏览器适用的 var xmlHttp; if (window.XMLHttpRequest) &#123; xmlHttp = new XMLHttpRequest(); &#125; // 要考虑浏览器的兼容 if (window.ActiveXObiect) &#123; xmlHttp = new ActiveXObiect("Microsoft.XMLHTTP"); if (!xmlHttp) &#123; xmlHttp = new ActiveXObiect("Msxml2.XMLHTTP"); &#125; &#125; return xmlHttp; &#125; function keywordBlur() &#123; clearContent(); &#125; // 设置显示的位置 function setLocation() &#123; // 关联信息的显示位置要和输入框一致 var content = document.getElementById("keyword"); // 输入框的宽度 var width = content.offsetWidth; // 到左边框的距离 var left = content["offsetLeft"]; // 到顶部的距离 var top = content["offsetTop"] + content.offsetHeight; // 获得显示数据的div var popDiv = document.getElementById("popDiv"); popDiv.style.border = "black 1px solid"; popDiv.style.left = left + "px"; popDiv.style.top = top + "px"; popDiv.style.width = width + "px"; document.getElementById("content_table").style.width = width + "px"; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="myDiv"&gt; &lt;!-- 输入框 --&gt; &lt;input type="text" size="50" id="keyword" onkeyup="getMoreContents()" onblur="keywordBlur()" onfocus="getMoreContents()"/&gt; &lt;input type="button" value="百度一下" width="50px"/&gt; &lt;!-- 内容展示的区域 --&gt; &lt;div id="popDiv"&gt; &lt;table id="content_table" bgcolor="#FFFAFA" border="0" cellspacing="0" cellpadding="0"&gt; &lt;tbody id="content_table_body"&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2.SearchServlet.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.servlet;import java.io.IOException;import java.util.ArrayList;import java.util.List;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import net.sf.json.JSONArray;/** * Servlet implementation class search */@WebServlet("/search")public class SearchServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; private static List&lt;String&gt; datas; /** * @see HttpServlet#HttpServlet() */ public SearchServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ static &#123; datas = new ArrayList&lt;String&gt;(); datas.add("ajax"); datas.add("ajax post"); datas.add("b啊哈"); datas.add("b哈"); datas.add("这是ajax"); datas.add("你全家都是ajax"); &#125; public List&lt;String&gt; getData(String keyword) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (String data : datas) &#123; if (data.contains(keyword)) &#123; list.add(data); &#125; &#125; return list; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException&#123; response.setCharacterEncoding("UTF-8"); request.setCharacterEncoding("UTF-8");; String keyword = request.getParameter("keyword"); List&lt;String&gt; listData = getData(keyword); response.getWriter().write(JSONArray.fromObject(listData).toString()); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doGet(request, response); &#125;&#125; 注意：不可以使用escape()函数编码，已经过时]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery+原生的javascript实现网站右侧导航定位--来自慕课课程]]></title>
    <url>%2F2017%2F08%2F08%2Fweb%E5%89%8D%E7%AB%AF%2Fjquery%2B%E5%8E%9F%E7%94%9F%E7%9A%84javascript%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%AB%99%E5%8F%B3%E4%BE%A7%E5%AF%BC%E8%88%AA%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[12345/** * @author xiaohejun * Man Always Remember Love Because of Romance Only. * */ 先看效果 demo的文件结构图你需要下载Jqueryjquery-3.2.1.js-jQuery+原生的javascript实现导航 -css -demo.css -js -demo.js -jquery-3.2.1.js -images -1.png -2.jpg -3.jpg -4.png -5.png -demo.html 界面原型demo.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;购物网站&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="css/demo.css"&gt; &lt;script src="js/jquery-3.2.1.js" rel="script"&gt;&lt;/script&gt; &lt;script src="js/demo.js" rel="script"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 菜单 --&gt; &lt;div id="menu"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#item1" class="current"&gt;1F 一楼&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#item2"&gt;2F 二楼&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#item3"&gt;3F 三楼&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#item4"&gt;4F 四楼&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#item5"&gt;5F 五楼&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="content"&gt; &lt;h1&gt;天狗购物&lt;/h1&gt; &lt;div id="item1" class="item"&gt; &lt;h2&gt;1F 男装&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="item2" class="item"&gt; &lt;h2&gt;2F 女装&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="item3" class="item"&gt; &lt;h2&gt;3F 美妆&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="item4" class="item"&gt; &lt;h2&gt;4F 数码&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="item5" class="item"&gt; &lt;h2&gt;5F 母婴&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ##样式css/demo.css1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677* &#123; margin:0px; padding: 0px;&#125;body &#123; font-size: 12px; line-height: 1.7;&#125;li &#123; list-style: none;&#125;#content &#123; width: 800px; margin: 0 auto; padding: 20px;&#125;#content h1 &#123; color: red;&#125;#content .item &#123; padding: 20px; margin-bottom: 20px; border: 1px dotted red;&#125;#content .item h2 &#123; font-size: 16px; font-weight: bold; border-bottom: 2px solid red; margin-bottom: 10px;&#125;#content .item li&#123; display: inline; margin-right: 10px;&#125;#content .item li a img &#123; width: 230px; height: 230px; border: none;&#125;#menu &#123; position: fixed; top: 100px; left: 50%; margin-left: 400px; width: 80px;&#125;#menu ul li a&#123; display: block; margin: 5px 0; font-size: 14px; font-weight: bold; color: #333; width: 80px; height:50px; line-height: 50px; text-decoration: none; text-align:center;&#125;#menu ul li a:hover,#menu ul li a.current&#123; color: #ffffff; background: red;&#125; 动作操作js/demo.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * Created by 何军 on 2017/8/7. * 使用jquery */$(document).ready(function () &#123; // 滚动条发生滚动 $(window).scroll(function () &#123; // 滚动挑距离顶部的距离 var top = $(document).scrollTop(); // 获取menu var menu = $("#menu"); // 获取每一个框 var items = $("#content").find(".item"); var currentId = ""; // 当前的id items.each(function () &#123; // 遍历每一个item var m = $(this); // 取得当前对象 var itemTop = m.offset().top; // 获得当前item的距离顶位置 if(top &gt; itemTop-200)&#123; // 如果用户滚动的距离比当前item的距离顶部位置少200px currentId = "#" + m.attr("id"); // 设置currentId 为当前id &#125; else &#123; return false; // 过头了。直接返回false退出循环 &#125; &#125;); var currentLink = menu.find(".current"); // 找到class是current的导航。初始是item1 if(currentId &amp;&amp; currentLink.attr("href") !== currentId)&#123; // 如果currentId不是空并且当前导航的href不是当前的id currentLink.removeClass("current"); // 移走current的Class // 注意此处查找方法的字符串拼接。currentId要用引号 menu.find("[href=\"" + currentId +"\"]").addClass("current"); // 找到currentId的导航加上current的class &#125; &#125;); &#125;);/*// 使用原生的jswindow.onload = function () &#123; window.onscroll = function () &#123; var top = document.documentElement ? document.documentElement.scrollTop : document.body.scrollTop; var menus = document.getElementById("menu").getElementsByTagName("a"); var items = getByClassName(document.getElementById("content"), "item"); var currentId = ""; for(var i =0; i &lt; items.length; i++) &#123; var _item = items[i]; var _itemTop = _item.offsetTop; if (top &gt; _itemTop - 200) &#123; currentId = _item.id; &#125; else &#123; break; &#125; &#125; if(currentId) &#123; // 给正确的menu的a元素current赋值 for (var i = 0; i &lt; menus.length; i++) &#123; var _menu = menus[i]; var _href = _menu.href.split("#"); if (_href[_href.length-1] !== currentId) &#123; console.log(_href[_href.length-1]); removeClass(_menu, "current"); &#125; else &#123; addClass(_menu, "current"); &#125; &#125; &#125; &#125;&#125;function getByClassName(obj,cls) &#123; var elements = obj.getElementsByTagName("*"); var result = []; for (var i=0; i &lt; elements.length; i++) &#123; if(elements[i].className === cls) &#123; result.push(elements[i]); &#125; &#125; return result;&#125;function hasClass(obj, cls) &#123; return obj.className.match(new RegExp("(\\s|^)" + cls + "(\\s|$)"));&#125;function removeClass(obj, cls) &#123; if (hasClass( obj, cls)) &#123; var reg = new RegExp("(\\s|^)" + cls + "(\\s|$)"); console.log("cls="); console.log(cls); obj.className = obj.className.replace(reg," "); &#125;&#125;function addClass(obj, cls) &#123; if (!hasClass(obj, cls)) &#123; obj.className += " " + cls; &#125;&#125;*/]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>jquery</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
