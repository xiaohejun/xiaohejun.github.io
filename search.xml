<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Wannafly挑战赛26]]></title>
    <url>%2F2018%2F10%2F13%2FACM%E9%A2%98%E7%9B%AE%2FWannafly%E6%8C%91%E6%88%98%E8%B5%9B26%2F</url>
    <content type="text"><![CDATA[Wannafly挑战赛26 emm.现在本来还是比赛时间.但是只搞出A题的我.指向写个博客然后去写项目.orz A. 御坂网络 ACWA 三次是因为.1.代码确实写错 2. 算n-1个点到这个点的距离去了. 3. emm.想到了正确的算法.但是应该输出没有换行.然后想想算距离是double.有精度损失呀.换种方式吧.就过了. 题目大意:平面坐标中有$n$个点.是否可以选择一个点作为圆心.其他$n-1$个点在这个圆上. 题解:圆的方程： $ (x - a) + (y - b) = r^2$所以只要$O(n^2)$暴力匹配这个方程就行. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define MAX_N 1100int n;struct Point&#123; LL x,y;&#125;p[MAX_N];LL d[MAX_N][MAX_N];LL dis(Point a, Point b)&#123; return (a.x - b.x)*(a.x - b.x)*1LL + (a.y - b.y) * (a.y - b.y)*1LL;&#125;int main()&#123; // freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n; for(int i = 0; i &lt; n; ++i)&#123; cin &gt;&gt; p[i].x &gt;&gt; p[i].y; &#125; for(int i = 0; i &lt; n; ++i)&#123; for(int j = 0; j &lt; n; ++j)&#123; if(i == j) continue; d[i][j] = dis(p[j], p[i]); &#125; &#125; for(int i = 0; i &lt; n; ++i)&#123; LL ans; ans = (i == 0) ? d[i][1] : d[i][0]; int j; for(j = 0; j &lt; n; ++j)&#123; if(j == i) continue; if(ans != d[i][j]) break; &#125; if(j == n) &#123; cout &lt;&lt; i+1; return 0; &#125; &#125; cout &lt;&lt; "-1"; return 0;&#125;]]></content>
      <categories>
        <category>ACM题目</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典训练指南打卡day1]]></title>
    <url>%2F2018%2F10%2F10%2F%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E8%AE%AD%E7%BB%83%E6%8C%87%E5%8D%97%2F%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E8%AE%AD%E7%BB%83%E6%8C%87%E5%8D%97%E6%89%93%E5%8D%A1day1%2F</url>
    <content type="text"><![CDATA[emm.最近有点小烦躁.今年还只能打两场了.青岛和沈阳.想要拿牌子.题目不知如何刷起.太多了呀.自己太菜了呀.所以来一个打卡系列吧.打卡刘汝佳&lt;&lt;算法竞赛 入门经典 训练指南&gt;&gt;. so. 打卡day1. Meteor UVALive - 3905题目大意:有一个矩形照相机.矩形照相机照到的范围是$(0,0)$到$(w,h)$.有$n$个流星.第i个流星的初始坐标$(x_i, y_i)$,速度$(a_i, b_i)$.所以.$t(t &gt;= 0)$时刻第$i$个流星的位置就是$(x_{ti}, y_{ti}) = (x_i, y_i) + t*(a_i, b_i).$求某一时刻矩形照相机最多可以照到的流星数量.(在边界上照到的不算) 题解:转换一下问题.每一个流星在矩形照相机中的时间段是确定的(如果可以进入矩形照相机).假设在这n个流星中有k个流星在一定时间段可以照到.第$i$个流星能照到的时间段是$(L_i, R_i) 1 \leq i \leq k. 1 \leq k \leq n.$所以我们只要求出这$k$个开区间的最大交集的数量.就是某一时刻最多有多少个区间有交集.假设我们已经计算出这k个开区间.考虑下面的算法: 每一个区间有两个端点.将每一个区间的左右端点分别看作一个事件.按照坐标优先级第一从小到大.坐标相同的按照右端点优先原则排序. 有一个扫描线.一个计数器cnt=0.答案保存ans=0.从小到大开始扫描事件.当遇到当前事件是左端点时.cnt加上1.更新ans取大.当遇到当前事件是右端点时.cnt减去1. 这样扫描完就得到答案.复杂度$O(log(n))$ 计算区间: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;int T;int w,h,n,a,b;struct Event&#123; double x; int type; // 0表示左端点.1表示右端点 bool operator&lt;(const Event&amp; b)const&#123; // 第一优先级.端点坐标从小到大.第二优先级.先处理右端点 return x &lt; b.x || (x == b.x &amp;&amp; type &gt; b.type); &#125;&#125;;// 计算到达边界的时间void update(int x, int a, int w, double &amp;L, double &amp;R)&#123; /* x + t1*a &gt; 0 x + t2*a &lt; w */ if(a == 0)&#123; if(x &lt;= 0 || x &gt;= w) R = L-1; // a是0.而且一开始就在外面 &#125; else if(a &gt; 0)&#123; L = max(L, -(double)x/a); R = min(R, (double)(w-x)/a); &#125; else &#123; L = max(L, (double)(w-x)/a); R = min(R, -(double)x/a); &#125;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int x,y; double L,R; cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; w &gt;&gt; h &gt;&gt; n; vector&lt;Event&gt; v; for(int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; a &gt;&gt; b; L = 0; R = 1e9; // 0 &lt; x+t*a &lt; w, 0 &lt; y+t*a &lt; h update(x, a, w, L, R); update(y, b, h, L, R); if(R &gt; L)&#123; // 区间成立 // 加入左右端点 v.push_back((Event)&#123;L, 0&#125;); v.push_back((Event)&#123;R, 1&#125;); &#125; &#125; sort(v.begin(), v.end()); // 排好序 int ans = 0; int cnt = 0; for(auto &amp;x : v)&#123; if(x.type == 0) &#123; ++cnt; // 左端点的时候加上 ans = max(ans, cnt); &#125; else --cnt; // 右端点的时候减去 &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛入门经典训练指南</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoderBeginnerContest112]]></title>
    <url>%2F2018%2F10%2F07%2FACM%E9%A2%98%E7%9B%AE%2F%20AtCoderBeginnerContest112%2F</url>
    <content type="text"><![CDATA[AtCoder Beginner Contest 112比赛链接 emm.第一次在AtCoder上的比赛. rank:754th rating:113. AC. WA.表示比赛时候的状态 A - Programming Education AC 题目大意: 输入1的时候输出”Hello World”. 输入2的时候会输入a,b.计算a+b. 题解: emm.入门操作.beginner出这个题还是很不错的.1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int kind,a,b; while(cin &gt;&gt; kind)&#123; if(kind == 1)&#123; cout &lt;&lt; "Hello World" &lt;&lt; endl; &#125; else &#123; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; (a+b) &lt;&lt; endl; &#125; &#125; return 0;&#125; B - Time Limit Exceeded AC 题目大意:给两个数N,T. N组数.每组两个数$c_i$和$t_i$.求所有不超过T的$t_i$中$c_i$的最小值. 题解: emm.入门操作.beginner出这个题还是很不错的. 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 105int N,T;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int c,t; while(cin &gt;&gt; N &gt;&gt; T)&#123; int ans = INT_MAX; for(int i = 1; i &lt;= N; ++i)&#123; cin &gt;&gt; c &gt;&gt; t; if(t &lt;= T) ans = min(ans, c); &#125; if(ans == INT_MAX) cout &lt;&lt; "TLE" &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; C - Pyramid WA ps: 到最后没做出这道题.想暴力.然后看到 The center coordinates and the height of the pyramid can be uniquely identified 这句话.理解成中心点的坐标和h可能是无穷的.orz应该是:可以唯一地识别金字塔的中心坐标和高度. by google translate 题目大意:有N个点.$(x_i, y_i,h_i)$. $h_i$表示这个点的高度.求一个点$(C_x, C_y, H)$满足.$h_i = max(H-|x_i - C_x| + |y_i - C_y|, 0)$. 题解:由于$0 &lt;= C_x, C_y &lt;= 100.$所以暴力即可. 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 110int n;int x[MAX_N], y[MAX_N], h[MAX_N];int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); while(cin &gt;&gt; n)&#123; for(int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; h[i]; if(h[i] &gt; 0) &#123; swap(h[i], h[1]); swap(x[i], x[1]); swap(y[i], y[1]); &#125; &#125; for(int cx = 0; cx &lt;= 100; ++cx)&#123; for(int cy = 0; cy &lt;= 100; ++cy)&#123; int ch = h[1] + abs(x[1] - cx) + abs(y[1] - cy); bool is = true; for(int i = 2; i &lt;= n; ++i)&#123; if(max(ch - abs(x[i] - cx) - abs(y[i] - cy), 0) != h[i]) &#123; is = false; break; &#125; &#125; if(is)&#123; cout &lt;&lt; cx &lt;&lt; " " &lt;&lt; cy &lt;&lt; " " &lt;&lt; ch &lt;&lt; endl; return 0; &#125; &#125; &#125; &#125; return 0;&#125; D - Partition AC 题目大意:两个数N,M.可以有多种方案找N个数之和是M.每种方案N个数的最大公约数是x.这多种方案中x最大$$ \sum_{i=1}^{N}a_i = M $$$$ ans = max(gcd(a_1, a_2,…,a_N))$$ 题解:可以确定.答案不超过M/N.如果答案是x.那么.这个N个数一定是x的倍数.所以只要从M/N到1枚举.第一个满足M每次减去x的k倍.最后如果M是0.说明当前x是答案.因为是从大到小枚举.所以第一个肯定是最大的. 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 105int N,M;bool can(int x)&#123; int m = M; m -= x; while(m &gt; 0 &amp;&amp; m/x)&#123; m -= (m/x * x); &#125; return m == 0;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); while(cin &gt;&gt; N &gt;&gt; M)&#123; for(int ans = M/N; ans &gt;= 1; --ans)&#123; if(can(ans)) &#123; cout &lt;&lt; ans &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM题目</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客集训派对day3]]></title>
    <url>%2F2018%2F10%2F04%2FACM%E9%A2%98%E7%9B%AE%2F%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E6%B4%BE%E5%AF%B9day3%2F</url>
    <content type="text"><![CDATA[原比赛链接emmm.国庆刷题狂欢,来自暑假ccpc-wannafly camp day 3的题目 A.Knight题目描述有一张无限大的棋盘，你要将马从(0,0)移到(n,m)。每一步中，如果马在(x,y)，你可以将它移动到(x+1,y+2),(x+1,y-2),(x-1,y+2),(x-1,y-2),(x+2,y+1),(x+2,y-1),(x-2,y+1)或(x-2,y-1)。你需要最小化移动步数。 输入描述:第一行一个整数t表示数据组数 (1≤ t≤ 1000)。每组数据一行两个整数n,m (|n|,|m|≤ 109)。 输出描述:每组数据输出一行一个整数表示最小步数。 示例1输入20 44 2输出22 不妨假设 x&gt;=y&gt;=0。当 x&lt;=2y 时，定义每一步的冗余值 wi=3-dx-dy，那么∑wi=∑(2-dx)=3步数-x-y，显然我们只需要最小化冗余值。我们先只用(+2,+1)(若 x 为奇数则加一步(+1,+2))走到(x,y’)，然后通过将(+2,+1)替换为 2 个(+1,+2)使得0&lt;=y-y’&lt;3。若 y-y’=0，则冗余值为 0，显然最小。若 y-y’=1，则将(+1,+2)替换为(+2,+1)和(-1,+2)或将 2 个(+2,+1)替换为(+1,+2),(+1,+2),(+2,-1)，冗余值为 2，显然最小。（此处需要特判(2,2)）若 y-y’=2，则加上(+2,+1)和(-2,+1)，冗余值为 4，由于不存在冗余值为 1的步，所以最小。当 x&gt;2y 时，定义每一步的冗余值 wi=2-dx，那么∑wi=∑(2-dx)=2步数-x，显然我们只需要最小化冗余值。我们先只使用(+2,+1)走到(2y,y)，然后用(+2,+1)和(+2,-1)走到(x’,y)使得 0&lt;=x-x’&lt;4。若 x-x’=0 则冗余值为 0，显然最小。若 x-x’=1 则将之前的(+2,+1)改为(+1,+2)和(+2,-1)，冗余值为 1，显然最小。（此处需要特判(1,0)）若 x-x’=2 则加上(+1,+2)和(+1,-2)，冗余值为 2，由 x/2+y 的奇偶性可知最小。若 x-x’=3 则加上(+2,+1),(+2,+1),(-1,-2)，冗余值为 3，由 x/2+y 的奇偶性可知最小。时间复杂度 O(t) 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll fun(ll x, ll y) &#123; if (x == 1 &amp;&amp; y == 0) &#123; return 3; &#125; if (x == 2 &amp;&amp; y == 2) &#123; return 4; &#125; ll delta = x - y; if (y&gt;delta) &#123; return delta - 2 * floor(((double)(delta-y)) / 3.0); &#125; else &#123; return delta - 2 * floor(((double)(delta-y)) / 4.0); &#125;&#125;int main()&#123; //freopen("in.txt", "r", stdin); int t; cin &gt;&gt; t; while (t--) &#123; ll x, y; cin &gt;&gt; x &gt;&gt; y; x = abs(x); y = abs(y); if (x &lt; y) &#123; swap(x, y); &#125; cout &lt;&lt; fun(x, y) &lt;&lt; endl; &#125; return 0;&#125; D. Shopping题目描述你要买n件物品，其中有一些是凳子。商场正在举行促销活动，如果购物车中有至少一个凳子，那么你可以半价购买这个购物车中最贵的一个物品。你有m辆购物车，请最小化你的花费。 输入描述:第一行一个整数t表示数据组数 (1 ≤ t ≤ 100)。每组数据第一行两个整数n,m (1 ≤ n,m ≤ 1000)，接下来n行每行两个整数ai,bi，分别表示第i件物品的价格以及它是否是凳子 (1 ≤ ai ≤ 105, 0 ≤ bi ≤ 1)。 输出描述:每组数据输出一行一个实数表示最小花费，保留一位小数。 示例1 输入25 11 02 13 14 05 05 101 02 13 14 05 0 输出12.510.5 显然可以将最贵的 min(m,凳子个数)个物品打折。时间复杂度 O(tn) 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std; int t;int n,m; int main()&#123; //freopen("in.txt", "r", stdin); scanf("%d", &amp;t); int a,b; while(t--)&#123; scanf("%d%d", &amp;n, &amp;m); vector&lt;int&gt; v; int cnt = 0; for(int i = 0; i &lt; n; ++i)&#123; scanf("%d%d", &amp;a, &amp;b); if(b == 1) ++cnt; v.push_back(a); &#125; sort(v.begin(), v.end()); double ans = 0.0; int sz = v.size(); m = min(m, cnt); for(int i = sz-1,j=1; i &gt;= 0; --i,++j)&#123; if(j &lt;= m) ans += v[i]/2.0; else ans += v[i]; &#125; printf("%.1lf\n", ans); &#125; return 0;&#125; H.Travel题目描述魔方国有n座城市，编号为。城市之间通过n-1条无向道路连接，形成一个树形结构。澜澜打算在魔方国进行m次旅游，每次游览至少一座城市。为了方便，每次旅游游览的城市必须是连通的。此外，澜澜希望游览所有城市恰好一次。澜澜想知道有多少种旅游方案满足条件，两个方案不同当且仅当存在某一次旅游游览了不同的城市。澜澜不会数数，所以只好让你来帮他数方案。 输入描述:第一行一个整数t表示数据组数 (1 ≤ t ≤ 100)。每组数据第一行两个整数n,m ，接下来n-1行每行两个整数ai,bi表示一条道路 (1≤ ai,bi≤ n)。 输出描述:每组数据输出一行一个整数表示方案数对109+7取模的结果。 示例1 输入23 11 21 33 21 21 3 输出14 把树分成 m 个连通块的方案数是 C(n-1,m-1)，乘上 m!就行了。时间复杂度 O(∑n) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL MOD = 1e9 + 7;#define MAX_N 100100LL f[MAX_N];void init()&#123; f[0] = f[1] = 1LL; for(int i = 2; i &lt; MAX_N; ++i) f[i] = i * f[i - 1] % MOD;&#125;LL powN(LL a, LL n)&#123; LL base = a, res = 1LL; while(n)&#123; if(n &amp; 1) res = res * base % MOD; base = base * base % MOD; n &gt;&gt;= 1; &#125; return res;&#125;LL inv(LL a, LL MOD)&#123; return powN(a, MOD - 2LL);&#125;LL C(LL n, LL m)&#123; if(m == 0) return 1; if(n &lt; 0 || n &lt; m) return 0; return (f[n] % MOD) * (inv(f[m], MOD) * inv(f[n - m], MOD) % MOD) % MOD;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(0); cin.tie(0); int t,a,b; LL n,m; cin &gt;&gt; t; init(); while(t--)&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n - 1; i++) cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; (C(n-1, m-1) * f[m]) % MOD&lt;&lt; endl; &#125; return 0;&#125; I.Metropolis题目描述魔方国有n座城市，编号为。城市之间通过n-1条无向道路连接，形成一个树形结构。在若干年之后，其中p座城市发展成了大都会，道路的数量也增加到了m条。大都会之间经常有贸易往来，因此，对于每座大都会，请你求出它到离它最近的其它大都会的距离。 输入描述:第一行三个整数n,m,p (1 ≤ n,m ≤ 2*105,2 ≤ p ≤ n)，第二行p个整数表示大都会的编号 (1≤ xi≤ n)。接下来m行每行三个整数ai,bi,li表示一条连接ai和bi，长度为li的道路 (1 ≤ ai,bi ≤ n,1 ≤ li ≤ 109)。保证图是连通的。 输出描述:输出一行p个整数，第i个整数表示xi的答案。示例1 输入5 6 32 4 51 2 41 3 11 4 11 5 42 3 13 4 3 输出3 3 5 把所有大都会设为源点跑多源最短路，记下每个点是由哪个源点扩展的。如果从源点 i 出发走到了一个由另一个源点 j 扩展到的点 k，那么从 i 出发经过 k 的最短距离肯定是 dis[i][j]，那么就没有必要继续走下去了。所以只要枚举所有两端由不同源点扩展的边更新答案就行了。时间复杂度 O((n+m)logn) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define MAX_N 200100const LL INF = 1e15;struct Edge&#123;int to; LL cost;&#125;;typedef pair&lt;LL, int&gt; P;int T;int n,m,k;int p[MAX_N];int is[MAX_N];LL d[MAX_N];LL ans[MAX_N];vector&lt;Edge&gt; G[MAX_N];void dijstra()&#123; for(int i = 1; i &lt;= n; ++i) d[i] = INF; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que; for(int i = 1; i &lt;= k; ++i)&#123; que.push(P(d[p[i]] = 0, p[i])); &#125; while(!que.empty())&#123; P p = que.top(); que.pop(); int v = p.second; if(p.first &gt; d[v]) continue; for(int i = 0; i &lt; G[v].size(); ++i)&#123; Edge e = G[v][i]; if(d[e.to] &gt; d[v] + e.cost)&#123; d[e.to] = d[v] + e.cost; is[e.to] = is[v]; // e.to是由v扩展的 que.push(P(d[e.to], e.to)); &#125; else if(is[v] != is[e.to])&#123; // 不同源点扩展的边 ans[is[v]] = min(ans[is[v]], d[v] + d[e.to] + e.cost); ans[is[e.to]] = min(ans[is[e.to]], d[v] + d[e.to] + e.cost); &#125; &#125; &#125;&#125;int main()&#123; //freopen("in.txt", "r", stdin); int u,v; LL c; scanf("%d%d", &amp;n, &amp;m); for(int i = 0; i &lt;= n; ++i) G[i].clear(); scanf("%d", &amp;k); for(int i = 1; i &lt;= k; ++i)&#123; scanf("%d", &amp;p[i]); ans[p[i]] = INF; is[p[i]] = p[i]; &#125; for(int i = 1; i &lt;= m; ++i)&#123; scanf("%d%d%lld", &amp;u, &amp;v, &amp;c); G[u].push_back((Edge)&#123;v, c&#125;); G[v].push_back((Edge)&#123;u, c&#125;); &#125; dijstra(); for(int i = 1; i &lt;= k; ++i)&#123; printf("%lld%c", ans[p[i]], "\n "[i &lt; k]); &#125; return 0;&#125; J. Graph Coloring I题目描述修修在黑板上画了一些无向连通图，他发现他可以将这些图的结点用两种颜色染色，满足相邻点不同色。澜澜不服气，在黑板上画了一个三个点的完全图。修修跟澜澜说，这个图我能找到一个简单奇环。澜澜又在黑板上画了一个n个点m条边的无向连通图。很可惜这不是一道数数题，修修做不出来了。澜澜非常得意，作为一位毒瘤出题人，有了好题当然要跟大家分享，于是他把这道题出给你做了。 输入描述:第一行两个整数n,m (1≤ n,m≤ 3*105)，接下来m行每行两个整数ai,bi表示一条边 (1≤ ai,bi≤ n)。保证图连通，并且不存在重边和自环。输出描述:如果你能把图二染色，第一行输出0，第二行输出n个整数表示每个点的颜色 (0≤ xi≤ 1)。如果有多种合法方案，你可以输出任意一种。如果你能找到一个简单奇环，第一行输出环长k，第二行输出k个整数表示环上结点编号 (1≤ yi≤ n)，你需要保证yi和yi+1之间有边，y1和yn之间有边。如果有多种合法方案，你可以输出任意一种。如果两种情况都是可行的，你只需要输出任意一种。如果两种情况都是不可行的，请输出一行一个整数-1。 示例1 输入3 21 21 3 输出00 1 1 示例2复制3 31 21 32 3 输出31 2 3 判一下是不是二分图就行了。时间复杂度 O(n+m) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 3*1e5+100;int color[MAX_N];vector&lt;int&gt; G[MAX_N];vector&lt;int&gt; p;int n,m;int s,e;bool dfs(int u, int c)&#123; color[u] = c; p.push_back(u); for(int i = 0; i &lt; G[u].size(); ++i)&#123; int v = G[u][i]; if(color[u] == color[v]) &#123;s = v, e = u;return false;&#125; if(!color[v])&#123; if(!dfs(v, 3 - c)) return false; &#125; &#125; p.erase(--p.end()); return true;&#125;int main()&#123; //freopen("in.txt", "r", stdin); scanf("%d%d", &amp;n, &amp;m); int u,v; for(int i = 1; i &lt;= m; ++i)&#123; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; memset(color, 0, sizeof(color)); if(dfs(1, 1))&#123; puts("0"); for(int i = 1; i&lt;= n; ++i)&#123; printf("%d%c", color[i]-1, "\n "[i &lt; n]); &#125; &#125; else &#123; int i = -1; int sz = p.size(); while(p[++i] != s); printf("%d\n", sz - i); for(;i &lt; sz; ++i)&#123; printf("%d%c", p[i], "\n "[i &lt; sz-1]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM题目</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018ccpc-wannafly-round]]></title>
    <url>%2F2018%2F08%2F03%2F%E6%97%A5%E8%AE%B0%2F2018ccpc-wannafly-round1%2F</url>
    <content type="text"><![CDATA[前言今天是训练营的第一天，早上去了一个大教室，上了一节”如何学习算法”的课,课上的最后一个初中cf橙名大佬上去互动来着.初中人家在打算法比赛,我初中的时候在干啥,难以回忆,差距呀!!!课上击鼓传花回答了一个问题”为什么学习算法”.我内心的答案是,”好玩,神奇,能赚钱”.还有听到一句话就是:”不怕学霸有多霸,就怕学霸放暑假”,好像是这样说的.作为菜鸡的自己瑟瑟发抖,自己被别人超越了很多个暑假. 比赛中午在酒店吃了自助餐之后,躺了一小会儿就去上次打省赛的机房去了,一开始比赛方的服务器没准备好,所以早上讲课的老师就在vj上开了一场练习赛,我A了一道暴力判断回文串的水题之后,大概就开始正赛了.值得一提的是,我们旁边坐了一个小学生!!!小学生!!!再次震惊,上次震惊是5月份的省赛,我真的以为小学生就能A签到题,最后发现虽然他是在教练指导下A的,但是他真的会写C语言代码.不得不说,别人家的小时候.正式打比赛.一看I题题目是最短路,然后那道题没有样例.然后第一手队友说dijkstra模板,我说给我&lt;&lt;挑战程序设计竞赛&gt;&gt;这本书,我A一个,最后发现不行,单源最短路径一次时间复杂度是O(|E|log|V|),但是它有Q组询问,Q有1e6这么大吧,E和V也是大概1e6.然后我去看榜单,A了一个签到G题,答案就是找出序列的最大的那个然后乘2.后面我就在做A,一开始以为是DP,后来贪心,后来写了贪心的代码,样列过了,队友的样例也过了,但是就是红的WA.~~最后题解是费用流,自己菜鸡,没有看费用流.其他题也是中等题没有做出来.难题就GG,想都不要想.我们队做出三个签到. 总结渐渐的成为一个ACMer,也大概一年了,从啥都不知道到现在.发现百度之星进决赛可以百度的校招绿色通道.还有美团的比赛.所以打比赛还是很不错的,如果可以靠打比赛进入一个好公司的话,就不想考研了,下一年的目标就是每天5道cf.然后坚持一年下来.加油吧!!!]]></content>
      <categories>
        <category>ACMer日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[M斐波那契数列]]></title>
    <url>%2F2018%2F03%2F25%2FACM%E9%A2%98%E7%9B%AE%2FM%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目传送门 Problem DescriptionM斐波那契数列F[n]是一种整数数列，它的定义如下： F[0] = aF1 = bF[n] = F[n-1] * F[n-2] ( n &gt; 1 ) 现在给出a, b, n，你能求出F[n]的值吗？ Input输入包含多组测试数据；每组数据占一行，包含3个整数a, b, n（ 0 &lt;= a, b, n &lt;= 10^9 ） Output对每组测试数据请输出一个整数F[n]，由于F[n]可能很大，你只需输出F[n]对1000000007取模后的值即可，每组数据输出一行。 Sample Input0 1 06 10 2 Sample Output060 题目解决题目分析: 注意到n的范围最大到10^9,所以简单的进行递推时间和空间上都无法处理到限制范围内. 这道题涉及到取余运算,所以我们应该知道取余运算的其中一个性质:$$(ab) \mod p = ((a \mod p) (b \mod p)) \mod p$$ 注意到该递推式和斐波那契数列有相似之处. 知识点:1.斐波那契数列的矩阵运算1.斐波那契数列$fib(0) = 0$$fib(1) = 1$$fib(n) = fib(n-1)+fib(n-2)$| n | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | … | … | n-1 | n || —–: | —–: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: || fib(n) | 0 | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 | 34 | 55 | 89 | 144 | 233 | 377 | … | … | fib(n-1) | fib(n) | 2.将斐波那契数列写到矩阵中1.考虑按照以下表达式构造n个矩阵:$$ A_{n} = \begin{bmatrix} fib(n) &amp; fib(n+1) \ fib(n+1) &amp; fib(n+2) \ \end{bmatrix}$$ 2.得到如下矩阵$A_{0} = \begin{bmatrix}0 &amp; 1 \1 &amp; 1 \ \end{bmatrix} $ &nbsp; $A_{1} = \begin{bmatrix}1 &amp; 1 \1 &amp; 2 \ \end{bmatrix} $ &nbsp; $ A_{2} = \begin{bmatrix}1 &amp; 2 \2 &amp; 3 \ \end{bmatrix} $ &nbsp; $A_{3} = \begin{bmatrix}2 &amp; 3 \3 &amp; 5 \ \end{bmatrix} $ &nbsp; $A_{4} = \begin{bmatrix}3 &amp; 5 \5 &amp; 8 \ \end{bmatrix} $ … &nbsp; … &nbsp; … $A_{n} = \begin{bmatrix}fib(n) &amp; fib(n+1) \ fib(n+1) &amp; fib(n+2) \ \end{bmatrix} $ 3.矩阵乘法运算$A_{1} = \begin{bmatrix}1 &amp; 1 \1 &amp; 2 \ \end{bmatrix} = A_{0}A_{0}$ &nbsp;&nbsp;&nbsp; $ A_{2} = \begin{bmatrix}1 &amp; 2 \2 &amp; 3 \ \end{bmatrix} = A_{0}A_{0}A_{0}$ &nbsp;&nbsp; $A_{3} = \begin{bmatrix}2 &amp; 3 \3 &amp; 5 \ \end{bmatrix} = A_{0}A_{0}A_{0}A_{0} $ $ A_{4} = \begin{bmatrix}3 &amp; 5 \5 &amp; 8 \ \end{bmatrix} = A_{0}A_{0}A_{0}A_{0}A_{0}$ &nbsp;&nbsp; $A_{n} = \begin{bmatrix}fib(n) &amp; fib(n+1) \fib(n+1) &amp; fib(n+2) \ \end{bmatrix} = A_{0} ^ {n+1}$ \begin{array}{|rrrrrrrr|}\hline\color{red}{综上所述,要想求解f(n),求得A(n)或者A(n-2)即可} &amp;\hline\end{array} 2.快速幂:Q:&nbsp;&nbsp;&nbsp;求解 $ x ^ N $A:&nbsp;&nbsp;&nbsp;O(N)的算法:1234ans = 1; for(i = 1; i &lt;= n; i++)&#123; ans *= x;&#125; A:&nbsp;&nbsp;&nbsp;O(logN)的算法: 将N转换成二进制表示形式 $$ N = 2 ^ {k_{1}} + 2 ^ {k_{2}} + 2 ^ {k_{3}} + …. + 2 ^ {k_{n}}$$ 要求解$x ^ N $,相当与计算$$ x ^ N = x ^ {2 ^ {k_{1}} + 2 ^ {k_{2}} + 2 ^ {k_{3}} + …. + 2 ^ {k_{n}}} = x^{2 ^ {k_{1}}}x^{2 ^ {k_{2}}}x^{2 ^ {k_{3}}}…x^{2 ^ {k_{n}}}$$ 所以只要在依次求$x ^ {2^i} $ 的同时进行计算就好了,最终得到了O(logN)的计算幂运算的算法 举个例子:计算 $ x ^ {22} $ 十进制下的22的二进制表示 : $ 22_{10} = 10110_{2}$ $ N = 22 = 2^{4} + 2^{2} + 2^{1}$ $ x^{22} = x^{2^{4} + 2^{2} + 2^{1}} = x^{16}x^{4}x^{2}$ 可以看到如果是O(N)的算法,当前例子需要计算22次,而O(logN)的算法只需要计算5次 \begin{array}{|rrrrrrrr|}\hline&amp; \color{red}{CODE:}&amp;\hline\end{array}123456789101112131415161718192021222324typedef long long LL;// 计算x^n,复杂度O(logN)LL powN(LL x, LL n)&#123; LL r = 1; // 计算结果 while(n)&#123; if(n&amp;1) r *= x; // 如果n的二进制表示i(i &gt;= 0)的位置是1,则乘上x^(2^i) x *= x; // 将x平方 n &gt;&gt;= 1; // 右移一位 &#125; return r; // 返回结果&#125;// 计算x^n mod p, ( a * b ) % p = ( ( a % p ) * ( b * p ) ) % p 复杂度O(logN)LL mod_powN(LL x, LL n, LL p)&#123; LL r = 1; // 计算结果 while(n)&#123; if(n&amp;1) r = r * x % p; // 如果n的二进制表示i(i &gt;= 0)的位置是1,则乘上x^(2^i) x = x * x % p; // 将x平方 n &gt;&gt;= 1; // 右移一位 &#125; return r; // 返回结果&#125; 3.费马小定理:费马小定理是数论中的一个定理：假如a是一个整数，p是一个质数，那么 $a^{p}-a$是p的倍数，可以表示为$$ a ^ p \equiv a (\mod p) $$如果a不是p的倍数，这个定理也可以写成$$ a ^ {p-1} \equiv 1 (\mod p)$$费马小定理是欧拉定理的一个特殊情况：如果n和a的最大公因数是1，那么$$ a^{φ(n)} \equiv 1 (\mod n) $$这里φ(n)是欧拉函数。欧拉函数的值是所有小于或等于n的正整数中与n互质的数的个数。假如n是一个素数（质数），则φ(n) = n-1，即费马小定理注: $\equiv$是同余符号 $ a \mod p = b \mod p$ 可表示为 $ a \equiv b (\mod p)$ 推导以下表达式:当p是质数时:$$ a ^ n \equiv a ^ {(n \mod (p-1))} (\mod p) $$成立 证:$$ n = k(p-1) + (n \mod (p-1)) (k为整数) $$$$ a ^ n \equiv a ^ {k(p-1) + (n \mod (p-1))} \equiv {a ^ {p-1}} ^ {k} a ^ {(n \mod (p-1))} (\mod p)$$由费马小定理可知:$$ {a ^ {p-1}} ^ {k} \equiv a ^ {p-1} \equiv 1(\mod p)$$得证:$$ a ^ n \equiv a ^ {(n \mod (p-1))} (\mod p) $$ 回到题目:1.分析我们注意到虽然题目中的M斐波那契数列和斐波那契数列有异曲同工之处,但是一个计算的是乘法,一个是加法,但加法和乘法之间有着密切的联系. 2.算一算先计算前几项的值:$$ f(0) = a = a ^ 1 b ^ 0 $$$$ f(1) = b = a ^ 0 b ^ 1 $$$$ f(2) = a b = a ^ 1 b ^ 1 $$$$ f(3) = a b b = a ^ 1 b ^ 2 $$$$ f(4) = a a b b b = a ^ 2 b ^ 3 $$$$ f(4) = a a a b b b b b= a ^ 3 b ^ 5 $$$$ ……………………………………………………..$$$$ f(n) = f(n-1)f(n-2) = a ^ x b ^ y $$|n| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 11 | 12 | 13 | … | … | n-1 | n ||——–| —–: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: ||x| 1 | 0 | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 | 34 | 55 | 89 | … | … | fib(n-2) | fib(n-1) ||y| 0 | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 | 34 | 55 | 89 | 144 | … | … | fib(n-1) | fib(n) | 不难得出:$$ f(0) = a $$$$ f(1) = b $$$$ f(n) = f(n-1)f(n-2) = a ^ {fib(n-1)} b ^ {fib(n)} (n &gt;= 2) $$ 通过上面费马小定理证明的结论,当p是质数时:$$ a ^ n \equiv a ^ {(n \mod (p-1))} (\mod p) $$所以我们实际上需要计算的就是下面的表达式(p = 1000000007):$$ f(n) \mod p= f(n-1)f(n-2) \mod p = a ^ {fib(n-1) \mod p-1} b ^ {fib(n) \mod p-1} \mod p(n &gt;= 2) $$ 1.计算类似于计算整数的快速幂算法计算矩阵的幂 $A_{n-1} = A_{0} ^ {n}$$A_{0} = \begin{bmatrix}0 &amp; 1 \1 &amp; 1 \ \end{bmatrix}$ &nbsp;&nbsp; $A_{n-1} = \begin{bmatrix}fib(n-1) &amp; fib(n) \fib(n) &amp; fib(n+1) \ \end{bmatrix} = A_{0} ^ {n}$ 计算矩阵的幂时,我们实际上需要得到的结果是:$$ A_{n-1} \mod p-1 = \begin{bmatrix}fib(n-1) \mod p-1 &amp; fib(n) \mod p-1 \fib(n) \mod p-1 &amp; fib(n+1) \mod p-1 \ \end{bmatrix} = (A_{0} \mod p-1) ^ {n} \mod p-1 $$ 如果理解了上面的快速幂算法的话,这实现起来将会非常简单 2.得到$fib(n-1) \mod p-1$ 和 $fib(n) \mod p-1$ 之后,设这两个数为x,y,用整数的快速幂算法计算:$$a ^ x b^y \mod p = (a ^ x \mod p b^y \mod p) \mod p$$ \begin{array}{|rrrrrrrr|}\hline&amp; \color{red}{CODE:}&amp;\hline\end{array} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MOD1 = 1e9+7; // pconst int MOD2 = 1e9+6; // p-1LL a,b,n;typedef struct Matrix&#123; // 矩阵结构体 LL arr[2][2];&#125;Matrix;Matrix unit = &#123; // 单位矩阵 1,0, 0,1&#125;;Matrix A0 = &#123; // A0矩阵 0,1, 1,1&#125;;// 矩阵a*bMatrix matrixMulti(Matrix a, Matrix b)&#123; int i,j,k; Matrix tmp; for(i = 0; i &lt; 2; i++)&#123; for(j = 0; j &lt; 2; j++)&#123; tmp.arr[i][j] = 0; for(k = 0; k &lt; 2; k++)&#123; tmp.arr[i][j] += (a.arr[i][k]*b.arr[k][j])%MOD2; tmp.arr[i][j] %= MOD2; &#125; &#125; &#125; return tmp;&#125;// 矩阵快速幂,计算的结果对MOD2取余Matrix matrixPow(Matrix a, LL n)&#123; Matrix r = unit, base = a; while(n)&#123; if(n&amp;1) r = matrixMulti(r,base); base = matrixMulti(base, base); n &gt;&gt;= 1; &#125; return r;&#125;// 整数快速幂,计算的结果对MOD1取余LL powN(LL a, LL n)&#123; LL r = 1, base = a%MOD1; while(n)&#123; if(n&amp;1) r = r*base%MOD1; base = base*base%MOD1; n &gt;&gt;= 1; &#125; return r;&#125;int main()&#123; //freopen("in.txt", "r", stdin); Matrix An_1; while(~scanf("%lld%lld%lld", &amp;a, &amp;b, &amp;n))&#123; // 输入a,b,n An_1 = matrixPow(A0,n); // 计算An_1 printf("%lld\n", powN(a, An_1.arr[0][0]) * powN(b, An_1.arr[1][0]) % MOD1); &#125; return 0;&#125; 思考:Q: 为什么要使用费马小定理?A: 因为 $ x \mod p-1 &lt;= x $ 所以可以减少计算整数幂时候的计算次数,不使用费马小定理会超时. 作者 @何军2018 年 03月 24日]]></content>
      <categories>
        <category>ACM题目</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[骰子作画]]></title>
    <url>%2F2018%2F03%2F17%2Fdemo%2F%E9%AA%B0%E5%AD%90%E4%BD%9C%E7%94%BB%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package Hebut_HappyBirthday;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import java.io.PrintStream;import java.lang.invoke.ConstantCallSite;import java.util.ArrayList;import javax.imageio.ImageIO;public class HebutHappyBirthday &#123; public BufferedImage hebutImg; public static int rgb2gray(int argb) &#123; int alpha = (argb &gt;&gt; 24) &amp; 0xFF; int red = (argb &gt;&gt; 16) &amp; 0xFF; int green = (argb &gt;&gt; 8) &amp; 0xFF; int blue = argb &amp; 0xFF; return (int)(0.3*red + 0.59*green + 0.11*blue); &#125; public static int sixStepGary(int x) &#123; int i; int c = 256/10; for(i = 0; i &lt;= 9; i++) &#123; if(i*c &lt; x &amp;&amp; x &lt;= (i+1)*c) return i; &#125; return 9; &#125; public static String getXChar(int x, int i) &#123; String str[] = new String[10]; str[0] = " "; str[1] = " 0"; str[2] = "0 0"; str[3] = "0 "; str[4] = "0 0"; str[5] = "000"; if(x == 0 || (x == 1 &amp;&amp; i != 2) || (x == 2 &amp;&amp; i == 2) || (x == 4 &amp;&amp; i == 2)) return str[0]; if((x == 2 &amp;&amp; i == 1) || (x == 3 &amp;&amp; i == 1)) return str[1]; if(i == 2 &amp;&amp; (x == 1 || x == 2 || x == 3 || x == 5)) return str[2]; if(i == 3 &amp;&amp; (x == 2 || x == 3)) return str[3]; if((x == 8 &amp;&amp; i == 2) || x == 6 || (x == 7 &amp;&amp; (i == 1 || i == 3)) || (x == 5 &amp;&amp; (i == 1 || i == 3)) || x == 4) return str[4]; if(x == 9 || (x == 8 &amp;&amp; (i == 1 || i == 3)) || (x == 7 &amp;&amp; i == 2)) return str[5]; return null; &#125; public HebutHappyBirthday() throws Exception &#123; hebutImg = ImageIO.read(new File("/media/hejun/新加卷/hebut520.jpg")); final int MAX_N = 10000; int i,j,k,l,ii,jj = 0,kk,ll,n = 1; int[][] rgb = new int[MAX_N][MAX_N]; int[][] ansrgb = new int[MAX_N][MAX_N]; int width = hebutImg.getWidth(); int height = hebutImg.getHeight(); int minx = hebutImg.getMinX(); int miny = hebutImg.getMinY(); //System.out.println(minx + " " + miny + " " + width + " " + height); for(i = minx; i &lt; height; i++) &#123; for(j = miny; j &lt; width; j++) &#123; rgb[i][j] = rgb2gray(hebutImg.getRGB(j, i));//获得像素值 &#125; &#125; int sum,count; for(i = minx, ii = 0; i &lt; height; i += n, ii++) &#123; for(j = miny, jj = 0; j &lt; width; j += n, jj++) &#123; sum = count = 0; for(k = i, kk = 0; kk &lt; n &amp;&amp; k &lt; height; k++, kk++) &#123; for(l = j, ll = 0; ll &lt; n &amp;&amp; l &lt; width; l++, ll++) &#123; sum += rgb[k][l]; count++; &#125; &#125; ansrgb[ii][jj] = sixStepGary(sum/count); &#125; &#125; String str; for(i = 0; i &lt; ii; i++) &#123; for(k = 1; k &lt;= 3; k++) &#123; str = ""; for(j = 0; j &lt; jj; j++) &#123; str += getXChar(ansrgb[i][j], k); &#125; System.out.println(str); &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; HebutHappyBirthday hebutHappyBirthday = new HebutHappyBirthday(); &#125;&#125;]]></content>
      <categories>
        <category>Demo</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学问题]]></title>
    <url>%2F2017%2F09%2F09%2FACM%E9%A2%98%E7%9B%AE%2F%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目地址 数学问题时间限制：2000/1000 MS（Java / Others）内存限制：32768/32768 K（Java / Others）总提交：1321接受提交：476 问题描述给定一个正整数n，请计算k个满足多少正整数 ķ^k≤ N。 输入没有超过50个测试用例。 每种情况只包含一行中的积分整数n。 1 ≤ N ≤ 1e18 产量对于每个测试用例，输出整数表示正整数k满足的数量 k^k≤ N 在一条线上。 样品输入14 样品输出12 错误答案：1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; // 正整数 long long n; int k = 1, sum = 0; while (scanf("%I64d", &amp;n) != EOF &amp;&amp; n &gt;= 1 &amp;&amp; n &lt;= 1e18) &#123; while (k &lt;= n) &#123; if (pow(k, k) &lt;= n) &#123; sum++; k++; &#125; else &#123; break; &#125; &#125; printf("%d\n", sum); sum = 0; k = 1; &#125; return 0;&#125; 正确答案：123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;long long a[20];void deal()&#123; for (int i = 1; i &lt;= 15; i++) // 计算k的k次方 &#123; long long result = 1; for (int j = 1; j &lt;= i; j++) &#123; result *= i; &#125; a[i] = result; &#125; a[16] = (long long)1e18 * 9; // 界限是1e18&#125;int main()&#123; deal(); long long n; while (cin &gt;&gt; n) &#123; for (int i = 1; i &lt;= 16; i++) &#123; if (a[i] &gt; n) &#123; cout &lt;&lt; i - 1 &lt;&lt; endl; break; &#125; &#125; &#125;&#125; 出错原因：1. 你会发现两种方法的最大不同： 第一种是每一次算出一个k的k次方来和n比较，使用pow()函数计算k的k次方 第二种是把k^k(1&lt;=k&lt;=15)放在一个数组中，并且在最后一个数中放a[16] = 1e18 * 9计算k的k次方的函数是自己写的 2. 第二种成功的方法为什么(1&lt;=k&lt;=15)，并且在数组下标16位放1e16*9： 15^15 = 437,893,890,380,859,375 ，一共18位，但是比1e18小 16^16 = 18,446,744,073,709,511,616 ，一共20位, 比1e18大 long long的最大值：9,223,372,036,854,775,807，一共19位 这样就确定了k的范围，并且解释了为什么在数组下标16位放1e16*9 当然你也可以这样写，只要最大的数字比1e18大就好 1a[16] = (long long)1e18 + 1; // 界限是1e18 但是这样不是最严谨，尽量放大一点是最严谨的 2. 重点要解释的问题，使用pow()函数为什么会出错： pow()函数返回的是double类型的数，使用pow()函数打印15的15次方你会发现： 再拿计算器计算 两个结果不一样，对比下面两张图你就会发现 当数字大到15^15时两个计算的结果就不同，所以这就导致了第一种方法出现错误答案的原因！ 总结：解题时注意关注数据类型的取值范围和精度问题，还有题目中的数据的取值范围。]]></content>
      <categories>
        <category>ACM题目</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[春风十里，不如绿你小游戏]]></title>
    <url>%2F2017%2F08%2F29%2Fdemo%2F%E6%98%A5%E9%A3%8E%E5%8D%81%E9%87%8C%EF%BC%8C%E4%B8%8D%E5%A6%82%E7%BB%BF%E4%BD%A0%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[开始游戏]]></content>
      <categories>
        <category>Demo</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH2框架整合--实现登录]]></title>
    <url>%2F2017%2F08%2F17%2Fssh2%2FSSH2%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88--%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[知识点回顾 开始整合（使用Maven）使用Maven新建一个项目:（关于Eclipse中使用Maven可参看这篇文章）新建好一个空的Maven项目结构是这样的 接下来你需要在pom.xml中配置项目需要的jar包，eclipse会为你下载，以后开发时，你可以(到Maven的官网查找需要的包进行下载)pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com&lt;/groupId&gt; &lt;artifactId&gt;SSH2LoginDemo&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;SSH2LoginDemo Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;!-- 导入junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 导入基本的javax.servlet --&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入Mysql的连接驱动包 --&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;6.0.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.struts/struts2-spring-plugin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-spring-plugin&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- http://projects.spring.io/spring-framework/ --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- http://projects.spring.io/spring-framework/ --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-orm --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;5.2.9.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.javassist/javassist --&gt; &lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.22.0-CR1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- druid连接池 --&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.26&lt;/version&gt; &lt;/dependency&gt; &lt;!-- j2ee的注解 --&gt; &lt;!-- https://mvnrepository.com/artifact/javax.annotation/javax.annotation-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;SSH2LoginDemo&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 新建四个文件放在src/main/resource中- applicationContext.xml（配置spring） - jdbc.properties（数据库连接的属性文件） - log4j.properties（日志记录属性文件） - struts.xml（struts2的配置文件） 先写上日志记录需要的属性文件，其他三个文件具体内容在编码时给出log4j.properties 123456789101112### direct log messages to stdout ###log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### direct messages to file mylog.log ###log4j.appender.file=org.apache.log4j.FileAppenderlog4j.appender.file.File=D:\mylog.loglog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### set log levels - for more verbose logging change &apos;info&apos; to &apos;debug&apos; ###log4j.rootLogger=warn, stdout 之后你需要在src/main/webapp/WEB-INF/web.xml中添加Spring的核心监听器和Struts2的过滤器web.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt; &lt;display-name&gt;SSH2LoginDemo&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- needed for ContextLoaderListener --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Bootstraps the root web application context before servlet initialization --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置struts2拦截器-核心过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; 具体编码前，我们先创建包和文件结构，结构图如下： 开始编码：一. 视图层(登录：login.jsp ，登录成功：loginSuccess.jsp ，登录失败：回到login.jsp) login.jsp12345678910111213141516171819&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@taglib prefix="s" uri="/struts-tags" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 如果登录失败，显示登录失败信息 --&gt; &lt;h1&gt;&lt;s:property value="fieldErrors.loginFail"/&gt;&lt;/h1&gt; &lt;form action="user_login" method="post"&gt; 用户名：&lt;input type="text" name="username"&gt; 密码：&lt;input type="password" name="password"&gt; &lt;input type="submit" value="登录"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; loginSuccess.jsp 123456789101112131415&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib prefix="s" uri="/struts-tags" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;登录成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 欢迎消息，显示登陆用户的用户名 --&gt; &lt;h1&gt;欢迎你:&lt;s:property value="username"/&gt;&lt;/h1&gt; &lt;s:debug&gt;&lt;/s:debug&gt;&lt;/body&gt;&lt;/html&gt; 二.控制层(UserAction)，通过Struts.xml配置请求的ActionStruts.xml 12345678910111213141516171819&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN" "http://struts.apache.org/dtds/struts-2.5.dtd"&gt;&lt;struts&gt; &lt;!-- 开发模式 --&gt; &lt;constant name="struts.devMode" value="true"&gt;&lt;/constant&gt; &lt;!-- action的配置 --&gt; &lt;package name="ssh" namespace="/" extends="struts-default"&gt; &lt;!-- 为了安全起见，Struts2对Action中可执行的方法进行了声明，此处声明为全部 --&gt; &lt;global-allowed-methods&gt;regex:.*&lt;/global-allowed-methods&gt; &lt;!-- 匹配方法，Action交给了Spring管理，所以class属性这样写 --&gt; &lt;action name="user_*" class="userAction" method="&#123;1&#125;"&gt; &lt;!-- 成功跳转到登录成功页面 --&gt; &lt;result name="success"&gt;/loginSuccess.jsp&lt;/result&gt; &lt;!-- 失败回到登录页面 --&gt; &lt;result name="error"&gt;/login.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; UserAction.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.action;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Controller;import com.domain.User;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ModelDriven;import com.service.UserService;/** * 控制层继承ActionSupport,实现模型驱动 * @author 何军 * */@Controller // 该注解告诉Spring这是一个控制器类型的Component@Scope("prototype") // 把Action交给Spring管理，默认是单例的，该注解指定为Action多例public class UserAction extends ActionSupport implements ModelDriven&lt;User&gt;&#123; // 实现模型驱动需要new一个实体类的对象，通过getModel返回 private User user = new User(); // 自动装载UserService对象 @Autowired private UserService userService; // 返回模型user对象 public User getModel() &#123; return user; &#125; // 登录方法 public String login() &#123; // 调用Service层的方法得到用户 User existUser = userService.login(user); // 如果没有得到用户 if (existUser == null) &#123; // 加入错误提示信息 this.addFieldError("loginFail", "用户名或者密码错误"); return ERROR; &#125; else &#123; // 登录成功，将用户信息压入栈中 ActionContext.getContext().getValueStack().push(existUser); return SUCCESS; &#125; &#125;&#125; 三.业务逻辑层(UserService)，UserServiceImpl实现UserService中的方法UserService.java 123456789package com.service;import com.domain.User;public interface UserService &#123; User login(User user);&#125; UserServiceImpl.java 1234567891011121314151617181920212223package com.service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.dao.UserDao;import com.domain.User;import com.service.UserService;// 该注解说明这是一个Service类型的Commpent@Service public class UserServiceImpl implements UserService&#123; // 自动装载UserDao @Autowired private UserDao userDao; public User login(User user) &#123; // 通过用户名和密码查找用户 User existUser = userDao.findUserByUsernamAndPassword(user); return existUse; &#125;&#125; 四.数据库操作层(UserDao)，UserDaoImpl实现UserDao中的方法UserDao.java 123456789package com.dao;import com.domain.User;public interface UserDao &#123; User findUserByUsernamAndPassword(User user);&#125; UserDaoImpl.java 12345678910111213141516171819202122232425262728293031package com.dao.impl;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.orm.hibernate5.HibernateTemplate;import org.springframework.stereotype.Repository;import com.dao.UserDao;import com.domain.User;// Dao层@Repositorypublic class UserDaoImpl implements UserDao&#123; // 自动装配hibernateTemplate,这个Bean需要在applicationContext.xml中注册 @Autowired private HibernateTemplate hibernateTemplate; public User findUserByUsernamAndPassword(User user) &#123; // hql语句 String hql = "from User where username=? and password=?"; // 查找对象 List&lt;User&gt; users = (List&lt;User&gt;) hibernateTemplate.find(hql, user.getUsername(), user.getPassword()); if (users.size() &gt; 0) &#123; // 查找到的对象用户名和密码唯一，所以如果找到的话，List中的第一个对象就是要找的对象 return users.get(0); &#125; return null; &#125;&#125; 五.实体层（User）User.java 12345678910111213141516171819202122232425262728293031323334353637383940package com.domain;import java.io.Serializable;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table;// 声明实体类映射@Entity@Table(name="User")public class User implements Serializable&#123; private Integer id; // id private String username; // 用户名 private String password; // 密码 // 主键 @Id @GeneratedValue(strategy=GenerationType.AUTO) // 主键生成策略 public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; 六.建立数据库关联在数据库中创建一个名字为_ssh的数据库jjdbc.properties 1234567891011121314151617jdbc.driver=com.mysql.cj.jdbc.Driver#\u5B9A\u4E49\u8FDE\u63A5\u7684URL\u5730\u5740\uFF0C\u8BBE\u7F6E\u7F16\u7801\u96C6\uFF0C\u65F6\u95F4\u57DF\uFF0C\u5141\u8BB8\u591A\u6761SQL\u8BED\u53E5\u64CD\u4F5C\u0153jdbc.url=jdbc:mysql://localhost:3306/_ssh?characterEncoding=utf-8&amp;serverTimezone=UTC&amp;allowMultiQueries=true#jdbc:mysql://localhost:3306/thcardb?characterEncoding=utf-8&amp;serverTimezone=UTC&amp;allowMultiQueries=truejdbc.username=root#jdbc.password=asd123asdjdbc.password=123#\u5B9A\u4E49\u521D\u59CB\u8FDE\u63A5\u6570initialSize=0#\u5B9A\u4E49\u6700\u5927\u8FDE\u63A5\u6570maxActive=20#\u5B9A\u4E49\u6700\u5927\u7A7A\u95F2maxIdle=20#\u5B9A\u4E49\u6700\u5C0F\u7A7A\u95F2minIdle=1#\u5B9A\u4E49\u6700\u957F\u7B49\u5F85\u65F6\u95F4maxWait=60000 将数据库相关的全部配置作为Bean交给Spring处理，applicationContext.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd"&gt; &lt;!-- 自动扫描包下面的Bean --&gt; &lt;context:component-scan base-package="com"/&gt; &lt;!-- 加载jdbc的属性文件 --&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="location" value="classpath:jdbc.properties" /&gt; &lt;/bean&gt; &lt;!-- druid配置数据源 --&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;!-- &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"&gt;&lt;/property&gt; --&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置SessionFactory --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt; &lt;!-- 配置数据源 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 其它hibernate配置 --&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.MySQL5Dialect&lt;/prop&gt; &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.format_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt; &lt;prop key="javax.persistence.validation.mode"&gt;none&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name="packagesToScan" value="com.domain"/&gt; &lt;/bean&gt; &lt;!-- 注册hibernateTemplate这个Bean --&gt; &lt;bean id="hibernateTemplate" class="org.springframework.orm.hibernate5.HibernateTemplate"&gt; &lt;property name="sessionFactory" ref="sessionFactory" /&gt; &lt;/bean&gt; &lt;/beans&gt; 测试： 启动，自动生成了表 在数据库中加一条数据 输入错误的用户名密码测试 输入正确的用户名密码测试 总结：MVC思想是贯穿WEB开发的，回想自己当初刚刚接触WEB开发时，学习thinkphp5框架一脸懵。当时刚刚大一结束，对编程的接触就是用C语言完成了一个通讯录管理程序。用C语言实现了简单的增删改查。接触WEB开发，先学html+css，学得不怎么样，连盒子模型都没有理解透，就开始接触Boostrap框架。后来隔了一个寒假，回去开始学习thinkphp5，连框架的概念都没有的我每天学习十分得痛苦。现在，离我离开实验室应该是4个月。我自己从零开始接触了java，四个月时间，我的进步还是可观的，回想大学这一年，发生的事情真的好多。]]></content>
      <categories>
        <category>ssh2</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>hibernate</tag>
        <tag>struts2</tag>
        <tag>ssh2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页制作的总结]]></title>
    <url>%2F2017%2F08%2F13%2Fweb%E5%89%8D%E7%AB%AF%2Fhtml%2Bcss%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一. 盒子模型 在css中，width和height指的是内容区域的宽度和高度，增加内边距，边框和外边距不会影响内容区域的尺寸，但是会增加元素框的尺寸。 二.清除浮动，清除默认样式12345678910111213```` /*清除默认样式*/body&#123; margin: 0px; padding: 0px;&#125;/*清除浮动*/.clearfix &#123; zoom: 1; display: table;&#125;```` 三.使用float应该注意 float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。注释：假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止。 注意，图片本身有高度和宽度。其他浮动元素会碰到它的边框停下。 这就是文字环绕图片的原理。 浮动会让元素塌陷。即被浮动元素的父元素不具有高度。例如一个父元素包含了浮动元素，它将塌陷具有零高度。你可以按以下方法处理： 在浮动元素后加个div设置clear: both; height:0,overflow:hidden 使用clearfix; 设置父元素浮动; 四.制作弹出层 需要的知识点： 定位：absolute,relative,fixed 事件：onload,onclick DOM操作：getElementById(),scrollHeight(),clientHeight(),createElement(),appendChild(),removeChild().静止定位：相对与当前状态的屏幕静止。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Boostrap]]></title>
    <url>%2F2017%2F08%2F13%2Fweb%E5%89%8D%E7%AB%AF%2FBoostrap%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[一.响应式布局—查看Demo1.响应式布局的设计原则- 移动优先 在设计的初期就要考虑页面如何在多终端显示 - 渐进增强 充分发挥硬件设备的最大功能 2.头部声明 栅格系统进行响应式开发,头部设置响应的viewport 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;&gt; 3.网页开发中的单位： px px是相对于屏幕分辨率，大小无法跟随屏幕的放大和缩小，所有浏览器都支持 em 1em=16px(但不完全是,每个浏览器不一样)，em会继承父级元素的字体大小，IE部分浏览器不支持em rem rem和em类似,rem会继承根元素的字体大小，html{font-size:62.5%}(稳定)]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>boostrap</tag>
        <tag>响应式布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax+servlet实现百度智能提示搜索框--来自慕课课程]]></title>
    <url>%2F2017%2F08%2F08%2Fweb%E5%89%8D%E7%AB%AF%2Fajax%2Bservlet%E5%AE%9E%E7%8E%B0%E7%99%BE%E5%BA%A6%E6%99%BA%E8%83%BD%E6%8F%90%E7%A4%BA%E6%90%9C%E7%B4%A2%E6%A1%86--%E6%9D%A5%E8%87%AA%E6%85%95%E8%AF%BE%E8%AF%BE%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[查看Demo12345/** * @author xiaohejun * Man Always Remember Love Because of Romance Only. * */ 一.实现效果： 1.serach.jsp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;搜索&lt;/title&gt; &lt;style type="text/css"&gt; #myDiv &#123; position:absolute; left: 50%; top: 50%; margin-left: -200px; margin-top: -50px; &#125; .mouseOver&#123; background: #708090; color: #FFFAFA; &#125; .mouseOut&#123; background: #FFFAFA; color: #000000; &#125; &lt;/style&gt; &lt;script type="text/javascript"&gt; var xmlHttp; /*获得用户关联信息*/ function getMoreContents() &#123; // 首先获得用户输入 var content = document.getElementById("keyword"); if(content.value == "")&#123; return; &#125; // 然后给服务器发送用户输入类容，用ajax异步发送请求，获得一个对象，骄傲做xmlHttp xmlHttp = createXmlHttp(); // 要给服务器发送数据,escape()方法对字符串进行编码 var url="search?keyword=" + decodeURI(content.value); // 和服务器建立链接,true参数表示javascript脚本会在send()方法之后继续执行，而且不会等待来自服务器的响应 xmlHttp.open("GET",url); // 绑定一个回调方法，这个会调方法会在xmlHttp状态改变0-4，我们只关心4（complete）这个状态，完成之后，调用回调方法 xmlHttp.onreadystatechange=callback; xmlHttp.send(null); &#125; // 清空之前的数据 function clearContent() &#123; var tbody = document.getElementById("content_table_body"); var size = tbody.childNodes.length; for (var i = size-1; i &gt;= 0;i--) &#123; tbody.removeChild(tbody.childNodes[i]); &#125; document.getElementById("popDiv").style.border = "none"; &#125; //回调函数 function callback() &#123; if(xmlHttp.readyState==4)&#123; // 服务器响应成功 if(xmlHttp.status==200)&#123; // 交互成功，获得响应数据 var result = xmlHttp.responseText; // 解析成JSON格式 var json = eval("("+result+")"); // 获得数据之后，就可以动态显示这些数据，把这些数据展示到输入框的下面 setContent(json); &#125; &#125; &#125; // 设置关联数据的展示 function setContent(contents) &#123; clearContent(); setLocation(); var size = contents.length; for (var i = 0; i &lt; size; i++) &#123; var nextNode = contents[i]; var tr = document.createElement("tr"); var td = document.createElement("td"); td.setAttribute("border","0"); td.bgColor = "white"; td.onmouseover = function () &#123; this.className = 'mouseOver'; &#125;; td.onmouseout = function () &#123; this.className = 'mouseOut'; &#125; td.onmousedown = function() &#123; document.getElementById("keyword").value = this.innerHTML; &#125; var text = document.createTextNode(nextNode); td.appendChild(text); tr.appendChild(td); document.getElementById('content_table_body').appendChild(tr); &#125; &#125; // 获得xmlHttp对象 function createXmlHttp() &#123; // 对于大多数浏览器适用的 var xmlHttp; if (window.XMLHttpRequest) &#123; xmlHttp = new XMLHttpRequest(); &#125; // 要考虑浏览器的兼容 if (window.ActiveXObiect) &#123; xmlHttp = new ActiveXObiect("Microsoft.XMLHTTP"); if (!xmlHttp) &#123; xmlHttp = new ActiveXObiect("Msxml2.XMLHTTP"); &#125; &#125; return xmlHttp; &#125; function keywordBlur() &#123; clearContent(); &#125; // 设置显示的位置 function setLocation() &#123; // 关联信息的显示位置要和输入框一致 var content = document.getElementById("keyword"); // 输入框的宽度 var width = content.offsetWidth; // 到左边框的距离 var left = content["offsetLeft"]; // 到顶部的距离 var top = content["offsetTop"] + content.offsetHeight; // 获得显示数据的div var popDiv = document.getElementById("popDiv"); popDiv.style.border = "black 1px solid"; popDiv.style.left = left + "px"; popDiv.style.top = top + "px"; popDiv.style.width = width + "px"; document.getElementById("content_table").style.width = width + "px"; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="myDiv"&gt; &lt;!-- 输入框 --&gt; &lt;input type="text" size="50" id="keyword" onkeyup="getMoreContents()" onblur="keywordBlur()" onfocus="getMoreContents()"/&gt; &lt;input type="button" value="百度一下" width="50px"/&gt; &lt;!-- 内容展示的区域 --&gt; &lt;div id="popDiv"&gt; &lt;table id="content_table" bgcolor="#FFFAFA" border="0" cellspacing="0" cellpadding="0"&gt; &lt;tbody id="content_table_body"&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2.SearchServlet.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.servlet;import java.io.IOException;import java.util.ArrayList;import java.util.List;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import net.sf.json.JSONArray;/** * Servlet implementation class search */@WebServlet("/search")public class SearchServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; private static List&lt;String&gt; datas; /** * @see HttpServlet#HttpServlet() */ public SearchServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ static &#123; datas = new ArrayList&lt;String&gt;(); datas.add("ajax"); datas.add("ajax post"); datas.add("b啊哈"); datas.add("b哈"); datas.add("这是ajax"); datas.add("你全家都是ajax"); &#125; public List&lt;String&gt; getData(String keyword) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (String data : datas) &#123; if (data.contains(keyword)) &#123; list.add(data); &#125; &#125; return list; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException&#123; response.setCharacterEncoding("UTF-8"); request.setCharacterEncoding("UTF-8");; String keyword = request.getParameter("keyword"); List&lt;String&gt; listData = getData(keyword); response.getWriter().write(JSONArray.fromObject(listData).toString()); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doGet(request, response); &#125;&#125; 注意：不可以使用escape()函数编码，已经过时]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery+原生的javascript实现网站右侧导航定位--来自慕课课程]]></title>
    <url>%2F2017%2F08%2F08%2Fweb%E5%89%8D%E7%AB%AF%2Fjquery%2B%E5%8E%9F%E7%94%9F%E7%9A%84javascript%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%AB%99%E5%8F%B3%E4%BE%A7%E5%AF%BC%E8%88%AA%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[12345/** * @author xiaohejun * Man Always Remember Love Because of Romance Only. * */ 先看效果 demo的文件结构图你需要下载Jqueryjquery-3.2.1.js-jQuery+原生的javascript实现导航 -css -demo.css -js -demo.js -jquery-3.2.1.js -images -1.png -2.jpg -3.jpg -4.png -5.png -demo.html 界面原型demo.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;购物网站&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="css/demo.css"&gt; &lt;script src="js/jquery-3.2.1.js" rel="script"&gt;&lt;/script&gt; &lt;script src="js/demo.js" rel="script"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 菜单 --&gt; &lt;div id="menu"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#item1" class="current"&gt;1F 一楼&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#item2"&gt;2F 二楼&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#item3"&gt;3F 三楼&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#item4"&gt;4F 四楼&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#item5"&gt;5F 五楼&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="content"&gt; &lt;h1&gt;天狗购物&lt;/h1&gt; &lt;div id="item1" class="item"&gt; &lt;h2&gt;1F 男装&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.png" alt="1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="item2" class="item"&gt; &lt;h2&gt;2F 女装&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt="2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="item3" class="item"&gt; &lt;h2&gt;3F 美妆&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt="3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="item4" class="item"&gt; &lt;h2&gt;4F 数码&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.png" alt="4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="item5" class="item"&gt; &lt;h2&gt;5F 母婴&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.png" alt="5"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ##样式css/demo.css1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677* &#123; margin:0px; padding: 0px;&#125;body &#123; font-size: 12px; line-height: 1.7;&#125;li &#123; list-style: none;&#125;#content &#123; width: 800px; margin: 0 auto; padding: 20px;&#125;#content h1 &#123; color: red;&#125;#content .item &#123; padding: 20px; margin-bottom: 20px; border: 1px dotted red;&#125;#content .item h2 &#123; font-size: 16px; font-weight: bold; border-bottom: 2px solid red; margin-bottom: 10px;&#125;#content .item li&#123; display: inline; margin-right: 10px;&#125;#content .item li a img &#123; width: 230px; height: 230px; border: none;&#125;#menu &#123; position: fixed; top: 100px; left: 50%; margin-left: 400px; width: 80px;&#125;#menu ul li a&#123; display: block; margin: 5px 0; font-size: 14px; font-weight: bold; color: #333; width: 80px; height:50px; line-height: 50px; text-decoration: none; text-align:center;&#125;#menu ul li a:hover,#menu ul li a.current&#123; color: #ffffff; background: red;&#125; 动作操作js/demo.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * Created by 何军 on 2017/8/7. * 使用jquery */$(document).ready(function () &#123; // 滚动条发生滚动 $(window).scroll(function () &#123; // 滚动挑距离顶部的距离 var top = $(document).scrollTop(); // 获取menu var menu = $("#menu"); // 获取每一个框 var items = $("#content").find(".item"); var currentId = ""; // 当前的id items.each(function () &#123; // 遍历每一个item var m = $(this); // 取得当前对象 var itemTop = m.offset().top; // 获得当前item的距离顶位置 if(top &gt; itemTop-200)&#123; // 如果用户滚动的距离比当前item的距离顶部位置少200px currentId = "#" + m.attr("id"); // 设置currentId 为当前id &#125; else &#123; return false; // 过头了。直接返回false退出循环 &#125; &#125;); var currentLink = menu.find(".current"); // 找到class是current的导航。初始是item1 if(currentId &amp;&amp; currentLink.attr("href") !== currentId)&#123; // 如果currentId不是空并且当前导航的href不是当前的id currentLink.removeClass("current"); // 移走current的Class // 注意此处查找方法的字符串拼接。currentId要用引号 menu.find("[href=\"" + currentId +"\"]").addClass("current"); // 找到currentId的导航加上current的class &#125; &#125;); &#125;);/*// 使用原生的jswindow.onload = function () &#123; window.onscroll = function () &#123; var top = document.documentElement ? document.documentElement.scrollTop : document.body.scrollTop; var menus = document.getElementById("menu").getElementsByTagName("a"); var items = getByClassName(document.getElementById("content"), "item"); var currentId = ""; for(var i =0; i &lt; items.length; i++) &#123; var _item = items[i]; var _itemTop = _item.offsetTop; if (top &gt; _itemTop - 200) &#123; currentId = _item.id; &#125; else &#123; break; &#125; &#125; if(currentId) &#123; // 给正确的menu的a元素current赋值 for (var i = 0; i &lt; menus.length; i++) &#123; var _menu = menus[i]; var _href = _menu.href.split("#"); if (_href[_href.length-1] !== currentId) &#123; console.log(_href[_href.length-1]); removeClass(_menu, "current"); &#125; else &#123; addClass(_menu, "current"); &#125; &#125; &#125; &#125;&#125;function getByClassName(obj,cls) &#123; var elements = obj.getElementsByTagName("*"); var result = []; for (var i=0; i &lt; elements.length; i++) &#123; if(elements[i].className === cls) &#123; result.push(elements[i]); &#125; &#125; return result;&#125;function hasClass(obj, cls) &#123; return obj.className.match(new RegExp("(\\s|^)" + cls + "(\\s|$)"));&#125;function removeClass(obj, cls) &#123; if (hasClass( obj, cls)) &#123; var reg = new RegExp("(\\s|^)" + cls + "(\\s|$)"); console.log("cls="); console.log(cls); obj.className = obj.className.replace(reg," "); &#125;&#125;function addClass(obj, cls) &#123; if (!hasClass(obj, cls)) &#123; obj.className += " " + cls; &#125;&#125;*/]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>jquery</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
